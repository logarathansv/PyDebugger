Page: https://seaborn.pydata.org/api.html#plot-object
API reference # Objects interface # Plot object # Plot An interface for declaratively specifying statistical graphics. Mark objects # Dot marks Dot A mark suitable for dot plots or less-dense scatterplots. Dots A dot mark defined by strokes to better handle overplotting. Line marks Line A mark connecting data points with sorting along the orientation axis. Lines A faster but less-flexible mark for drawing many lines. Path A mark connecting data points in the order they appear. Paths A faster but less-flexible mark for drawing many paths. Dash A line mark drawn as an oriented segment for each datapoint. Range An oriented line mark drawn between min/max values. Bar marks Bar A bar mark drawn between baseline and data values. Bars A faster bar mark with defaults more suitable for histograms. Fill marks Area A fill mark drawn from a baseline to data values. Band A fill mark representing an interval between values. Text marks Text A textual mark to annotate or represent data values. Stat objects # Agg Aggregate data along the value axis using given method. Est Calculate a point estimate and error bar interval. Count Count distinct observations within groups. Hist Bin observations, count them, and optionally normalize or cumulate. KDE Compute a univariate kernel density estimate. Perc Replace observations with percentile values. PolyFit Fit a polynomial of the given order and resample data onto predicted curve. Move objects # Dodge Displacement and narrowing of overlapping marks along orientation axis. Jitter Random displacement along one or both axes to reduce overplotting. Norm Divisive scaling on the value axis after aggregating within groups. Stack Displacement of overlapping bar or area marks along the value axis. Shift Displacement of all marks with the same magnitude / direction. Scale objects # Boolean A scale with a discrete domain of True and False values. Continuous A numeric scale supporting norms and functional transforms. Nominal A categorical scale without relative importance / magnitude. Temporal A scale for date/time data. Base classes # Mark Base class for objects that visually represent data. Stat Base class for objects that apply statistical transformations. Move Base class for objects that apply simple positional transforms. Scale Base class for objects that map data values to visual properties. Function interface # Relational plots # relplot Figure-level interface for drawing relational plots onto a FacetGrid. scatterplot Draw a scatter plot with possibility of several semantic groupings. lineplot Draw a line plot with possibility of several semantic groupings. Distribution plots # displot Figure-level interface for drawing distribution plots onto a FacetGrid. histplot Plot univariate or bivariate histograms to show distributions of datasets. kdeplot Plot univariate or bivariate distributions using kernel density estimation. ecdfplot Plot empirical cumulative distribution functions. rugplot Plot marginal distributions by drawing ticks along the x and y axes. distplot DEPRECATED Categorical plots # catplot Figure-level interface for drawing categorical plots onto a FacetGrid. stripplot Draw a categorical scatterplot using jitter to reduce overplotting. swarmplot Draw a categorical scatterplot with points adjusted to be non-overlapping. boxplot Draw a box plot to show distributions with respect to categories. violinplot Draw a patch representing a KDE and add observations or box plot statistics. boxenplot Draw an enhanced box plot for larger datasets. pointplot Show point estimates and errors using lines with markers. barplot Show point estimates and errors as rectangular bars. countplot Show the counts of observations in each categorical bin using bars. Regression plots # lmplot Plot data and regression model fits across a FacetGrid. regplot Plot data and a linear regression model fit. residplot Plot the residuals of a linear regression. Matrix plots # heatmap Plot rectangular data as a color-encoded matrix. clustermap Plot a matrix dataset as a hierarchically-clustered heatmap. Multi-plot grids # Facet grids # FacetGrid Multi-plot grid for plotting conditional relationships. Pair grids # pairplot Plot pairwise relationships in a dataset. PairGrid Subplot grid for plotting pairwise relationships in a dataset. Joint grids # jointplot Draw a plot of two variables with bivariate and univariate graphs. JointGrid Grid for drawing a bivariate plot with marginal univariate plots. Themeing # set_theme Set aspects of the visual theme for all matplotlib and seaborn plots. axes_style Get the parameters that control the general style of the plots. set_style Set the parameters that control the general style of the plots. plotting_context Get the parameters that control the scaling of plot elements. set_context Set the parameters that control the scaling of plot elements. set_color_codes Change how matplotlib color shorthands are interpreted. reset_defaults Restore all RC params to default settings. reset_orig Restore all RC params to original settings (respects custom rc). set Alias for set_theme() , which is the preferred interface. Color palettes # set_palette Set the matplotlib color cycle using a seaborn palette. color_palette Return a list of colors or continuous colormap defining a palette. husl_palette Return hues with constant lightness and saturation in the HUSL system. hls_palette Return hues with constant lightness and saturation in the HLS system. cubehelix_palette Make a sequential palette from the cubehelix system. dark_palette Make a sequential palette that blends from dark to color . light_palette Make a sequential palette that blends from light to color . diverging_palette Make a diverging palette between two HUSL colors. blend_palette Make a palette that blends between a list of colors. xkcd_palette Make a palette with color names from the xkcd color survey. crayon_palette Make a palette with color names from Crayola crayons. mpl_palette Return a palette or colormap from the matplotlib registry. Palette widgets # choose_colorbrewer_palette Select a palette from the ColorBrewer set. choose_cubehelix_palette Launch an interactive widget to create a sequential cubehelix palette. choose_light_palette Launch an interactive widget to create a light sequential palette. choose_dark_palette Launch an interactive widget to create a dark sequential palette. choose_diverging_palette Launch an interactive widget to choose a diverging color palette. Utility functions # despine Remove the top and right spines from plot(s). move_legend Recreate a plot's legend at a new location. saturate Return a fully saturated color with the same hue. desaturate Decrease the saturation channel of a color by some percent. set_hls_values Independently manipulate the h, l, or s channels of a color. load_dataset Load an example dataset from the online repository (requires internet). get_dataset_names Report available example datasets, useful for reporting issues. get_data_home Return a path to the cache directory for example datasets.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Plot.html#seaborn.objects.Plot
seaborn.objects.Plot # class seaborn.objects. Plot ( * args , data = None , x = None , y = None , color = None , alpha = None , fill = None , marker = None , pointsize = None , stroke = None , linewidth = None , linestyle = None , fillcolor = None , fillalpha = None , edgewidth = None , edgestyle = None , edgecolor = None , edgealpha = None , text = None , halign = None , valign = None , offset = None , fontsize = None , xmin = None , xmax = None , ymin = None , ymax = None , group = None ) # An interface for declaratively specifying statistical graphics. Plots are constructed by initializing this class and adding one or more
layers, comprising a Mark and optional Stat or Move .  Additionally,
faceting variables or variable pairings may be defined to divide the space
into multiple subplots. The mappings from data values to visual properties
can be parametrized using scales, although the plot will try to infer good
defaults when scales are not explicitly defined. The constructor accepts a data source (a pandas.DataFrame or
dictionary with columnar values) and variable assignments. Variables can be
passed as keys to the data source or directly as data vectors.  If multiple
data-containing objects are provided, they will be index-aligned. The data source and variables defined in the constructor will be used for
all layers in the plot, unless overridden or disabled when adding a layer. The following variables can be defined in the constructor: x , y , color , alpha , fill , marker , pointsize , stroke , linewidth , linestyle , fillcolor , fillalpha , edgewidth , edgestyle , edgecolor , edgealpha , text , halign , valign , offset , fontsize , xmin , xmax , ymin , ymax , group The data , x , and y variables can be passed as positional arguments or
using keywords. Whether the first positional argument is interpreted as a
data source or x variable depends on its type. The methods of this class return a copy of the instance; use chaining to
build up a plot through multiple calls. Methods can be called in any order. Most methods only add information to the plot spec; no actual processing
happens until the plot is shown or saved. It is also possible to compile
the plot without rendering it to access the lower-level representation. Methods # Specification methods add Specify a layer of the visualization in terms of mark and data transform(s). scale Specify mappings from data units to visual properties. Subplot methods facet Produce subplots with conditional subsets of the data. pair Produce subplots by pairing multiple x and/or y variables. Customization methods layout Control the figure size and layout. label Control the labels and titles for axes, legends, and subplots. limit Control the range of visible data. share Control sharing of axis limits and ticks across subplots. theme Control the appearance of elements in the plot. Integration methods on Provide existing Matplotlib figure or axes for drawing the plot. Output methods plot Compile the plot spec and return the Plotter object. save Compile the plot and write it to a buffer or file on disk. show Compile the plot and display it by hooking into pyplot. Configuration # The Plot object’s default behavior can be configured through its Plot.config attribute. Notice that this is a property of the class, not a method on an instance. Theme configuration # Theme changes made through the the Plot.config interface will apply to all subsequent Plot instances. Use the Plot.theme() method to modify the theme on a plot-by-plot basis. The theme is a dictionary of matplotlib rc parameters . You can set individual parameters directly: so . Plot . config . theme [ "axes.facecolor" ] = "white" To change the overall style of the plot, update the theme with a dictionary of parameters, perhaps from one of seaborn’s theming functions: from seaborn import axes_style so . Plot . config . theme . update ( axes_style ( "whitegrid" )) To sync Plot with matplotlib’s global state, pass the rcParams dictionary: import matplotlib as mpl so . Plot . config . theme . update ( mpl . rcParams ) The theme can also be reset back to seaborn defaults: so . Plot . config . theme . reset () Display configuration # When returned from the last statement in a notebook cell, a Plot will be compiled and embedded in the notebook as an image. By default, the image is rendered as HiDPI PNG. Alternatively, it is possible to display the plots in SVG format: so . Plot . config . display [ "format" ] = "svg" SVG images use vector graphics with “infinite” resolution, so they will appear crisp at any amount of zoom. The downside is that each plot element is drawn separately, so the image data can get very heavy for certain kinds of plots (e.g., for dense scatterplots). The HiDPI scaling of the default PNG images will also inflate the size of the notebook they are stored in. (Unlike with SVG, PNG size will scale with the dimensions of the plot but not its complexity). When not useful, it can be disabled: so . Plot . config . display [ "hidpi" ] = False The embedded images are scaled down slightly — independently from the figure size or DPI — so that more information can be presented on the screen. The precise scaling factor is also configurable: so . Plot . config . display [ "scaling" ] = 0.7


Page: https://seaborn.pydata.org/generated/seaborn.objects.Dot.html#seaborn.objects.Dot
seaborn.objects.Dot # class seaborn.objects. Dot ( artist_kws=<factory> , marker=<'o'> , pointsize=<6> , stroke=<0.75> , color=<'C0'> , alpha=<1> , fill=<True> , edgecolor=<depend:color> , edgealpha=<depend:alpha> , edgewidth=<0.5> , edgestyle=<'-'> ) # A mark suitable for dot plots or less-dense scatterplots. This mark defines the following properties: marker , pointsize , stroke , color , alpha , fill , edgecolor , edgealpha , edgewidth , edgestyle See also Dots A dot mark defined by strokes to better handle overplotting. Examples This mark draws relatively large, filled dots by default: p1 = so . Plot ( tips , "total_bill" , "tip" ) p1 . add ( so . Dot ()) While Dots is a better choice for dense scatter plots, adding a thin edge can help to resolve individual points: p1 . add ( so . Dot ( edgecolor = "w" )) Dodging and jittering can also help to reduce overplotting, when
appropriate: ( so . Plot ( tips , "total_bill" , "day" , color = "sex" ) . add ( so . Dot (), so . Dodge (), so . Jitter ( .2 )) ) The larger dot size makes this mark well suited to representing values along a nominal scale: p2 = so . Plot ( glue , "Score" , "Model" ) . facet ( "Task" , wrap = 4 ) . limit ( x = ( - 5 , 105 )) p2 . add ( so . Dot ()) A number of properties can be set or mapped: ( p2 . add ( so . Dot ( pointsize = 6 ), color = "Year" , marker = "Encoder" ) . scale ( marker = [ "o" , "s" ], color = "flare" ) ) Note that the edge properties are parameterized differently for filled and unfilled markers; use stroke and color rather than edgewidth and edgecolor if the marker is unfilled: p2 . add ( so . Dot ( stroke = 1.5 ), fill = "Encoder" , color = "Encoder" ) Combine with Range to show error bars: ( so . Plot ( tips , x = "total_bill" , y = "day" ) . add ( so . Dot ( pointsize = 3 ), so . Shift ( y = .2 ), so . Jitter ( .2 )) . add ( so . Dot (), so . Agg ()) . add ( so . Range (), so . Est ( errorbar = ( "se" , 2 ))) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Dots.html#seaborn.objects.Dots
seaborn.objects.Dots # class seaborn.objects. Dots ( artist_kws=<factory> , marker=<rc:scatter.marker> , pointsize=<4> , stroke=<0.75> , color=<'C0'> , alpha=<1> , fill=<True> , fillcolor=<depend:color> , fillalpha=<0.2> ) # A dot mark defined by strokes to better handle overplotting. This mark defines the following properties: marker , pointsize , stroke , color , alpha , fill , fillcolor , fillalpha See also Dot A mark suitable for dot plots or less-dense scatterplots. Examples This mark draws relatively small, partially-transparent dots: p1 = so . Plot ( mpg , "horsepower" , "mpg" ) p1 . add ( so . Dots ()) Fixing or mapping the color property changes both the stroke (edge) and fill: p1 . add ( so . Dots (), color = "origin" ) These properties can be independently parametrized (although the resulting plot may not always be clear): ( p1 . add ( so . Dots ( fillalpha = .5 ), color = "origin" , fillcolor = "weight" ) . scale ( fillcolor = "binary" ) ) Filled and unfilled markers will happily mix: p1 . add ( so . Dots ( stroke = 1 ), marker = "origin" ) . scale ( marker = [ "o" , "x" , ( 6 , 2 , 1 )]) The partial opacity also helps to see local density when using jitter: ( so . Plot ( mpg , "horsepower" , "origin" ) . add ( so . Dots (), so . Jitter ( .25 )) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Line.html#seaborn.objects.Line
seaborn.objects.Line # class seaborn.objects. Line ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> , marker=<rc:lines.marker> , pointsize=<rc:lines.markersize> , fillcolor=<depend:color> , edgecolor=<depend:color> , edgewidth=<rc:lines.markeredgewidth> ) # A mark connecting data points with sorting along the orientation axis. This mark defines the following properties: color , alpha , linewidth , linestyle , marker , pointsize , fillcolor , edgecolor , edgewidth See also Path A mark connecting data points in the order they appear. Lines A faster but less-flexible mark for drawing many lines. Examples The mark draws a connecting line between sorted observations: so . Plot ( dowjones , "Date" , "Price" ) . add ( so . Line ()) Change the orientation to connect observations along the opposite axis
( orient="y" is redundant here; the plot would detect that the date
variable has a lower orientation priority than the price variable): so . Plot ( dowjones , x = "Price" , y = "Date" ) . add ( so . Line (), orient = "y" ) To replicate the same line multiple times, assign a group variable (but consider using Lines here instead): ( fmri . query ( "region == 'parietal' and event == 'stim'" ) . pipe ( so . Plot , "timepoint" , "signal" ) . add ( so . Line ( color = ".2" , linewidth = 1 ), group = "subject" ) ) When mapping variables to properties like color or linestyle , stat transforms are computed within each grouping: p = so . Plot ( fmri , "timepoint" , "signal" , color = "region" , linestyle = "event" ) p . add ( so . Line (), so . Agg ()) Combine with Band to show an error bar: ( p . add ( so . Line (), so . Agg ()) . add ( so . Band (), so . Est (), group = "event" ) ) Add markers to indicate values where the data were sampled: p . add ( so . Line ( marker = "o" , edgecolor = "w" ), so . Agg (), linestyle = None )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Lines.html#seaborn.objects.Lines
seaborn.objects.Lines # class seaborn.objects. Lines ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> ) # A faster but less-flexible mark for drawing many lines. This mark defines the following properties: color , alpha , linewidth , linestyle See also Line A mark connecting data points with sorting along the orientation axis. Examples Like Line , the mark draws a connecting line between sorted observations: so . Plot ( seaice , "Date" , "Extent" ) . add ( so . Lines ()) Compared to Line , this mark offers fewer settable properties, but it can have better performance when drawing a large number of lines: ( so . Plot ( x = seaice [ "Date" ] . dt . day_of_year , y = seaice [ "Extent" ], color = seaice [ "Date" ] . dt . year ) . facet ( seaice [ "Date" ] . dt . year . round ( - 1 )) . add ( so . Lines ( linewidth = .5 , color = "#bbca" ), col = None ) . add ( so . Lines ( linewidth = 1 )) . scale ( color = "ch:rot=-.2,light=.7" ) . layout ( size = ( 8 , 4 )) . label ( title = " {} s" . format ) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Path.html#seaborn.objects.Path
seaborn.objects.Path # class seaborn.objects. Path ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> , marker=<rc:lines.marker> , pointsize=<rc:lines.markersize> , fillcolor=<depend:color> , edgecolor=<depend:color> , edgewidth=<rc:lines.markeredgewidth> ) # A mark connecting data points in the order they appear. This mark defines the following properties: color , alpha , linewidth , linestyle , marker , pointsize , fillcolor , edgecolor , edgewidth See also Line A mark connecting data points with sorting along the orientation axis. Paths A faster but less-flexible mark for drawing many paths. Examples Unlike Line , this mark does not sort observations before plotting, making it suitable for plotting trajectories through a variable space: p = so . Plot ( healthexp , "Spending_USD" , "Life_Expectancy" , color = "Country" ) p . add ( so . Path ()) It otherwise offers the same set of options, including a number of properties that can be set or mapped: p . add ( so . Path ( marker = "o" , pointsize = 2 , linewidth = .75 , fillcolor = "w" ))


Page: https://seaborn.pydata.org/generated/seaborn.objects.Paths.html#seaborn.objects.Paths
seaborn.objects.Paths # class seaborn.objects. Paths ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> ) # A faster but less-flexible mark for drawing many paths. This mark defines the following properties: color , alpha , linewidth , linestyle See also Path A mark connecting data points in the order they appear. Examples Unlike Lines , this mark does not sort observations before plotting, making it suitable for plotting trajectories through a variable space: p = ( so . Plot ( networks ) . pair ( x = [ "5" , "8" , "12" , "15" ], y = [ "6" , "13" , "16" ], ) . layout ( size = ( 8 , 5 )) . share ( x = True , y = True ) ) p . add ( so . Paths ()) The mark has the same set of properties as Lines : p . add ( so . Paths ( linewidth = 1 , alpha = .8 ), color = "hemi" )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Dash.html#seaborn.objects.Dash
seaborn.objects.Dash # class seaborn.objects. Dash ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> , width=<0.8> ) # A line mark drawn as an oriented segment for each datapoint. This mark defines the following properties: color , alpha , linewidth , linestyle , |width| Examples A line segment is drawn for each datapoint, centered on the value along the orientation axis: p = so . Plot ( penguins , "species" , "body_mass_g" , color = "sex" ) p . add ( so . Dash ()) A number of properties can be mapped or set directly: p . add ( so . Dash ( alpha = .5 ), linewidth = "flipper_length_mm" ) The mark has a width property, which is relative to the spacing between orientation values: p . add ( so . Dash ( width = .5 )) When dodged, the width will automatically adapt: p . add ( so . Dash (), so . Dodge ()) This mark works well to show aggregate values when paired with a strip plot: ( p . add ( so . Dash (), so . Agg (), so . Dodge ()) . add ( so . Dots (), so . Dodge (), so . Jitter ()) ) When both coordinate variables are numeric, you can control the orientation explicitly: ( so . Plot ( penguins [ "body_mass_g" ], penguins [ "flipper_length_mm" ] . round ( - 1 ), ) . add ( so . Dash (), orient = "y" ) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Range.html#seaborn.objects.Range
seaborn.objects.Range # class seaborn.objects. Range ( artist_kws=<factory> , color=<'C0'> , alpha=<1> , linewidth=<rc:lines.linewidth> , linestyle=<rc:lines.linestyle> ) # An oriented line mark drawn between min/max values. This mark defines the following properties: color , alpha , linewidth , linestyle Examples This mark will often be used in the context of a stat transform that adds an errorbar interval: ( so . Plot ( penguins , x = "body_mass_g" , y = "species" , color = "sex" ) . add ( so . Dot (), so . Agg (), so . Dodge ()) . add ( so . Range (), so . Est ( errorbar = "sd" ), so . Dodge ()) ) One feature (or potential gotcha) is that the mark will pick up properties like linestyle and linewidth ; exclude those properties from the relevant layer if this behavior is undesired: ( so . Plot ( penguins , x = "sex" , y = "body_mass_g" , linestyle = "species" ) . facet ( "species" ) . add ( so . Line ( marker = "o" ), so . Agg ()) . add ( so . Range (), so . Est ( errorbar = "sd" )) ) It’s also possible to directly assign the minimum and maximum values for the range: ( penguins . rename_axis ( index = "penguin" ) . pipe ( so . Plot , x = "penguin" , ymin = "bill_depth_mm" , ymax = "bill_length_mm" ) . add ( so . Range (), color = "island" ) ) When min / max variables are neither computed as part of a
transform or explicitly assigned, the range will cover the full extent
of the data at each unique observation on the orient axis: ( so . Plot ( penguins , x = "sex" , y = "body_mass_g" ) . facet ( "species" ) . add ( so . Dots ( pointsize = 6 )) . add ( so . Range ( linewidth = 2 )) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Bar.html#seaborn.objects.Bar
seaborn.objects.Bar # class seaborn.objects. Bar ( artist_kws=<factory> , color=<'C0'> , alpha=<0.7> , fill=<True> , edgecolor=<depend:color> , edgealpha=<1> , edgewidth=<rc:patch.linewidth> , edgestyle=<'-'> , width=<0.8> , baseline=<0> ) # A bar mark drawn between baseline and data values. This mark defines the following properties: color , alpha , fill , edgecolor , edgealpha , edgewidth , edgestyle , |width| , |baseline| See also Bars A faster bar mark with defaults more suitable for histograms. Examples The mark draws discrete bars from a baseline to provided values: so . Plot ( flights [ "month" ], flights [ "passengers" ]) . add ( so . Bar ()) The bars are oriented depending on the x/y variable types and the orient parameter: so . Plot ( flights [ "passengers" ], flights [ "month" ]) . add ( so . Bar ()) A common usecase will be drawing histograms on a variable with a nominal
scale: so . Plot ( penguins , x = "species" ) . add ( so . Bar (), so . Hist ()) When mapping additional variables, the bars will overlap by default: so . Plot ( penguins , x = "species" , color = "sex" ) . add ( so . Bar (), so . Hist ()) Apply a move transform, such as a Dodge or Stack to resolve them: so . Plot ( penguins , x = "species" , color = "sex" ) . add ( so . Bar (), so . Hist (), so . Dodge ()) A number of properties can be mapped or set: ( so . Plot ( penguins , x = "species" , color = "sex" , alpha = "sex" , edgestyle = "sex" , ) . add ( so . Bar ( edgewidth = 2 ), so . Hist (), so . Dodge ( "fill" )) ) Combine with Range to plot an estimate with errorbars: ( so . Plot ( penguins , "body_mass_g" , "species" , color = "sex" ) . add ( so . Bar ( alpha = .5 ), so . Agg (), so . Dodge ()) . add ( so . Range (), so . Est ( errorbar = "sd" ), so . Dodge ()) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Bars.html#seaborn.objects.Bars
seaborn.objects.Bars # class seaborn.objects. Bars ( artist_kws=<factory> , color=<'C0'> , alpha=<0.7> , fill=<True> , edgecolor=<rc:patch.edgecolor> , edgealpha=<1> , edgewidth=<auto> , edgestyle=<'-'> , width=<1> , baseline=<0> ) # A faster bar mark with defaults more suitable for histograms. This mark defines the following properties: color , alpha , fill , edgecolor , edgealpha , edgewidth , edgestyle , |width| , |baseline| See also Bar A bar mark drawn between baseline and data values. Examples This mark draws bars between a baseline and a value. In contrast to Bar , the bars have a full width and thin edges by default; this makes this mark a better choice for a continuous histogram: p = so . Plot ( diamonds , "price" ) . scale ( x = "log" ) p . add ( so . Bars (), so . Hist ()) When mapping the color or other properties, bars will overlap by default; this is usually confusing: p . add ( so . Bars (), so . Hist (), color = "cut" ) Using a move transform, such as Stack or Dodge , will resolve the overlap (although faceting might often be a better approach): p . add ( so . Bars (), so . Hist (), so . Stack (), color = "cut" ) A number of different properties can be set or mapped: p . add ( so . Bars ( edgewidth = 0 ), so . Hist (), so . Stack (), alpha = "clarity" ) It is possible to draw unfilled bars, but you must override the default edge color: p . add ( so . Bars ( fill = False , edgecolor = "C0" , edgewidth = 1.5 ), so . Hist ()) It is also possible to narrow the bars, which may be useful for dealing with overlap in some cases: hist = so . Hist ( binwidth = .075 , binrange = ( 2 , 5 )) ( p . add ( so . Bars (), hist ) . add ( so . Bars ( color = ".9" , width = .5 ), hist , data = diamonds . query ( "cut == 'Ideal'" ) ) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Area.html#seaborn.objects.Area
seaborn.objects.Area # class seaborn.objects. Area ( artist_kws=<factory> , color=<'C0'> , alpha=<0.2> , fill=<True> , edgecolor=<depend:color> , edgealpha=<1> , edgewidth=<rc:patch.linewidth> , edgestyle=<'-'> , baseline=<0> ) # A fill mark drawn from a baseline to data values. This mark defines the following properties: color , alpha , fill , edgecolor , edgealpha , edgewidth , edgestyle , |baseline| See also Band A fill mark representing an interval between values. Examples p = so . Plot ( healthexp , "Year" , "Spending_USD" ) . facet ( "Country" , wrap = 3 ) p . add ( so . Area ()) The color property sets both the edge and fill color: p . add ( so . Area (), color = "Country" ) It’s also possible to map only the edgecolor : p . add ( so . Area ( color = ".5" , edgewidth = 2 ), edgecolor = "Country" ) The mark is drawn as a polygon, but it can be combined with Line to draw a shaded region by setting edgewidth=0 : p . add ( so . Area ( edgewidth = 0 )) . add ( so . Line ()) The layer’s orientation defines the axis that the mark fills from: p . add ( so . Area (), x = "Spending_USD" , y = "Year" , orient = "y" ) This mark can be stacked to show part-whole relationships: ( so . Plot ( healthexp , "Year" , "Spending_USD" , color = "Country" ) . add ( so . Area ( alpha = .7 ), so . Stack ()) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Band.html#seaborn.objects.Band
seaborn.objects.Band # class seaborn.objects. Band ( artist_kws=<factory> , color=<'C0'> , alpha=<0.2> , fill=<True> , edgecolor=<depend:color> , edgealpha=<1> , edgewidth=<0> , edgestyle=<'-'> ) # A fill mark representing an interval between values. This mark defines the following properties: color , alpha , fill , edgecolor , edgealpha , edgewidth , edgestyle See also Area A fill mark drawn from a baseline to data values. Examples The mark fills between pairs of data points to show an interval on the value axis: p = so . Plot ( seaice , x = "Day" , ymin = "1980" , ymax = "2019" ) p . add ( so . Band ()) By default it draws a faint ribbon with no edges, but edges can be added: p . add ( so . Band ( alpha = .5 , edgewidth = 2 )) The defaults are optimized for the main expected usecase, where the mark is combined with a line to show an errorbar interval: ( so . Plot ( fmri , x = "timepoint" , y = "signal" , color = "event" ) . add ( so . Band (), so . Est ()) . add ( so . Line (), so . Agg ()) ) When min/max values are not explicitly assigned or added in a transform, the band will cover the full extent of the data: ( so . Plot ( fmri , x = "timepoint" , y = "signal" , color = "event" ) . add ( so . Line ( linewidth = .5 ), group = "subject" ) . add ( so . Band ()) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Text.html#seaborn.objects.Text
seaborn.objects.Text # class seaborn.objects. Text ( artist_kws=<factory> , text=<''> , color=<'k'> , alpha=<1> , fontsize=<rc:font.size> , halign=<'center'> , valign=<'center_baseline'> , offset=<4> ) # A textual mark to annotate or represent data values. This mark defines the following properties: text , color , alpha , fontsize , halign , valign , offset Examples Add text at x/y locations on the plot: ( so . Plot ( glue , x = "SST-2" , y = "MRPC" , text = "Model" ) . add ( so . Text ()) ) Add bar annotations, horizontally-aligned with halign : ( so . Plot ( glue , x = "Average" , y = "Model" , text = "Average" ) . add ( so . Bar ()) . add ( so . Text ( color = "w" , halign = "right" )) ) Fine-tune the alignment using offset : ( so . Plot ( glue , x = "Average" , y = "Model" , text = "Average" ) . add ( so . Bar ()) . add ( so . Text ( color = "w" , halign = "right" , offset = 6 )) ) Add text above dots, mapping the text color with a third variable: ( so . Plot ( glue , x = "SST-2" , y = "MRPC" , color = "Encoder" , text = "Model" ) . add ( so . Dot ()) . add ( so . Text ( valign = "bottom" )) ) Map the text alignment for better use of space: ( so . Plot ( glue , x = "RTE" , y = "MRPC" , color = "Encoder" , text = "Model" ) . add ( so . Dot ()) . add ( so . Text (), halign = "Encoder" ) . scale ( halign = { "LSTM" : "left" , "Transformer" : "right" }) ) Use additional matplotlib parameters to control the appearance of the text: ( so . Plot ( glue , x = "RTE" , y = "MRPC" , color = "Encoder" , text = "Model" ) . add ( so . Dot ()) . add ( so . Text ({ "fontweight" : "bold" }), halign = "Encoder" ) . scale ( halign = { "LSTM" : "left" , "Transformer" : "right" }) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Agg.html#seaborn.objects.Agg
seaborn.objects.Agg # class seaborn.objects. Agg ( func = 'mean' ) # Aggregate data along the value axis using given method. Parameters : func str or callable Name of a pandas.Series method or a vector -> scalar function. See also objects.Est Aggregation with error bars. Examples The default behavior is to aggregate by taking a mean over each group: p = so . Plot ( diamonds , "clarity" , "carat" ) p . add ( so . Bar (), so . Agg ()) Other aggregation functions can be selected by name if they are pandas methods: p . add ( so . Bar (), so . Agg ( "median" )) It’s also possible to pass an arbitrary aggregation function: p . add ( so . Bar (), so . Agg ( lambda x : x . quantile ( .75 ) - x . quantile ( .25 ))) When other mapping variables are assigned, they’ll be used to define aggregation groups. With some marks, it may be helpful to use additional transforms, such as Dodge : p . add ( so . Bar (), so . Agg (), so . Dodge (), color = "cut" ) The variable that gets aggregated depends on the orientation of the layer, which is usually inferred from the coordinate variable types (but may also be specified with the orient parameter in Plot.add() ): so . Plot ( diamonds , "carat" , "clarity" ) . add ( so . Bar (), so . Agg ())


Page: https://seaborn.pydata.org/generated/seaborn.objects.Est.html#seaborn.objects.Est
seaborn.objects.Est # class seaborn.objects. Est ( func = 'mean' , errorbar = ('ci', 95) , n_boot = 1000 , seed = None ) # Calculate a point estimate and error bar interval. For more information about the various errorbar choices, see the errorbar tutorial . Additional variables: weight : When passed to a layer that uses this stat, a weighted estimate
will be computed. Note that use of weights currently limits the choice of
function and error bar method  to "mean" and "ci" , respectively. Parameters : func str or callable Name of a numpy.ndarray method or a vector -> scalar function. errorbar str, (str, float) tuple, or callable Name of errorbar method (one of “ci”, “pi”, “se” or “sd”), or a tuple
with a method name ane a level parameter, or a function that maps from a
vector to a (min, max) interval. n_boot int Number of bootstrap samples to draw for “ci” errorbars. seed int Seed for the PRNG used to draw bootstrap samples. Examples The default behavior is to compute the mean and 95% confidence interval (using bootstrapping): p = so . Plot ( diamonds , "clarity" , "carat" ) p . add ( so . Range (), so . Est ()) Other estimators may be selected by name if they are pandas methods: p . add ( so . Range (), so . Est ( "median" )) There are several options for computing the error bar interval, such as (scaled) standard errors: p . add ( so . Range (), so . Est ( errorbar = "se" )) The error bars can also represent the spread of the distribution around the estimate using (scaled) standard deviations: p . add ( so . Range (), so . Est ( errorbar = "sd" )) Because confidence intervals are computed using bootstrapping, there will be small amounts of randomness. Reduce the random variability by increasing the nubmer of bootstrap iterations (although this will be slower), or eliminate it by seeding the random number generator: p . add ( so . Range (), so . Est ( seed = 0 )) To compute a weighted estimate (and confidence interval), assign a weight variable in the layer where you use the stat: p . add ( so . Range (), so . Est (), weight = "price" )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Count.html#seaborn.objects.Count
seaborn.objects.Count # class seaborn.objects. Count # Count distinct observations within groups. See also Hist A more fully-featured transform including binning and/or normalization. Examples The transform counts distinct observations of the orientation variable defines a new variable on the opposite axis: so . Plot ( tips , x = "day" ) . add ( so . Bar (), so . Count ()) When additional mapping variables are defined, they are also used to define groups: so . Plot ( tips , x = "day" , color = "sex" ) . add ( so . Bar (), so . Count (), so . Dodge ()) Unlike Hist , numeric data are not binned before counting: so . Plot ( tips , x = "size" ) . add ( so . Bar (), so . Count ()) When the y variable is defined, the counts are assigned to the x variable: so . Plot ( tips , y = "size" ) . add ( so . Bar (), so . Count ())


Page: https://seaborn.pydata.org/generated/seaborn.objects.Hist.html#seaborn.objects.Hist
seaborn.objects.Hist # class seaborn.objects. Hist ( stat = 'count' , bins = 'auto' , binwidth = None , binrange = None , common_norm = True , common_bins = True , cumulative = False , discrete = False ) # Bin observations, count them, and optionally normalize or cumulate. Parameters : stat str Aggregate statistic to compute in each bin: count : the number of observations density : normalize so that the total area of the histogram equals 1 percent : normalize so that bar heights sum to 100 probability or proportion : normalize so that bar heights sum to 1 frequency : divide the number of observations by the bin width bins str, int, or ArrayLike Generic parameter that can be the name of a reference rule, the number
of bins, or the bin breaks. Passed to numpy.histogram_bin_edges() . binwidth float Width of each bin; overrides bins but can be used with binrange .
Note that if binwidth does not evenly divide the bin range, the actual
bin width used will be only approximately equal to the parameter value. binrange (min, max) Lowest and highest value for bin edges; can be used with either bins (when a number) or binwidth . Defaults to data extremes. common_norm bool or list of variables When not False , the normalization is applied across groups. Use True to normalize across all groups, or pass variable name(s) that
define normalization groups. common_bins bool or list of variables When not False , the same bins are used for all groups. Use True to
share bins across all groups, or pass variable name(s) to share within. cumulative bool If True, cumulate the bin values. discrete bool If True, set binwidth and binrange so that bins have unit width and
are centered on integer values Notes The choice of bins for computing and plotting a histogram can exert
substantial influence on the insights that one is able to draw from the
visualization. If the bins are too large, they may erase important features.
On the other hand, bins that are too small may be dominated by random
variability, obscuring the shape of the true underlying distribution. The
default bin size is determined using a reference rule that depends on the
sample size and variance. This works well in many cases, (i.e., with
“well-behaved” data) but it fails in others. It is always a good to try
different bin sizes to be sure that you are not missing something important.
This function allows you to specify bins in several different ways, such as
by setting the total number of bins to use, the width of each bin, or the
specific locations where the bins should break. Examples For discrete or categorical variables, this stat is commonly combined with a Bar mark: so . Plot ( penguins , "island" ) . add ( so . Bar (), so . Hist ()) When used to estimate a univariate distribution, it is better to use the Bars mark: p = so . Plot ( penguins , "flipper_length_mm" ) p . add ( so . Bars (), so . Hist ()) The granularity of the bins will influence whether the underlying distribution is accurately represented. Adjust it by setting the total number: p . add ( so . Bars (), so . Hist ( bins = 20 )) Alternatively, specify the width of the bins: p . add ( so . Bars (), so . Hist ( binwidth = 5 )) By default, the transform returns the count of observations in each bin. The counts can be normalized, e.g. to show a proportion: p . add ( so . Bars (), so . Hist ( stat = "proportion" )) When additional variables define groups, the default behavior is to normalize across all groups: p = p . facet ( "island" ) p . add ( so . Bars (), so . Hist ( stat = "proportion" )) Pass common_norm=False to normalize each distribution independently: p . add ( so . Bars (), so . Hist ( stat = "proportion" , common_norm = False )) Or, with more than one grouping varible, specify a subset to normalize within: p . add ( so . Bars (), so . Hist ( stat = "proportion" , common_norm = [ "col" ]), color = "sex" ) When distributions overlap it may be easier to discern their shapes with an Area mark: p . add ( so . Area (), so . Hist (), color = "sex" ) Or add Stack move to represent a part-whole relationship: p . add ( so . Bars (), so . Hist (), so . Stack (), color = "sex" )


Page: https://seaborn.pydata.org/generated/seaborn.objects.KDE.html#seaborn.objects.KDE
seaborn.objects.KDE # class seaborn.objects. KDE ( bw_adjust = 1 , bw_method = 'scott' , common_norm = True , common_grid = True , gridsize = 200 , cut = 3 , cumulative = False ) # Compute a univariate kernel density estimate. Parameters : bw_adjust float Factor that multiplicatively scales the value chosen using bw_method . Increasing will make the curve smoother. See Notes. bw_method string, scalar, or callable Method for determining the smoothing bandwidth to use. Passed directly
to scipy.stats.gaussian_kde ; see there for options. common_norm bool or list of variables If True , normalize so that the areas of all curves sums to 1.
If False , normalize each curve independently. If a list, defines
variable(s) to group by and normalize within. common_grid bool or list of variables If True , all curves will share the same evaluation grid.
If False , each evaluation grid is independent. If a list, defines
variable(s) to group by and share a grid within. gridsize int or None Number of points in the evaluation grid. If None, the density is
evaluated at the original datapoints. cut float Factor, multiplied by the kernel bandwidth, that determines how far
the evaluation grid extends past the extreme datapoints. When set to 0,
the curve is truncated at the data limits. cumulative bool If True, estimate a cumulative distribution function. Requires scipy. Notes The bandwidth , or standard deviation of the smoothing kernel, is an
important parameter. Much like histogram bin width, using the wrong
bandwidth can produce a distorted representation. Over-smoothing can erase
true features, while under-smoothing can create false ones. The default
uses a rule-of-thumb that works best for distributions that are roughly
bell-shaped. It is a good idea to check the default by varying bw_adjust . Because the smoothing is performed with a Gaussian kernel, the estimated
density curve can extend to values that may not make sense. For example, the
curve may be drawn over negative values when data that are naturally
positive. The cut parameter can be used to control the evaluation range,
but datasets that have many observations close to a natural boundary may be
better served by a different method. Similar distortions may arise when a dataset is naturally discrete or “spiky”
(containing many repeated observations of the same value). KDEs will always
produce a smooth curve, which could be misleading. The units on the density axis are a common source of confusion. While kernel
density estimation produces a probability distribution, the height of the curve
at each point gives a density, not a probability. A probability can be obtained
only by integrating the density across a range. The curve is normalized so
that the integral over all possible values is 1, meaning that the scale of
the density axis depends on the data values. If scipy is installed, its cython-accelerated implementation will be used. Examples This stat estimates transforms observations into a smooth function representing the estimated density: p = so . Plot ( penguins , x = "flipper_length_mm" ) p . add ( so . Area (), so . KDE ()) Adjust the smoothing bandwidth to see more or fewer details: p . add ( so . Area (), so . KDE ( bw_adjust = 0.25 )) The curve will extend beyond observed values in the dataset: p2 = p . add ( so . Bars ( alpha = .3 ), so . Hist ( "density" )) p2 . add ( so . Line (), so . KDE ()) Control the range of the density curve relative to the observations using cut : p2 . add ( so . Line (), so . KDE ( cut = 0 )) When observations are assigned to the y variable, the density will be shown for x : so . Plot ( penguins , y = "flipper_length_mm" ) . add ( so . Area (), so . KDE ()) Use gridsize to increase or decrease the resolution of the grid where the density is evaluated: p . add ( so . Dots (), so . KDE ( gridsize = 100 )) Or pass None to evaluate the density at the original datapoints: p . add ( so . Dots (), so . KDE ( gridsize = None )) Other variables will define groups for the estimation: p . add ( so . Area (), so . KDE (), color = "species" ) By default, the density is normalized across all groups (i.e., the joint density is shown); pass common_norm=False to show conditional densities: p . add ( so . Area (), so . KDE ( common_norm = False ), color = "species" ) Or pass a list of variables to condition on: ( p . facet ( "sex" ) . add ( so . Area (), so . KDE ( common_norm = [ "col" ]), color = "species" ) ) This stat can be combined with other transforms, such as Stack (when common_grid=True ): p . add ( so . Area (), so . KDE (), so . Stack (), color = "sex" ) Set cumulative=True to integrate the density: p . add ( so . Line (), so . KDE ( cumulative = True ))


Page: https://seaborn.pydata.org/generated/seaborn.objects.Perc.html#seaborn.objects.Perc
seaborn.objects.Perc # class seaborn.objects. Perc ( k = 5 , method = 'linear' ) # Replace observations with percentile values. Parameters : k list of numbers or int If a list of numbers, this gives the percentiles (in [0, 100]) to compute.
If an integer, compute k evenly-spaced percentiles between 0 and 100.
For example, k=5 computes the 0, 25, 50, 75, and 100th percentiles. method str Method for interpolating percentiles between observed datapoints.
See numpy.percentile() for valid options and more information. Examples The default behavior computes the quartiles and min/max of the input data: p = ( so . Plot ( diamonds , "cut" , "price" ) . scale ( y = "log" ) ) p . add ( so . Dot (), so . Perc ()) Passing an integer will compute that many evenly-spaced percentiles: p . add ( so . Dot (), so . Perc ( 20 )) Passing a list will compute exactly those percentiles: p . add ( so . Dot (), so . Perc ([ 10 , 25 , 50 , 75 , 90 ])) Combine with a range mark to show a percentile interval: ( so . Plot ( diamonds , "price" , "cut" ) . add ( so . Dots ( pointsize = 1 , alpha = .2 ), so . Jitter ( .3 )) . add ( so . Range ( color = "k" ), so . Perc ([ 25 , 75 ]), so . Shift ( y = .2 )) . scale ( x = "log" ) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.PolyFit.html#seaborn.objects.PolyFit
seaborn.objects.PolyFit # class seaborn.objects. PolyFit ( order = 2 , gridsize = 100 ) # Fit a polynomial of the given order and resample data onto predicted curve.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Dodge.html#seaborn.objects.Dodge
seaborn.objects.Dodge # class seaborn.objects. Dodge ( empty = 'keep' , gap = 0 , by = None ) # Displacement and narrowing of overlapping marks along orientation axis. Parameters : empty {‘keep’, ‘drop’, ‘fill’} gap float Size of gap between dodged marks. by list of variable names Variables to apply the movement to, otherwise use all. Examples This transform modifies both the width and position (along the orientation axis) of marks that would otherwise overlap: ( so . Plot ( tips , "day" , color = "time" ) . add ( so . Bar (), so . Count (), so . Dodge ()) ) By default, empty space may appear when variables are not fully crossed: p = so . Plot ( tips , "day" , color = "time" ) p . add ( so . Bar (), so . Count (), so . Dodge ()) The empty parameter handles this case; use it to fill out the space: p . add ( so . Bar (), so . Count (), so . Dodge ( empty = "fill" )) Or center the marks while using a consistent width: p . add ( so . Bar (), so . Count (), so . Dodge ( empty = "drop" )) Use gap to add a bit of spacing between dodged marks: p = so . Plot ( tips , "day" , "total_bill" , color = "sex" ) p . add ( so . Bar (), so . Agg ( "sum" ), so . Dodge ( gap = .1 )) When multiple semantic variables are used, each distinct group will be dodged: p . add ( so . Dot (), so . Dodge (), fill = "smoker" ) Use by to dodge only a subset of variables: p . add ( so . Dot (), so . Dodge ( by = [ "color" ]), fill = "smoker" ) When combining with other transforms (such as Jitter or Stack ), be mindful of the order that they are applied in: p . add ( so . Dot (), so . Dodge (), so . Jitter ())


Page: https://seaborn.pydata.org/generated/seaborn.objects.Jitter.html#seaborn.objects.Jitter
seaborn.objects.Jitter # class seaborn.objects. Jitter ( width=<default> , x=0 , y=0 , seed=None ) # Random displacement along one or both axes to reduce overplotting. Parameters : width float Magnitude of jitter, relative to mark width, along the orientation axis.
If not provided, the default value will be 0 when x or y are set, otherwise
there will be a small amount of jitter applied by default. x float Magnitude of jitter, in data units, along the x axis. y float Magnitude of jitter, in data units, along the y axis. Examples When used without any arguments, a small amount of jitter will be applied along the orientation axis: ( so . Plot ( penguins , "species" , "body_mass_g" ) . add ( so . Dots (), so . Jitter ()) ) The width parameter controls the amount of jitter relative to the spacing between the marks: ( so . Plot ( penguins , "species" , "body_mass_g" ) . add ( so . Dots (), so . Jitter ( .5 )) ) The width parameter always applies to the orientation axis, so the direction of jitter will adapt along with the orientation: ( so . Plot ( penguins , "body_mass_g" , "species" ) . add ( so . Dots (), so . Jitter ( .5 )) ) Because the width jitter is relative, it can be used when the orientation axis is numeric without further tweaking: ( so . Plot ( penguins [ "body_mass_g" ] . round ( - 3 ), penguins [ "flipper_length_mm" ]) . add ( so . Dots (), so . Jitter ()) ) In contrast to width , the x and y parameters always refer to specific axes and control the jitter in data units: ( so . Plot ( penguins [ "body_mass_g" ] . round ( - 3 ), penguins [ "flipper_length_mm" ]) . add ( so . Dots (), so . Jitter ( x = 100 )) ) Both x and y can be used in a single transform: ( so . Plot ( penguins [ "body_mass_g" ] . round ( - 3 ), penguins [ "flipper_length_mm" ] . round ( - 1 ), ) . add ( so . Dots (), so . Jitter ( x = 200 , y = 5 )) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Norm.html#seaborn.objects.Norm
seaborn.objects.Norm # class seaborn.objects. Norm ( func = 'max' , where = None , by = None , percent = False ) # Divisive scaling on the value axis after aggregating within groups. Parameters : func str or callable Function called on each group to define the comparison value. where str Query string defining the subset used to define the comparison values. by list of variables Variables used to define aggregation groups. percent bool If True, multiply the result by 100. Examples By default, this transform scales each group relative to its maximum value: ( so . Plot ( healthexp , x = "Year" , y = "Spending_USD" , color = "Country" ) . add ( so . Lines (), so . Norm ()) . label ( y = "Spending relative to maximum amount" ) ) Use where to constrain the values used to define a baseline, and percent to scale the output: ( so . Plot ( healthexp , x = "Year" , y = "Spending_USD" , color = "Country" ) . add ( so . Lines (), so . Norm ( where = "x == x.min()" , percent = True )) . label ( y = "Percent change in spending from 1970 baseline" ) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Stack.html#seaborn.objects.Stack
seaborn.objects.Stack # class seaborn.objects. Stack # Displacement of overlapping bar or area marks along the value axis. Examples This transform applies a vertical shift to eliminate overlap between marks with a baseline, such as Bar or Area : so . Plot ( titanic , x = "class" , color = "sex" ) . add ( so . Bar (), so . Count (), so . Stack ()) Stacking can make it much harder to compare values between groups that get shifted, but it can work well when depicting a part-whole relationship: ( so . Plot ( titanic , x = "age" , alpha = "alive" ) . facet ( "sex" ) . add ( so . Bars (), so . Hist ( binwidth = 10 ), so . Stack ()) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Shift.html#seaborn.objects.Shift
seaborn.objects.Shift # class seaborn.objects. Shift ( x = 0 , y = 0 ) # Displacement of all marks with the same magnitude / direction. Parameters : x, y float Magnitude of shift, in data units, along each axis. Examples Use this transform to layer multiple marks that would otherwise overlap and be hard to interpret: ( so . Plot ( penguins , "species" , "body_mass_g" ) . add ( so . Dots (), so . Jitter ()) . add ( so . Range (), so . Perc ([ 25 , 75 ]), so . Shift ( x = .2 )) ) For y variables with a nominal scale, bear in mind that the axis will be inverted and a positive shift will move downwards: ( so . Plot ( diamonds , "carat" , "clarity" ) . add ( so . Dots (), so . Jitter ()) . add ( so . Range (), so . Perc ([ 25 , 75 ]), so . Shift ( y = .25 )) )


Page: https://seaborn.pydata.org/generated/seaborn.objects.Boolean.html#seaborn.objects.Boolean
seaborn.objects.Boolean # class seaborn.objects. Boolean ( values = None ) # A scale with a discrete domain of True and False values. The behavior is similar to the Nominal scale, but property
mappings and legends will use a [True, False] ordering rather than
a sort using numeric rules. Coordinate variables accomplish this by
inverting axis limits so as to maintain underlying numeric positioning.
Input data are cast to boolean values, respecting missing data. tick ( locator = None ) # label ( formatter = None ) #


Page: https://seaborn.pydata.org/generated/seaborn.objects.Continuous.html#seaborn.objects.Continuous
seaborn.objects.Continuous # class seaborn.objects. Continuous ( values = None , norm = None , trans = None ) # A numeric scale supporting norms and functional transforms. tick ( locator = None , * , at = None , upto = None , count = None , every = None , between = None , minor = None ) # Configure the selection of ticks for the scale’s axis or legend. Parameters : locator matplotlib.ticker.Locator subclass Pre-configured matplotlib locator; other parameters will not be used. at sequence of floats Place ticks at these specific locations (in data units). upto int Choose “nice” locations for ticks, but do not exceed this number. count int Choose exactly this number of ticks, bounded by between or axis limits. every float Choose locations at this interval of separation (in data units). between pair of floats Bound upper / lower ticks when using every or count . minor int Number of unlabeled ticks to draw between labeled “major” ticks. Returns : scale Copy of self with new tick configuration. label ( formatter=None , * , like=None , base=<default> , unit=None ) # Configure the appearance of tick labels for the scale’s axis or legend. Parameters : formatter matplotlib.ticker.Formatter subclass Pre-configured formatter to use; other parameters will be ignored. like str or callable Either a format pattern (e.g., ".2f" ), a format string with fields named x and/or pos (e.g., "${x:.2f}" ), or a callable with a signature like f(x: float, pos: int) -> str . In the latter variants, x is passed as the
tick value and pos is passed as the tick index. base number Use log formatter (with scientific notation) having this value as the base.
Set to None to override the default formatter with a log transform. unit str or (str, str) tuple Use  SI prefixes with these units (e.g., with unit="g" , a tick value
of 5000 will appear as 5 kg ). When a tuple, the first element gives the
separator between the number and unit. Returns : scale Copy of self with new label configuration.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Nominal.html#seaborn.objects.Nominal
seaborn.objects.Nominal # class seaborn.objects. Nominal ( values = None , order = None ) # A categorical scale without relative importance / magnitude. tick ( locator = None ) # Configure the selection of ticks for the scale’s axis or legend. Note This API is under construction and will be enhanced over time.
At the moment, it is probably not very useful. Parameters : locator matplotlib.ticker.Locator subclass Pre-configured matplotlib locator; other parameters will not be used. Returns : Copy of self with new tick configuration. label ( formatter = None ) # Configure the selection of labels for the scale’s axis or legend. Note This API is under construction and will be enhanced over time.
At the moment, it is probably not very useful. Parameters : formatter matplotlib.ticker.Formatter subclass Pre-configured matplotlib formatter; other parameters will not be used. Returns : scale Copy of self with new tick configuration.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Temporal.html#seaborn.objects.Temporal
seaborn.objects.Temporal # class seaborn.objects. Temporal ( values = None , norm = None ) # A scale for date/time data. tick ( locator = None , * , upto = None ) # Configure the selection of ticks for the scale’s axis or legend. Note This API is under construction and will be enhanced over time. Parameters : locator matplotlib.ticker.Locator subclass Pre-configured matplotlib locator; other parameters will not be used. upto int Choose “nice” locations for ticks, but do not exceed this number. Returns : scale Copy of self with new tick configuration. label ( formatter = None , * , concise = False ) # Configure the appearance of tick labels for the scale’s axis or legend. Note This API is under construction and will be enhanced over time. Parameters : formatter matplotlib.ticker.Formatter subclass Pre-configured formatter to use; other parameters will be ignored. concise bool If True, use matplotlib.dates.ConciseDateFormatter to make
the tick labels as compact as possible. Returns : scale Copy of self with new label configuration.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Mark.html#seaborn.objects.Mark
seaborn.objects.Mark # class seaborn.objects. Mark ( artist_kws=<factory> ) # Base class for objects that visually represent data.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Stat.html#seaborn.objects.Stat
seaborn.objects.Stat # class seaborn.objects. Stat # Base class for objects that apply statistical transformations.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Move.html#seaborn.objects.Move
seaborn.objects.Move # class seaborn.objects. Move # Base class for objects that apply simple positional transforms.


Page: https://seaborn.pydata.org/generated/seaborn.objects.Scale.html#seaborn.objects.Scale
seaborn.objects.Scale # class seaborn.objects. Scale # Base class for objects that map data values to visual properties.


Page: https://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot
seaborn.relplot # seaborn. relplot ( data = None , * , x = None , y = None , hue = None , size = None , style = None , units = None , weights = None , row = None , col = None , col_wrap = None , row_order = None , col_order = None , palette = None , hue_order = None , hue_norm = None , sizes = None , size_order = None , size_norm = None , markers = None , dashes = None , style_order = None , legend = 'auto' , kind = 'scatter' , height = 5 , aspect = 1 , facet_kws = None , ** kwargs ) # Figure-level interface for drawing relational plots onto a FacetGrid. This function provides access to several different axes-level functions
that show the relationship between two variables with semantic mappings
of subsets. The kind parameter selects the underlying axes-level
function to use: scatterplot() (with kind="scatter" ; the default) lineplot() (with kind="line" ) Extra keyword arguments are passed to the underlying function, so you
should refer to the documentation for each to see kind-specific options. The relationship between x and y can be shown for different subsets
of the data using the hue , size , and style parameters. These
parameters control what visual semantics are used to identify the different
subsets. It is possible to show up to three dimensions independently by
using all three semantic types, but this style of plot can be hard to
interpret and is often ineffective. Using redundant semantics (i.e. both hue and style for the same variable) can be helpful for making
graphics more accessible. See the tutorial for more information. The default treatment of the hue (and to a lesser extent, size )
semantic, if present, depends on whether the variable is inferred to
represent “numeric” or “categorical” data. In particular, numeric variables
are represented with a sequential colormap by default, and the legend
entries show regular “ticks” with values that may or may not exist in the
data. This behavior can be controlled through various parameters, as
described and illustrated below. After plotting, the FacetGrid with the plot is returned and can
be used directly to tweak supporting plot details or add other layers. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Grouping variable that will produce elements with different colors.
Can be either categorical or numeric, although color mapping will
behave differently in latter case. size vector or key in data Grouping variable that will produce elements with different sizes.
Can be either categorical or numeric, although size mapping will
behave differently in latter case. style vector or key in data Grouping variable that will produce elements with different styles.
Can have a numeric dtype but will always be treated as categorical. units vector or key in data Grouping variable identifying sampling units. When used, a separate
line will be drawn for each unit with appropriate semantics, but no
legend entry will be added. Useful for showing distribution of
experimental replicates when exact identities are not needed. weights vector or key in data Data values or column used to compute weighted estimation.
Note that use of weights currently limits the choice of statistics
to a ‘mean’ estimator and ‘ci’ errorbar. row, col vectors or keys in data Variables that define subsets to plot on different facets. col_wrap int “Wrap” the column variable at this width, so that the column facets
span multiple rows. Incompatible with a row facet. row_order, col_order lists of strings Order to organize the rows and/or columns of the grid in, otherwise the
orders are inferred from the data objects. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. sizes list, dict, or tuple An object that determines how sizes are chosen when size is used.
List or dict arguments should provide a size for each unique data value,
which forces a categorical interpretation. The argument may also be a
min, max tuple. size_order list Specified order for appearance of the size variable levels,
otherwise they are determined from the data. Not relevant when the size variable is numeric. size_norm tuple or Normalize object Normalization in data units for scaling plot objects when the size variable is numeric. style_order list Specified order for appearance of the style variable levels
otherwise they are determined from the data. Not relevant when the style variable is numeric. dashes boolean, list, or dictionary Object determining how to draw the lines for different levels of the style variable. Setting to True will use default dash codes, or
you can pass a list of dash codes or a dictionary mapping levels of the style variable to dash codes. Setting to False will use solid
lines for all subsets. Dashes are specified as in matplotlib: a tuple
of (segment, gap) lengths, or an empty string to draw a solid line. markers boolean, list, or dictionary Object determining how to draw the markers for different levels of the style variable. Setting to True will use default markers, or
you can pass a list of markers or a dictionary mapping levels of the style variable to markers. Setting to False will draw
marker-less lines.  Markers are specified as in matplotlib. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. kind string Kind of plot to draw, corresponding to a seaborn relational plot.
Options are "scatter" or "line" . height scalar Height (in inches) of each facet. See also: aspect . aspect scalar Aspect ratio of each facet, so that aspect * height gives the width
of each facet in inches. facet_kws dict Dictionary of other keyword arguments to pass to FacetGrid . kwargs key, value pairings Other keyword arguments are passed through to the underlying plotting
function. Returns : FacetGrid An object managing one or more subplots that correspond to conditional data
subsets with convenient methods for batch-setting of axes attributes. Examples These examples will illustrate only some of the functionality that relplot() is capable of. For more information, consult the examples for scatterplot() and lineplot() , which are used when kind="scatter" or kind="line" , respectively. To illustrate kind="scatter" (the default style of plot), we will use the “tips” dataset: tips = sns . load_dataset ( "tips" ) tips . head () total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 Assigning x and y and any semantic mapping variables will draw a single plot: sns . relplot ( data = tips , x = "total_bill" , y = "tip" , hue = "day" ) Assigning a col variable creates a faceted figure with multiple subplots arranged across the columns of the grid: sns . relplot ( data = tips , x = "total_bill" , y = "tip" , hue = "day" , col = "time" ) Different variables can be assigned to facet on both the columns and rows: sns . relplot ( data = tips , x = "total_bill" , y = "tip" , hue = "day" , col = "time" , row = "sex" ) When the variable assigned to col has many levels, it can be “wrapped” across multiple rows: sns . relplot ( data = tips , x = "total_bill" , y = "tip" , hue = "time" , col = "day" , col_wrap = 2 ) Assigning multiple semantic variables can show multi-dimensional relationships, but be mindful to avoid making an overly-complicated plot. sns . relplot ( data = tips , x = "total_bill" , y = "tip" , col = "time" , hue = "time" , size = "size" , style = "sex" , palette = [ "b" , "r" ], sizes = ( 10 , 100 ) ) When there is a natural continuity to one of the variables, it makes more sense to show lines instead of points. To draw the figure using lineplot() , set kind="line" . We will illustrate this effect with the “fmri dataset: fmri = sns . load_dataset ( "fmri" ) fmri . head () subject timepoint event region signal 0 s13 18 stim parietal -0.017552 1 s5 14 stim parietal -0.080883 2 s12 18 stim parietal -0.081033 3 s11 18 stim parietal -0.046134 4 s10 18 stim parietal -0.037970 Using kind="line" offers the same flexibility for semantic mappings as kind="scatter" , but lineplot() transforms the data more before plotting. Observations are sorted by their x value, and repeated observations are aggregated. By default, the resulting plot shows the mean and 95% CI for each unit sns . relplot ( data = fmri , x = "timepoint" , y = "signal" , col = "region" , hue = "event" , style = "event" , kind = "line" , ) The size and shape of the figure is parametrized by the height and aspect ratio of each individual facet: sns . relplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "event" , style = "event" , col = "region" , height = 4 , aspect = .7 , kind = "line" ) The object returned by relplot() is always a FacetGrid , which has several methods that allow you to quickly tweak the title, labels, and other aspects of the plot: g = sns . relplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "event" , style = "event" , col = "region" , height = 4 , aspect = .7 , kind = "line" ) ( g . map ( plt . axhline , y = 0 , color = ".7" , dashes = ( 2 , 1 ), zorder = 0 ) . set_axis_labels ( "Timepoint" , "Percent signal change" ) . set_titles ( "Region: {col_name} cortex" ) . tight_layout ( w_pad = 0 )) It is also possible to use wide-form data with relplot() : flights_wide = ( sns . load_dataset ( "flights" ) . pivot ( index = "year" , columns = "month" , values = "passengers" ) ) Faceting is not an option in this case, but the plot will still take advantage of the external legend offered by FacetGrid : sns . relplot ( data = flights_wide , kind = "line" )


Page: https://seaborn.pydata.org/generated/seaborn.scatterplot.html#seaborn.scatterplot
seaborn.scatterplot # seaborn. scatterplot ( data = None , * , x = None , y = None , hue = None , size = None , style = None , palette = None , hue_order = None , hue_norm = None , sizes = None , size_order = None , size_norm = None , markers = True , style_order = None , legend = 'auto' , ax = None , ** kwargs ) # Draw a scatter plot with possibility of several semantic groupings. The relationship between x and y can be shown for different subsets
of the data using the hue , size , and style parameters. These
parameters control what visual semantics are used to identify the different
subsets. It is possible to show up to three dimensions independently by
using all three semantic types, but this style of plot can be hard to
interpret and is often ineffective. Using redundant semantics (i.e. both hue and style for the same variable) can be helpful for making
graphics more accessible. See the tutorial for more information. The default treatment of the hue (and to a lesser extent, size )
semantic, if present, depends on whether the variable is inferred to
represent “numeric” or “categorical” data. In particular, numeric variables
are represented with a sequential colormap by default, and the legend
entries show regular “ticks” with values that may or may not exist in the
data. This behavior can be controlled through various parameters, as
described and illustrated below. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Grouping variable that will produce points with different colors.
Can be either categorical or numeric, although color mapping will
behave differently in latter case. size vector or key in data Grouping variable that will produce points with different sizes.
Can be either categorical or numeric, although size mapping will
behave differently in latter case. style vector or key in data Grouping variable that will produce points with different markers.
Can have a numeric dtype but will always be treated as categorical. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. sizes list, dict, or tuple An object that determines how sizes are chosen when size is used.
List or dict arguments should provide a size for each unique data value,
which forces a categorical interpretation. The argument may also be a
min, max tuple. size_order list Specified order for appearance of the size variable levels,
otherwise they are determined from the data. Not relevant when the size variable is numeric. size_norm tuple or Normalize object Normalization in data units for scaling plot objects when the size variable is numeric. markers boolean, list, or dictionary Object determining how to draw the markers for different levels of the style variable. Setting to True will use default markers, or
you can pass a list of markers or a dictionary mapping levels of the style variable to markers. Setting to False will draw
marker-less lines.  Markers are specified as in matplotlib. style_order list Specified order for appearance of the style variable levels
otherwise they are determined from the data. Not relevant when the style variable is numeric. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs key, value mappings Other keyword arguments are passed down to matplotlib.axes.Axes.scatter() . Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. See also lineplot Plot data using lines. stripplot Plot a categorical scatter with jitter. swarmplot Plot a categorical scatter with non-overlapping points. Examples These examples will use the “tips” dataset, which has a mixture of numeric and categorical variables: tips = sns . load_dataset ( "tips" ) tips . head () total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 Passing long-form data and assigning x and y will draw a scatter plot between two variables: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" ) Assigning a variable to hue will map its levels to the color of the points: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "time" ) Assigning the same variable to style will also vary the markers and create a more accessible plot: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "time" , style = "time" ) Assigning hue and style to different variables will vary colors and markers independently: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "day" , style = "time" ) If the variable assigned to hue is numeric, the semantic mapping will be quantitative and use a different default palette: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "size" ) Pass the name of a categorical palette or explicit colors (as a Python list of dictionary) to force categorical mapping of the hue variable: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "size" , palette = "deep" ) If there are a large number of unique numeric values, the legend will show a representative, evenly-spaced set: tip_rate = tips . eval ( "tip / total_bill" ) . rename ( "tip_rate" ) sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = tip_rate ) A numeric variable can also be assigned to size to apply a semantic mapping to the areas of the points: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "size" , size = "size" ) Control the range of marker areas with sizes , and set legend="full" to force every unique value to appear in the legend: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "size" , size = "size" , sizes = ( 20 , 200 ), legend = "full" ) Pass a tuple of values or a matplotlib.colors.Normalize object to hue_norm to control the quantitative hue mapping: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "size" , size = "size" , sizes = ( 20 , 200 ), hue_norm = ( 0 , 7 ), legend = "full" ) Control the specific markers used to map the style variable by passing a Python list or dictionary of marker codes: markers = { "Lunch" : "s" , "Dinner" : "X" } sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , style = "time" , markers = markers ) Additional keyword arguments are passed to matplotlib.axes.Axes.scatter() , allowing you to directly set the attributes of the plot that are not semantically mapped: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , s = 100 , color = ".2" , marker = "+" ) The previous examples used a long-form dataset. When working with wide-form data, each column will be plotted against its index using both hue and style mapping: index = pd . date_range ( "1 1 2000" , periods = 100 , freq = "m" , name = "date" ) data = np . random . randn ( 100 , 4 ) . cumsum ( axis = 0 ) wide_df = pd . DataFrame ( data , index , [ "a" , "b" , "c" , "d" ]) sns . scatterplot ( data = wide_df ) Use relplot() to combine scatterplot() and FacetGrid . This allows grouping within additional categorical variables, and plotting them across multiple subplots. Using relplot() is safer than using FacetGrid directly, as it ensures synchronization of the semantic mappings across facets. sns . relplot ( data = tips , x = "total_bill" , y = "tip" , col = "time" , hue = "day" , style = "day" , kind = "scatter" )


Page: https://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot
seaborn.lineplot # seaborn. lineplot ( data = None , * , x = None , y = None , hue = None , size = None , style = None , units = None , weights = None , palette = None , hue_order = None , hue_norm = None , sizes = None , size_order = None , size_norm = None , dashes = True , markers = None , style_order = None , estimator = 'mean' , errorbar = ('ci', 95) , n_boot = 1000 , seed = None , orient = 'x' , sort = True , err_style = 'band' , err_kws = None , legend = 'auto' , ci = 'deprecated' , ax = None , ** kwargs ) # Draw a line plot with possibility of several semantic groupings. The relationship between x and y can be shown for different subsets
of the data using the hue , size , and style parameters. These
parameters control what visual semantics are used to identify the different
subsets. It is possible to show up to three dimensions independently by
using all three semantic types, but this style of plot can be hard to
interpret and is often ineffective. Using redundant semantics (i.e. both hue and style for the same variable) can be helpful for making
graphics more accessible. See the tutorial for more information. The default treatment of the hue (and to a lesser extent, size )
semantic, if present, depends on whether the variable is inferred to
represent “numeric” or “categorical” data. In particular, numeric variables
are represented with a sequential colormap by default, and the legend
entries show regular “ticks” with values that may or may not exist in the
data. This behavior can be controlled through various parameters, as
described and illustrated below. By default, the plot aggregates over multiple y values at each value of x and shows an estimate of the central tendency and a confidence
interval for that estimate. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Grouping variable that will produce lines with different colors.
Can be either categorical or numeric, although color mapping will
behave differently in latter case. size vector or key in data Grouping variable that will produce lines with different widths.
Can be either categorical or numeric, although size mapping will
behave differently in latter case. style vector or key in data Grouping variable that will produce lines with different dashes
and/or markers. Can have a numeric dtype but will always be treated
as categorical. units vector or key in data Grouping variable identifying sampling units. When used, a separate
line will be drawn for each unit with appropriate semantics, but no
legend entry will be added. Useful for showing distribution of
experimental replicates when exact identities are not needed. weights vector or key in data Data values or column used to compute weighted estimation.
Note that use of weights currently limits the choice of statistics
to a ‘mean’ estimator and ‘ci’ errorbar. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. sizes list, dict, or tuple An object that determines how sizes are chosen when size is used.
List or dict arguments should provide a size for each unique data value,
which forces a categorical interpretation. The argument may also be a
min, max tuple. size_order list Specified order for appearance of the size variable levels,
otherwise they are determined from the data. Not relevant when the size variable is numeric. size_norm tuple or Normalize object Normalization in data units for scaling plot objects when the size variable is numeric. dashes boolean, list, or dictionary Object determining how to draw the lines for different levels of the style variable. Setting to True will use default dash codes, or
you can pass a list of dash codes or a dictionary mapping levels of the style variable to dash codes. Setting to False will use solid
lines for all subsets. Dashes are specified as in matplotlib: a tuple
of (segment, gap) lengths, or an empty string to draw a solid line. markers boolean, list, or dictionary Object determining how to draw the markers for different levels of the style variable. Setting to True will use default markers, or
you can pass a list of markers or a dictionary mapping levels of the style variable to markers. Setting to False will draw
marker-less lines.  Markers are specified as in matplotlib. style_order list Specified order for appearance of the style variable levels
otherwise they are determined from the data. Not relevant when the style variable is numeric. estimator name of pandas method or callable or None Method for aggregating across multiple observations of the y variable at the same x level. If None , all observations will
be drawn. errorbar string, (string, number) tuple, or callable Name of errorbar method (either “ci”, “pi”, “se”, or “sd”), or a tuple
with a method name and a level parameter, or a function that maps from a
vector to a (min, max) interval, or None to hide errorbar. See the errorbar tutorial for more information. n_boot int Number of bootstraps to use for computing the confidence interval. seed int, numpy.random.Generator, or numpy.random.RandomState Seed or random number generator for reproducible bootstrapping. orient “x” or “y” Dimension along which the data are sorted / aggregated. Equivalently,
the “independent variable” of the resulting function. sort boolean If True, the data will be sorted by the x and y variables, otherwise
lines will connect points in the order they appear in the dataset. err_style “band” or “bars” Whether to draw the confidence intervals with translucent error bands
or discrete error bars. err_kws dict of keyword arguments Additional parameters to control the aesthetics of the error bars. The
kwargs are passed either to matplotlib.axes.Axes.fill_between() or matplotlib.axes.Axes.errorbar() , depending on err_style . legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. ci int or “sd” or None Size of the confidence interval to draw when aggregating. Deprecated since version 0.12.0: Use the new errorbar parameter for more flexibility. ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs key, value mappings Other keyword arguments are passed down to matplotlib.axes.Axes.plot() . Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. See also scatterplot Plot data using points. pointplot Plot point estimates and CIs using markers and lines. Examples The flights dataset has 10 years of monthly airline passenger data: flights = sns . load_dataset ( "flights" ) flights . head () year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 To draw a line plot using long-form data, assign the x and y variables: may_flights = flights . query ( "month == 'May'" ) sns . lineplot ( data = may_flights , x = "year" , y = "passengers" ) Pivot the dataframe to a wide-form representation: flights_wide = flights . pivot ( index = "year" , columns = "month" , values = "passengers" ) flights_wide . head () month Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec year 1949 112 118 132 129 121 135 148 148 136 119 104 118 1950 115 126 141 135 125 149 170 170 158 133 114 140 1951 145 150 178 163 172 178 199 199 184 162 146 166 1952 171 180 193 181 183 218 230 242 209 191 172 194 1953 196 196 236 235 229 243 264 272 237 211 180 201 To plot a single vector, pass it to data . If the vector is a pandas.Series , it will be plotted against its index: sns . lineplot ( data = flights_wide [ "May" ]) Passing the entire wide-form dataset to data plots a separate line for each column: sns . lineplot ( data = flights_wide ) Passing the entire dataset in long-form mode will aggregate over repeated values (each year) to show the mean and 95% confidence interval: sns . lineplot ( data = flights , x = "year" , y = "passengers" ) Assign a grouping semantic ( hue , size , or style ) to plot separate lines sns . lineplot ( data = flights , x = "year" , y = "passengers" , hue = "month" ) The same column can be assigned to multiple semantic variables, which can increase the accessibility of the plot: sns . lineplot ( data = flights , x = "year" , y = "passengers" , hue = "month" , style = "month" ) Use the orient parameter to aggregate and sort along the vertical dimension of the plot: sns . lineplot ( data = flights , x = "passengers" , y = "year" , orient = "y" ) Each semantic variable can also represent a different column. For that, we’ll need a more complex dataset: fmri = sns . load_dataset ( "fmri" ) fmri . head () subject timepoint event region signal 0 s13 18 stim parietal -0.017552 1 s5 14 stim parietal -0.080883 2 s12 18 stim parietal -0.081033 3 s11 18 stim parietal -0.046134 4 s10 18 stim parietal -0.037970 Repeated observations are aggregated even when semantic grouping is used: sns . lineplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "event" ) Assign both hue and style to represent two different grouping variables: sns . lineplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "region" , style = "event" ) When assigning a style variable, markers can be used instead of (or along with) dashes to distinguish the groups: sns . lineplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "event" , style = "event" , markers = True , dashes = False ) Show error bars instead of error bands and extend them to two standard error widths: sns . lineplot ( data = fmri , x = "timepoint" , y = "signal" , hue = "event" , err_style = "bars" , errorbar = ( "se" , 2 ), ) Assigning the units variable will plot multiple lines without applying a semantic mapping: sns . lineplot ( data = fmri . query ( "region == 'frontal'" ), x = "timepoint" , y = "signal" , hue = "event" , units = "subject" , estimator = None , lw = 1 , ) Load another dataset with a numeric grouping variable: dots = sns . load_dataset ( "dots" ) . query ( "align == 'dots'" ) dots . head () align choice time coherence firing_rate 0 dots T1 -80 0.0 33.189967 1 dots T1 -80 3.2 31.691726 2 dots T1 -80 6.4 34.279840 3 dots T1 -80 12.8 32.631874 4 dots T1 -80 25.6 35.060487 Assigning a numeric variable to hue maps it differently, using a different default palette and a quantitative color mapping: sns . lineplot ( data = dots , x = "time" , y = "firing_rate" , hue = "coherence" , style = "choice" , ) Control the color mapping by setting the palette and passing a matplotlib.colors.Normalize object: sns . lineplot ( data = dots . query ( "coherence > 0" ), x = "time" , y = "firing_rate" , hue = "coherence" , style = "choice" , palette = "flare" , hue_norm = mpl . colors . LogNorm (), ) Or pass specific colors, either as a Python list or dictionary: palette = sns . color_palette ( "mako_r" , 6 ) sns . lineplot ( data = dots , x = "time" , y = "firing_rate" , hue = "coherence" , style = "choice" , palette = palette ) Assign the size semantic to map the width of the lines with a numeric variable: sns . lineplot ( data = dots , x = "time" , y = "firing_rate" , size = "coherence" , hue = "choice" , legend = "full" ) Pass a a tuple, sizes=(smallest, largest) , to control the range of linewidths used to map the size semantic: sns . lineplot ( data = dots , x = "time" , y = "firing_rate" , size = "coherence" , hue = "choice" , sizes = ( .25 , 2.5 ) ) By default, the observations are sorted by x . Disable this to plot a line with the order that observations appear in the dataset: x , y = np . random . normal ( size = ( 2 , 5000 )) . cumsum ( axis = 1 ) sns . lineplot ( x = x , y = y , sort = False , lw = 1 ) Use relplot() to combine lineplot() and FacetGrid . This allows grouping within additional categorical variables. Using relplot() is safer than using FacetGrid directly, as it ensures synchronization of the semantic mappings across facets: sns . relplot ( data = fmri , x = "timepoint" , y = "signal" , col = "region" , hue = "event" , style = "event" , kind = "line" )


Page: https://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot
seaborn.displot # seaborn. displot ( data = None , * , x = None , y = None , hue = None , row = None , col = None , weights = None , kind = 'hist' , rug = False , rug_kws = None , log_scale = None , legend = True , palette = None , hue_order = None , hue_norm = None , color = None , col_wrap = None , row_order = None , col_order = None , height = 5 , aspect = 1 , facet_kws = None , ** kwargs ) # Figure-level interface for drawing distribution plots onto a FacetGrid. This function provides access to several approaches for visualizing the
univariate or bivariate distribution of data, including subsets of data
defined by semantic mapping and faceting across multiple subplots. The kind parameter selects the approach to use: histplot() (with kind="hist" ; the default) kdeplot() (with kind="kde" ) ecdfplot() (with kind="ecdf" ; univariate-only) Additionally, a rugplot() can be added to any kind of plot to show
individual observations. Extra keyword arguments are passed to the underlying function, so you should
refer to the documentation for each to understand the complete set of options
for making plots with this interface. See the distribution plots tutorial for a more
in-depth discussion of the relative strengths and weaknesses of each approach.
The distinction between figure-level and axes-level functions is explained
further in the user guide . Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. row, col vectors or keys in data Variables that define subsets to plot on different facets. weights vector or key in data Observation weights used for computing the distribution function. kind {“hist”, “kde”, “ecdf”} Approach for visualizing the data. Selects the underlying plotting function
and determines the additional set of valid parameters. rug bool If True, show each observation with marginal ticks (as in rugplot() ). rug_kws dict Parameters to control the appearance of the rug plot. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. legend bool If False, suppress the legend for semantic variables. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. color matplotlib color Single color specification for when hue mapping is not used. Otherwise, the
plot will try to hook into the matplotlib property cycle. col_wrap int “Wrap” the column variable at this width, so that the column facets
span multiple rows. Incompatible with a row facet. {row,col}_order vector of strings Specify the order in which levels of the row and/or col variables
appear in the grid of subplots. height scalar Height (in inches) of each facet. See also: aspect . aspect scalar Aspect ratio of each facet, so that aspect * height gives the width
of each facet in inches. facet_kws dict Additional parameters passed to FacetGrid . kwargs Other keyword arguments are documented with the relevant axes-level function: histplot() (with kind="hist" ) kdeplot() (with kind="kde" ) ecdfplot() (with kind="ecdf" ) Returns : FacetGrid An object managing one or more subplots that correspond to conditional data
subsets with convenient methods for batch-setting of axes attributes. See also histplot Plot a histogram of binned counts with optional normalization or smoothing. kdeplot Plot univariate or bivariate distributions using kernel density estimation. rugplot Plot a tick at each observation value along the x and/or y axes. ecdfplot Plot empirical cumulative distribution functions. jointplot Draw a bivariate plot with univariate marginal distributions. Examples See the API documentation for the axes-level functions for more details
about the breadth of options available for each plot kind. The default plot kind is a histogram: penguins = sns . load_dataset ( "penguins" ) sns . displot ( data = penguins , x = "flipper_length_mm" ) Use the kind parameter to select a different representation: sns . displot ( data = penguins , x = "flipper_length_mm" , kind = "kde" ) There are three main plot kinds; in addition to histograms and kernel
density estimates (KDEs), you can also draw empirical cumulative
distribution functions (ECDFs): sns . displot ( data = penguins , x = "flipper_length_mm" , kind = "ecdf" ) While in histogram mode, it is also possible to add a KDE curve: sns . displot ( data = penguins , x = "flipper_length_mm" , kde = True ) To draw a bivariate plot, assign both x and y : sns . displot ( data = penguins , x = "flipper_length_mm" , y = "bill_length_mm" ) Currently, bivariate plots are available only for histograms and KDEs: sns . displot ( data = penguins , x = "flipper_length_mm" , y = "bill_length_mm" , kind = "kde" ) For each kind of plot, you can also show individual observations with a
marginal “rug”: g = sns . displot ( data = penguins , x = "flipper_length_mm" , y = "bill_length_mm" , kind = "kde" , rug = True ) Each kind of plot can be drawn separately for subsets of data using hue mapping: sns . displot ( data = penguins , x = "flipper_length_mm" , hue = "species" , kind = "kde" ) Additional keyword arguments are passed to the appropriate underlying
plotting function, allowing for further customization: sns . displot ( data = penguins , x = "flipper_length_mm" , hue = "species" , multiple = "stack" ) The figure is constructed using a FacetGrid , meaning that you can also show subsets on distinct subplots, or “facets”: sns . displot ( data = penguins , x = "flipper_length_mm" , hue = "species" , col = "sex" , kind = "kde" ) Because the figure is drawn with a FacetGrid , you control its size and shape with the height and aspect parameters: sns . displot ( data = penguins , y = "flipper_length_mm" , hue = "sex" , col = "species" , kind = "ecdf" , height = 4 , aspect = .7 , ) The function returns the FacetGrid object with the plot, and you can use the methods on this object to customize it further: g = sns . displot ( data = penguins , y = "flipper_length_mm" , hue = "sex" , col = "species" , kind = "kde" , height = 4 , aspect = .7 , ) g . set_axis_labels ( "Density (a.u.)" , "Flipper length (mm)" ) g . set_titles ( " {col_name} penguins" )


Page: https://seaborn.pydata.org/generated/seaborn.histplot.html#seaborn.histplot
seaborn.histplot # seaborn. histplot ( data = None , * , x = None , y = None , hue = None , weights = None , stat = 'count' , bins = 'auto' , binwidth = None , binrange = None , discrete = None , cumulative = False , common_bins = True , common_norm = True , multiple = 'layer' , element = 'bars' , fill = True , shrink = 1 , kde = False , kde_kws = None , line_kws = None , thresh = 0 , pthresh = None , pmax = None , cbar = False , cbar_ax = None , cbar_kws = None , palette = None , hue_order = None , hue_norm = None , color = None , log_scale = None , legend = True , ax = None , ** kwargs ) # Plot univariate or bivariate histograms to show distributions of datasets. A histogram is a classic visualization tool that represents the distribution
of one or more variables by counting the number of observations that fall within
discrete bins. This function can normalize the statistic computed within each bin to estimate
frequency, density or probability mass, and it can add a smooth curve obtained
using a kernel density estimate, similar to kdeplot() . More information is provided in the user guide . Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. weights vector or key in data If provided, weight the contribution of the corresponding data points
towards the count in each bin by these factors. stat str Aggregate statistic to compute in each bin. count : show the number of observations in each bin frequency : show the number of observations divided by the bin width probability or proportion : normalize such that bar heights sum to 1 percent : normalize such that bar heights sum to 100 density : normalize such that the total area of the histogram equals 1 bins str, number, vector, or a pair of such values Generic bin parameter that can be the name of a reference rule,
the number of bins, or the breaks of the bins.
Passed to numpy.histogram_bin_edges() . binwidth number or pair of numbers Width of each bin, overrides bins but can be used with binrange . binrange pair of numbers or a pair of pairs Lowest and highest value for bin edges; can be used either
with bins or binwidth . Defaults to data extremes. discrete bool If True, default to binwidth=1 and draw the bars so that they are
centered on their corresponding data points. This avoids “gaps” that may
otherwise appear when using discrete (integer) data. cumulative bool If True, plot the cumulative counts as bins increase. common_bins bool If True, use the same bins when semantic variables produce multiple
plots. If using a reference rule to determine the bins, it will be computed
with the full dataset. common_norm bool If True and using a normalized statistic, the normalization will apply over
the full dataset. Otherwise, normalize each histogram independently. multiple {“layer”, “dodge”, “stack”, “fill”} Approach to resolving multiple elements when semantic mapping creates subsets.
Only relevant with univariate data. element {“bars”, “step”, “poly”} Visual representation of the histogram statistic.
Only relevant with univariate data. fill bool If True, fill in the space under the histogram.
Only relevant with univariate data. shrink number Scale the width of each bar relative to the binwidth by this factor.
Only relevant with univariate data. kde bool If True, compute a kernel density estimate to smooth the distribution
and show on the plot as (one or more) line(s).
Only relevant with univariate data. kde_kws dict Parameters that control the KDE computation, as in kdeplot() . line_kws dict Parameters that control the KDE visualization, passed to matplotlib.axes.Axes.plot() . thresh number or None Cells with a statistic less than or equal to this value will be transparent.
Only relevant with bivariate data. pthresh number or None Like thresh , but a value in [0, 1] such that cells with aggregate counts
(or other statistics, when used) up to this proportion of the total will be
transparent. pmax number or None A value in [0, 1] that sets that saturation point for the colormap at a value
such that cells below constitute this proportion of the total count (or
other statistic, when used). cbar bool If True, add a colorbar to annotate the color mapping in a bivariate plot.
Note: Does not currently support plots with a hue variable well. cbar_ax matplotlib.axes.Axes Pre-existing axes for the colorbar. cbar_kws dict Additional parameters passed to matplotlib.figure.Figure.colorbar() . palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. color matplotlib color Single color specification for when hue mapping is not used. Otherwise, the
plot will try to hook into the matplotlib property cycle. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. legend bool If False, suppress the legend for semantic variables. ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs Other keyword arguments are passed to one of the following matplotlib
functions: matplotlib.axes.Axes.bar() (univariate, element=”bars”) matplotlib.axes.Axes.fill_between() (univariate, other element, fill=True) matplotlib.axes.Axes.plot() (univariate, other element, fill=False) matplotlib.axes.Axes.pcolormesh() (bivariate) Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. See also displot Figure-level interface to distribution plot functions. kdeplot Plot univariate or bivariate distributions using kernel density estimation. rugplot Plot a tick at each observation value along the x and/or y axes. ecdfplot Plot empirical cumulative distribution functions. jointplot Draw a bivariate plot with univariate marginal distributions. Notes The choice of bins for computing and plotting a histogram can exert
substantial influence on the insights that one is able to draw from the
visualization. If the bins are too large, they may erase important features.
On the other hand, bins that are too small may be dominated by random
variability, obscuring the shape of the true underlying distribution. The
default bin size is determined using a reference rule that depends on the
sample size and variance. This works well in many cases, (i.e., with
“well-behaved” data) but it fails in others. It is always a good to try
different bin sizes to be sure that you are not missing something important.
This function allows you to specify bins in several different ways, such as
by setting the total number of bins to use, the width of each bin, or the
specific locations where the bins should break. Examples Assign a variable to x to plot a univariate distribution along the x axis: penguins = sns . load_dataset ( "penguins" ) sns . histplot ( data = penguins , x = "flipper_length_mm" ) Flip the plot by assigning the data variable to the y axis: sns . histplot ( data = penguins , y = "flipper_length_mm" ) Check how well the histogram represents the data by specifying a
different bin width: sns . histplot ( data = penguins , x = "flipper_length_mm" , binwidth = 3 ) You can also define the total number of bins to use: sns . histplot ( data = penguins , x = "flipper_length_mm" , bins = 30 ) Add a kernel density estimate to smooth the histogram, providing
complementary information about the shape of the distribution: sns . histplot ( data = penguins , x = "flipper_length_mm" , kde = True ) If neither x nor y is assigned, the dataset is treated as
wide-form, and a histogram is drawn for each numeric column: sns . histplot ( data = penguins ) You can otherwise draw multiple histograms from a long-form dataset with
hue mapping: sns . histplot ( data = penguins , x = "flipper_length_mm" , hue = "species" ) The default approach to plotting multiple distributions is to “layer”
them, but you can also “stack” them: sns . histplot ( data = penguins , x = "flipper_length_mm" , hue = "species" , multiple = "stack" ) Overlapping bars can be hard to visually resolve. A different approach
would be to draw a step function: sns . histplot ( penguins , x = "flipper_length_mm" , hue = "species" , element = "step" ) You can move even farther away from bars by drawing a polygon with
vertices in the center of each bin. This may make it easier to see the
shape of the distribution, but use with caution: it will be less obvious
to your audience that they are looking at a histogram: sns . histplot ( penguins , x = "flipper_length_mm" , hue = "species" , element = "poly" ) To compare the distribution of subsets that differ substantially in
size, use independent density normalization: sns . histplot ( penguins , x = "bill_length_mm" , hue = "island" , element = "step" , stat = "density" , common_norm = False , ) It’s also possible to normalize so that each bar’s height shows a
probability, proportion, or percent, which make more sense for discrete
variables: tips = sns . load_dataset ( "tips" ) sns . histplot ( data = tips , x = "size" , stat = "percent" , discrete = True ) You can even draw a histogram over categorical variables (although this
is an experimental feature): sns . histplot ( data = tips , x = "day" , shrink = .8 ) When using a hue semantic with discrete data, it can make sense to
“dodge” the levels: sns . histplot ( data = tips , x = "day" , hue = "sex" , multiple = "dodge" , shrink = .8 ) Real-world data is often skewed. For heavily skewed distributions, it’s better to define the bins in log space. Compare: planets = sns . load_dataset ( "planets" ) sns . histplot ( data = planets , x = "distance" ) To the log-scale version: sns . histplot ( data = planets , x = "distance" , log_scale = True ) There are also a number of options for how the histogram appears. You
can show unfilled bars: sns . histplot ( data = planets , x = "distance" , log_scale = True , fill = False ) Or an unfilled step function: sns . histplot ( data = planets , x = "distance" , log_scale = True , element = "step" , fill = False ) Step functions, especially when unfilled, make it easy to compare
cumulative histograms: sns . histplot ( data = planets , x = "distance" , hue = "method" , hue_order = [ "Radial Velocity" , "Transit" ], log_scale = True , element = "step" , fill = False , cumulative = True , stat = "density" , common_norm = False , ) When both x and y are assigned, a bivariate histogram is
computed and shown as a heatmap: sns . histplot ( penguins , x = "bill_depth_mm" , y = "body_mass_g" ) It’s possible to assign a hue variable too, although this will not
work well if data from the different levels have substantial overlap: sns . histplot ( penguins , x = "bill_depth_mm" , y = "body_mass_g" , hue = "species" ) Multiple color maps can make sense when one of the variables is
discrete: sns . histplot ( penguins , x = "bill_depth_mm" , y = "species" , hue = "species" , legend = False ) The bivariate histogram accepts all of the same options for computation
as its univariate counterpart, using tuples to parametrize x and y independently: sns . histplot ( planets , x = "year" , y = "distance" , bins = 30 , discrete = ( True , False ), log_scale = ( False , True ), ) The default behavior makes cells with no observations transparent,
although this can be disabled: sns . histplot ( planets , x = "year" , y = "distance" , bins = 30 , discrete = ( True , False ), log_scale = ( False , True ), thresh = None , ) It’s also possible to set the threshold and colormap saturation point in
terms of the proportion of cumulative counts: sns . histplot ( planets , x = "year" , y = "distance" , bins = 30 , discrete = ( True , False ), log_scale = ( False , True ), pthresh = .05 , pmax = .9 , ) To annotate the colormap, add a colorbar: sns . histplot ( planets , x = "year" , y = "distance" , bins = 30 , discrete = ( True , False ), log_scale = ( False , True ), cbar = True , cbar_kws = dict ( shrink = .75 ), )


Page: https://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot
seaborn.kdeplot # seaborn. kdeplot ( data = None , * , x = None , y = None , hue = None , weights = None , palette = None , hue_order = None , hue_norm = None , color = None , fill = None , multiple = 'layer' , common_norm = True , common_grid = False , cumulative = False , bw_method = 'scott' , bw_adjust = 1 , warn_singular = True , log_scale = None , levels = 10 , thresh = 0.05 , gridsize = 200 , cut = 3 , clip = None , legend = True , cbar = False , cbar_ax = None , cbar_kws = None , ax = None , ** kwargs ) # Plot univariate or bivariate distributions using kernel density estimation. A kernel density estimate (KDE) plot is a method for visualizing the
distribution of observations in a dataset, analogous to a histogram. KDE
represents the data using a continuous probability density curve in one or
more dimensions. The approach is explained further in the user guide . Relative to a histogram, KDE can produce a plot that is less cluttered and
more interpretable, especially when drawing multiple distributions. But it
has the potential to introduce distortions if the underlying distribution is
bounded or not smooth. Like a histogram, the quality of the representation
also depends on the selection of good smoothing parameters. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. weights vector or key in data If provided, weight the kernel density estimation using these values. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. color matplotlib color Single color specification for when hue mapping is not used. Otherwise, the
plot will try to hook into the matplotlib property cycle. fill bool or None If True, fill in the area under univariate density curves or between
bivariate contours. If None, the default depends on multiple . multiple {{“layer”, “stack”, “fill”}} Method for drawing multiple elements when semantic mapping creates subsets.
Only relevant with univariate data. common_norm bool If True, scale each conditional density by the number of observations
such that the total area under all densities sums to 1. Otherwise,
normalize each density independently. common_grid bool If True, use the same evaluation grid for each kernel density estimate.
Only relevant with univariate data. cumulative bool, optional If True, estimate a cumulative distribution function. Requires scipy. bw_method string, scalar, or callable, optional Method for determining the smoothing bandwidth to use; passed to scipy.stats.gaussian_kde . bw_adjust number, optional Factor that multiplicatively scales the value chosen using bw_method . Increasing will make the curve smoother. See Notes. warn_singular bool If True, issue a warning when trying to estimate the density of data
with zero variance. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. levels int or vector Number of contour levels or values to draw contours at. A vector argument
must have increasing values in [0, 1]. Levels correspond to iso-proportions
of the density: e.g., 20% of the probability mass will lie below the
contour drawn for 0.2. Only relevant with bivariate data. thresh number in [0, 1] Lowest iso-proportion level at which to draw a contour line. Ignored when levels is a vector. Only relevant with bivariate data. gridsize int Number of points on each dimension of the evaluation grid. cut number, optional Factor, multiplied by the smoothing bandwidth, that determines how
far the evaluation grid extends past the extreme datapoints. When
set to 0, truncate the curve at the data limits. clip pair of numbers or None, or a pair of such pairs Do not evaluate the density outside of these limits. legend bool If False, suppress the legend for semantic variables. cbar bool If True, add a colorbar to annotate the color mapping in a bivariate plot.
Note: Does not currently support plots with a hue variable well. cbar_ax matplotlib.axes.Axes Pre-existing axes for the colorbar. cbar_kws dict Additional parameters passed to matplotlib.figure.Figure.colorbar() . ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs Other keyword arguments are passed to one of the following matplotlib
functions: matplotlib.axes.Axes.plot() (univariate, fill=False ), matplotlib.axes.Axes.fill_between() (univariate, fill=True ), matplotlib.axes.Axes.contour() (bivariate, fill=False ), matplotlib.axes.contourf() (bivariate, fill=True ). Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. See also displot Figure-level interface to distribution plot functions. histplot Plot a histogram of binned counts with optional normalization or smoothing. ecdfplot Plot empirical cumulative distribution functions. jointplot Draw a bivariate plot with univariate marginal distributions. violinplot Draw an enhanced boxplot using kernel density estimation. Notes The bandwidth , or standard deviation of the smoothing kernel, is an
important parameter. Misspecification of the bandwidth can produce a
distorted representation of the data. Much like the choice of bin width in a
histogram, an over-smoothed curve can erase true features of a
distribution, while an under-smoothed curve can create false features out of
random variability. The rule-of-thumb that sets the default bandwidth works
best when the true distribution is smooth, unimodal, and roughly bell-shaped.
It is always a good idea to check the default behavior by using bw_adjust to increase or decrease the amount of smoothing. Because the smoothing algorithm uses a Gaussian kernel, the estimated density
curve can extend to values that do not make sense for a particular dataset.
For example, the curve may be drawn over negative values when smoothing data
that are naturally positive. The cut and clip parameters can be used
to control the extent of the curve, but datasets that have many observations
close to a natural boundary may be better served by a different visualization
method. Similar considerations apply when a dataset is naturally discrete or “spiky”
(containing many repeated observations of the same value). Kernel density
estimation will always produce a smooth curve, which would be misleading
in these situations. The units on the density axis are a common source of confusion. While kernel
density estimation produces a probability distribution, the height of the curve
at each point gives a density, not a probability. A probability can be obtained
only by integrating the density across a range. The curve is normalized so
that the integral over all possible values is 1, meaning that the scale of
the density axis depends on the data values. Examples Plot a univariate distribution along the x axis: tips = sns . load_dataset ( "tips" ) sns . kdeplot ( data = tips , x = "total_bill" ) Flip the plot by assigning the data variable to the y axis: sns . kdeplot ( data = tips , y = "total_bill" ) Plot distributions for each column of a wide-form dataset: iris = sns . load_dataset ( "iris" ) sns . kdeplot ( data = iris ) Use less smoothing: sns . kdeplot ( data = tips , x = "total_bill" , bw_adjust = .2 ) Use more smoothing, but don’t smooth past the extreme data points: ax = sns . kdeplot ( data = tips , x = "total_bill" , bw_adjust = 5 , cut = 0 ) Plot conditional distributions with hue mapping of a second variable: sns . kdeplot ( data = tips , x = "total_bill" , hue = "time" ) “Stack” the conditional distributions: sns . kdeplot ( data = tips , x = "total_bill" , hue = "time" , multiple = "stack" ) Normalize the stacked distribution at each value in the grid: sns . kdeplot ( data = tips , x = "total_bill" , hue = "time" , multiple = "fill" ) Estimate the cumulative distribution function(s), normalizing each
subset: sns . kdeplot ( data = tips , x = "total_bill" , hue = "time" , cumulative = True , common_norm = False , common_grid = True , ) Estimate distribution from aggregated data, using weights: tips_agg = ( tips . groupby ( "size" ) . agg ( total_bill = ( "total_bill" , "mean" ), n = ( "total_bill" , "count" )) ) sns . kdeplot ( data = tips_agg , x = "total_bill" , weights = "n" ) Map the data variable with log scaling: diamonds = sns . load_dataset ( "diamonds" ) sns . kdeplot ( data = diamonds , x = "price" , log_scale = True ) Use numeric hue mapping: sns . kdeplot ( data = tips , x = "total_bill" , hue = "size" ) Modify the appearance of the plot: sns . kdeplot ( data = tips , x = "total_bill" , hue = "size" , fill = True , common_norm = False , palette = "crest" , alpha = .5 , linewidth = 0 , ) Plot a bivariate distribution: geyser = sns . load_dataset ( "geyser" ) sns . kdeplot ( data = geyser , x = "waiting" , y = "duration" ) Map a third variable with a hue semantic to show conditional
distributions: sns . kdeplot ( data = geyser , x = "waiting" , y = "duration" , hue = "kind" ) Show filled contours: sns . kdeplot ( data = geyser , x = "waiting" , y = "duration" , hue = "kind" , fill = True , ) Show fewer contour levels, covering less of the distribution: sns . kdeplot ( data = geyser , x = "waiting" , y = "duration" , hue = "kind" , levels = 5 , thresh = .2 , ) Fill the axes extent with a smooth distribution, using a different
colormap: sns . kdeplot ( data = geyser , x = "waiting" , y = "duration" , fill = True , thresh = 0 , levels = 100 , cmap = "mako" , )


Page: https://seaborn.pydata.org/generated/seaborn.ecdfplot.html#seaborn.ecdfplot
seaborn.ecdfplot # seaborn. ecdfplot ( data = None , * , x = None , y = None , hue = None , weights = None , stat = 'proportion' , complementary = False , palette = None , hue_order = None , hue_norm = None , log_scale = None , legend = True , ax = None , ** kwargs ) # Plot empirical cumulative distribution functions. An ECDF represents the proportion or count of observations falling below each
unique value in a dataset. Compared to a histogram or density plot, it has the
advantage that each observation is visualized directly, meaning that there are
no binning or smoothing parameters that need to be adjusted. It also aids direct
comparisons between multiple distributions. A downside is that the relationship
between the appearance of the plot and the basic properties of the distribution
(such as its central tendency, variance, and the presence of any bimodality)
may not be as intuitive. More information is provided in the user guide . Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. weights vector or key in data If provided, weight the contribution of the corresponding data points
towards the cumulative distribution using these values. stat {{“proportion”, “percent”, “count”}} Distribution statistic to compute. complementary bool If True, use the complementary CDF (1 - CDF) palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. legend bool If False, suppress the legend for semantic variables. ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs Other keyword arguments are passed to matplotlib.axes.Axes.plot() . Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. See also displot Figure-level interface to distribution plot functions. histplot Plot a histogram of binned counts with optional normalization or smoothing. kdeplot Plot univariate or bivariate distributions using kernel density estimation. rugplot Plot a tick at each observation value along the x and/or y axes. Examples Plot a univariate distribution along the x axis: penguins = sns . load_dataset ( "penguins" ) sns . ecdfplot ( data = penguins , x = "flipper_length_mm" ) Flip the plot by assigning the data variable to the y axis: sns . ecdfplot ( data = penguins , y = "flipper_length_mm" ) If neither x nor y is assigned, the dataset is treated as
wide-form, and a histogram is drawn for each numeric column: sns . ecdfplot ( data = penguins . filter ( like = "bill_" , axis = "columns" )) You can also draw multiple histograms from a long-form dataset with hue
mapping: sns . ecdfplot ( data = penguins , x = "bill_length_mm" , hue = "species" ) The default distribution statistic is normalized to show a proportion,
but you can show absolute counts or percents instead: sns . ecdfplot ( data = penguins , x = "bill_length_mm" , hue = "species" , stat = "count" ) It’s also possible to plot the empirical complementary CDF (1 - CDF): sns . ecdfplot ( data = penguins , x = "bill_length_mm" , hue = "species" , complementary = True )


Page: https://seaborn.pydata.org/generated/seaborn.rugplot.html#seaborn.rugplot
seaborn.rugplot # seaborn. rugplot ( data = None , * , x = None , y = None , hue = None , height = 0.025 , expand_margins = True , palette = None , hue_order = None , hue_norm = None , legend = True , ax = None , ** kwargs ) # Plot marginal distributions by drawing ticks along the x and y axes. This function is intended to complement other plots by showing the location
of individual observations in an unobtrusive way. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. height float Proportion of axes extent covered by each rug element. Can be negative. expand_margins bool If True, increase the axes margins by the height of the rug to avoid
overlap with other elements. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. legend bool If False, do not add a legend for semantic variables. ax matplotlib.axes.Axes Pre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally. kwargs Other keyword arguments are passed to matplotlib.collections.LineCollection() Returns : matplotlib.axes.Axes The matplotlib axes containing the plot. Examples Add a rug along one of the axes: import seaborn as sns ; sns . set_theme () tips = sns . load_dataset ( "tips" ) sns . kdeplot ( data = tips , x = "total_bill" ) sns . rugplot ( data = tips , x = "total_bill" ) Add a rug along both axes: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" ) sns . rugplot ( data = tips , x = "total_bill" , y = "tip" ) Represent a third variable with hue mapping: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" , hue = "time" ) sns . rugplot ( data = tips , x = "total_bill" , y = "tip" , hue = "time" ) Draw a taller rug: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" ) sns . rugplot ( data = tips , x = "total_bill" , y = "tip" , height = .1 ) Put the rug outside the axes: sns . scatterplot ( data = tips , x = "total_bill" , y = "tip" ) sns . rugplot ( data = tips , x = "total_bill" , y = "tip" , height =- .02 , clip_on = False ) Show the density of a larger dataset using thinner lines and alpha
blending: diamonds = sns . load_dataset ( "diamonds" ) sns . scatterplot ( data = diamonds , x = "carat" , y = "price" , s = 5 ) sns . rugplot ( data = diamonds , x = "carat" , y = "price" , lw = 1 , alpha = .005 )


Page: https://seaborn.pydata.org/generated/seaborn.distplot.html#seaborn.distplot
seaborn.distplot # seaborn. distplot ( a = None , bins = None , hist = True , kde = True , rug = False , fit = None , hist_kws = None , kde_kws = None , rug_kws = None , fit_kws = None , color = None , vertical = False , norm_hist = False , axlabel = None , label = None , ax = None , x = None ) # DEPRECATED This function has been deprecated and will be removed in seaborn v0.14.0.
It has been replaced by histplot() and displot() , two functions
with a modern API and many more capabilities. For a guide to updating, please see this notebook: https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751


Page: https://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot
seaborn.catplot # seaborn. catplot ( data=None , * , x=None , y=None , hue=None , row=None , col=None , kind='strip' , estimator='mean' , errorbar=('ci' , 95) , n_boot=1000 , seed=None , units=None , weights=None , order=None , hue_order=None , row_order=None , col_order=None , col_wrap=None , height=5 , aspect=1 , log_scale=None , native_scale=False , formatter=None , orient=None , color=None , palette=None , hue_norm=None , legend='auto' , legend_out=True , sharex=True , sharey=True , margin_titles=False , facet_kws=None , ci=<deprecated> , **kwargs ) # Figure-level interface for drawing categorical plots onto a FacetGrid. This function provides access to several axes-level functions that
show the relationship between a numerical and one or more categorical
variables using one of several visual representations. The kind parameter selects the underlying axes-level function to use. Categorical scatterplots: stripplot() (with kind="strip" ; the default) swarmplot() (with kind="swarm" ) Categorical distribution plots: boxplot() (with kind="box" ) violinplot() (with kind="violin" ) boxenplot() (with kind="boxen" ) Categorical estimate plots: pointplot() (with kind="point" ) barplot() (with kind="bar" ) countplot() (with kind="count" ) Extra keyword arguments are passed to the underlying function, so you
should refer to the documentation for each to see kind-specific options. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . After plotting, the FacetGrid with the plot is returned and can
be used directly to tweak supporting plot details or add other layers. Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. row, col names of variables in data or vector data Categorical variables that will determine the faceting of the grid. kind str The kind of plot to draw, corresponds to the name of a categorical
axes-level plotting function. Options are: “strip”, “swarm”, “box”, “violin”,
“boxen”, “point”, “bar”, or “count”. estimator string or callable that maps vector -> scalar Statistical function to estimate within each categorical bin. errorbar string, (string, number) tuple, callable or None Name of errorbar method (either “ci”, “pi”, “se”, or “sd”), or a tuple
with a method name and a level parameter, or a function that maps from a
vector to a (min, max) interval, or None to hide errorbar. See the errorbar tutorial for more information. New in version v0.12.0. n_boot int Number of bootstrap samples used to compute confidence intervals. seed int, numpy.random.Generator , or numpy.random.RandomState Seed or random number generator for reproducible bootstrapping. units name of variable in data or vector data Identifier of sampling units; used by the errorbar function to
perform a multilevel bootstrap and account for repeated measures weights name of variable in data or vector data Data values or column used to compute weighted statistics.
Note that the use of weights may limit other statistical options. New in version v0.13.1. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. row_order, col_order lists of strings Order to organize the rows and/or columns of the grid in; otherwise the
orders are inferred from the data objects. col_wrap int “Wrap” the column variable at this width, so that the column facets
span multiple rows. Incompatible with a row facet. height scalar Height (in inches) of each facet. See also: aspect . aspect scalar Aspect ratio of each facet, so that aspect * height gives the width
of each facet in inches. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. legend_out bool If True , the figure size will be extended, and the legend will be
drawn outside the plot on the center right. share{x,y} bool, ‘col’, or ‘row’ optional If true, the facets will share y axes across columns and/or x axes
across rows. margin_titles bool If True , the titles for the row variable are drawn to the right of
the last column. This option is experimental and may not work in all
cases. facet_kws dict Dictionary of other keyword arguments to pass to FacetGrid . kwargs key, value pairings Other keyword arguments are passed through to the underlying plotting
function. Returns : FacetGrid Returns the FacetGrid object with the plot on it for further
tweaking. Examples By default, the visual representation will be a jittered strip plot: df = sns . load_dataset ( "titanic" ) sns . catplot ( data = df , x = "age" , y = "class" ) Use kind to select a different representation: sns . catplot ( data = df , x = "age" , y = "class" , kind = "box" ) One advantage is that the legend will be automatically placed outside
the plot: sns . catplot ( data = df , x = "age" , y = "class" , hue = "sex" , kind = "boxen" ) Additional keyword arguments get passed through to the underlying
seaborn function: sns . catplot ( data = df , x = "age" , y = "class" , hue = "sex" , kind = "violin" , bw_adjust = .5 , cut = 0 , split = True , ) Assigning a variable to col or row will automatically create
subplots. Control figure size with the height and aspect parameters: sns . catplot ( data = df , x = "class" , y = "survived" , col = "sex" , kind = "bar" , height = 4 , aspect = .6 , ) For single-subplot figures, it is easy to layer different
representations: sns . catplot ( data = df , x = "age" , y = "class" , kind = "violin" , color = ".9" , inner = None ) sns . swarmplot ( data = df , x = "age" , y = "class" , size = 3 ) Use methods on the returned FacetGrid to tweak the presentation: g = sns . catplot ( data = df , x = "who" , y = "survived" , col = "class" , kind = "bar" , height = 4 , aspect = .6 , ) g . set_axis_labels ( "" , "Survival Rate" ) g . set_xticklabels ([ "Men" , "Women" , "Children" ]) g . set_titles ( " {col_name} {col_var} " ) g . set ( ylim = ( 0 , 1 )) g . despine ( left = True )


Page: https://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot
seaborn.stripplot # seaborn. stripplot ( data=None , * , x=None , y=None , hue=None , order=None , hue_order=None , jitter=True , dodge=False , orient=None , color=None , palette=None , size=5 , edgecolor=<default> , linewidth=0 , hue_norm=None , log_scale=None , native_scale=False , formatter=None , legend='auto' , ax=None , **kwargs ) # Draw a categorical scatterplot using jitter to reduce overplotting. A strip plot can be drawn on its own, but it is also a good complement
to a box or violin plot in cases where you want to show all observations
along with some representation of the underlying distribution. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. jitter float, True / 1 is special-cased Amount of jitter (only along the categorical axis) to apply. This
can be useful when you have many points and they overlap, so that
it is easier to see the distribution. You can specify the amount
of jitter (half the width of the uniform random variable support),
or use True for a good default. dodge bool When a hue variable is assigned, setting this to True will
separate the strips for different hue levels along the categorical
axis and narrow the amount of space allotedto each strip. Otherwise,
the points for each level will be plotted in the same strip. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. size float Radius of the markers, in points. edgecolor matplotlib color, “gray” is special-cased Color of the lines around each point. If you pass "gray" , the
brightness is determined by the color palette used for the body
of the points. Note that stripplot has linewidth=0 by default,
so edge colors are only visible with nonzero line width. linewidth float Width of the lines that frame the plot elements. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other keyword arguments are passed through to matplotlib.axes.Axes.scatter() . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also swarmplot A categorical scatterplot where the points do not overlap. Can be used with other plots to show each observation. boxplot A traditional box-and-whisker plot with a similar API. violinplot A combination of boxplot and kernel density estimation. catplot Combine a categorical plot with a FacetGrid . Examples Assigning a single numeric variable shows its univariate distribution with points randomly “jittered” on the other axis: tips = sns . load_dataset ( "tips" ) sns . stripplot ( data = tips , x = "total_bill" ) Assigning a second variable splits the strips of points to compare categorical levels of that variable: sns . stripplot ( data = tips , x = "total_bill" , y = "day" ) Show vertically-oriented strips by swapping the assignment of the categorical and numerical variables: sns . stripplot ( data = tips , x = "day" , y = "total_bill" ) Prior to version 0.12, the levels of the categorical variable had different colors by default. To get the same effect, assign the hue variable explicitly: sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "day" , legend = False ) Or you can assign a distinct variable to hue to show a multidimensional relationship: sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "sex" ) If the hue variable is numeric, it will be mapped with a quantitative palette by default (note that this was not the case prior to version 0.12): sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "size" ) Use palette to control the color mapping, including forcing a categorical mapping by passing the name of a qualitative palette: sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "size" , palette = "deep" ) By default, the different levels of the hue variable are intermingled in each strip, but setting dodge=True will split them: sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "sex" , dodge = True ) The random jitter can be disabled by setting jitter=False : sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "sex" , dodge = True , jitter = False ) If plotting in wide-form mode, each numeric column of the dataframe will
be mapped to both x and hue : sns . stripplot ( data = tips ) To change the orientation while in wide-form mode, pass orient explicitly: sns . stripplot ( data = tips , orient = "h" ) The orient parameter is also useful when both axis variables are numeric, as it will resolve ambiguity about which dimension to group (and jitter) along: sns . stripplot ( data = tips , x = "total_bill" , y = "size" , orient = "h" ) By default, the categorical variable will be mapped to discrete indices with a fixed scale (0, 1, …), even when it is numeric: sns . stripplot ( data = tips . query ( "size in [2, 3, 5]" ), x = "total_bill" , y = "size" , orient = "h" , ) To disable this behavior and use the original scale of the variable, set native_scale=True : sns . stripplot ( data = tips . query ( "size in [2, 3, 5]" ), x = "total_bill" , y = "size" , orient = "h" , native_scale = True , ) Further visual customization can be achieved by passing keyword arguments for matplotlib.axes.Axes.scatter() : sns . stripplot ( data = tips , x = "total_bill" , y = "day" , hue = "time" , jitter = False , s = 20 , marker = "D" , linewidth = 1 , alpha = .1 , ) To make a plot with multiple facets, it is safer to use catplot() than to work with FacetGrid directly, because catplot() will ensure that the categorical and hue variables are properly synchronized in each facet: sns . catplot ( data = tips , x = "time" , y = "total_bill" , hue = "sex" , col = "day" , aspect = .5 )


Page: https://seaborn.pydata.org/generated/seaborn.swarmplot.html#seaborn.swarmplot
seaborn.swarmplot # seaborn. swarmplot ( data = None , * , x = None , y = None , hue = None , order = None , hue_order = None , dodge = False , orient = None , color = None , palette = None , size = 5 , edgecolor = None , linewidth = 0 , hue_norm = None , log_scale = None , native_scale = False , formatter = None , legend = 'auto' , warn_thresh = 0.05 , ax = None , ** kwargs ) # Draw a categorical scatterplot with points adjusted to be non-overlapping. This function is similar to stripplot() , but the points are adjusted
(only along the categorical axis) so that they don’t overlap. This gives a
better representation of the distribution of values, but it does not scale
well to large numbers of observations. This style of plot is sometimes
called a “beeswarm”. A swarm plot can be drawn on its own, but it is also a good complement
to a box or violin plot in cases where you want to show all observations
along with some representation of the underlying distribution. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. dodge bool When a hue variable is assigned, setting this to True will
separate the swarms for different hue levels along the categorical
axis and narrow the amount of space allotedto each strip. Otherwise,
the points for each level will be plotted in the same swarm. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. size float Radius of the markers, in points. edgecolor matplotlib color, “gray” is special-cased Color of the lines around each point. If you pass "gray" , the
brightness is determined by the color palette used for the body
of the points. linewidth float Width of the lines that frame the plot elements. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other keyword arguments are passed through to matplotlib.axes.Axes.scatter() . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also boxplot A traditional box-and-whisker plot with a similar API. violinplot A combination of boxplot and kernel density estimation. stripplot A scatterplot where one variable is categorical. Can be used in conjunction with other plots to show each observation. catplot Combine a categorical plot with a FacetGrid . Examples Assigning a single numeric variable shows its univariate distribution with points adjusted along on the other axis such that they don’t overlap: tips = sns . load_dataset ( "tips" ) sns . swarmplot ( data = tips , x = "total_bill" ) Assigning a second variable splits the groups of points to compare categorical levels of that variable: sns . swarmplot ( data = tips , x = "total_bill" , y = "day" ) Show vertically-oriented swarms by swapping the assignment of the categorical and numerical variables: sns . swarmplot ( data = tips , x = "day" , y = "total_bill" ) Prior to version 0.12, the levels of the categorical variable had different colors by default. To get the same effect, assign the hue variable explicitly: sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , hue = "day" , legend = False ) Or you can assign a distinct variable to hue to show a multidimensional relationship: sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , hue = "sex" ) If the hue variable is numeric, it will be mapped with a quantitative palette by default (note that this was not the case prior to version 0.12): sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , hue = "size" ) Use palette to control the color mapping, including forcing a categorical mapping by passing the name of a qualitative palette: sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , hue = "size" , palette = "deep" ) By default, the different levels of the hue variable are intermingled in each swarm, but setting dodge=True will split them: sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , hue = "sex" , dodge = True ) The “orientation” of the plot (defined as the direction along which quantitative relationships are preserved) is usually inferred automatically. But in ambiguous cases, such as when both axis variables are numeric, it can be specified: sns . swarmplot ( data = tips , x = "total_bill" , y = "size" , orient = "h" ) / Users / mwaskom / code / seaborn / seaborn / categorical . py : 3399 : UserWarning : 15.4 % of the points cannot be placed ; you may want to decrease the size of the markers or use stripplot . warnings . warn ( msg , UserWarning ) / Users / mwaskom / code / seaborn / seaborn / categorical . py : 3399 : UserWarning : 17.3 % of the points cannot be placed ; you may want to decrease the size of the markers or use stripplot . warnings . warn ( msg , UserWarning ) When the local density of points is too high, they will be forced to overlap in the “gutters” of each swarm and a warning will be issued. Decreasing the size of the points can help to avoid this problem: sns . swarmplot ( data = tips , x = "total_bill" , y = "size" , orient = "h" , size = 3 ) By default, the categorical variable will be mapped to discrete indices with a fixed scale (0, 1, …), even when it is numeric: sns . swarmplot ( data = tips . query ( "size in [2, 3, 5]" ), x = "total_bill" , y = "size" , orient = "h" , ) To disable this behavior and use the original scale of the variable, set native_scale=True (notice how this also changes the order of the variables on the y axis): sns . swarmplot ( data = tips . query ( "size in [2, 3, 5]" ), x = "total_bill" , y = "size" , orient = "h" , native_scale = True , ) Further visual customization can be achieved by passing keyword arguments for matplotlib.axes.Axes.scatter() : sns . swarmplot ( data = tips , x = "total_bill" , y = "day" , marker = "x" , linewidth = 1 , ) To make a plot with multiple facets, it is safer to use catplot() with kind="swarm" than to work with FacetGrid directly, because catplot() will ensure that the categorical and hue variables are properly synchronized in each facet: sns . catplot ( data = tips , kind = "swarm" , x = "time" , y = "total_bill" , hue = "sex" , col = "day" , aspect = .5 )


Page: https://seaborn.pydata.org/generated/seaborn.boxplot.html#seaborn.boxplot
seaborn.boxplot # seaborn. boxplot ( data = None , * , x = None , y = None , hue = None , order = None , hue_order = None , orient = None , color = None , palette = None , saturation = 0.75 , fill = True , dodge = 'auto' , width = 0.8 , gap = 0 , whis = 1.5 , linecolor = 'auto' , linewidth = None , fliersize = None , hue_norm = None , native_scale = False , log_scale = None , formatter = None , legend = 'auto' , ax = None , ** kwargs ) # Draw a box plot to show distributions with respect to categories. A box plot (or box-and-whisker plot) shows the distribution of quantitative
data in a way that facilitates comparisons between variables or across
levels of a categorical variable. The box shows the quartiles of the
dataset while the whiskers extend to show the rest of the distribution,
except for points that are determined to be “outliers” using a method
that is a function of the inter-quartile range. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. saturation float Proportion of the original saturation to draw fill colors in. Large
patches often look better with desaturated colors, but set this to 1 if you want the colors to perfectly match the input values. fill bool If True, use a solid patch. Otherwise, draw as line art. New in version v0.13.0. dodge “auto” or bool When hue mapping is used, whether elements should be narrowed and shifted along
the orient axis to eliminate overlap. If "auto" , set to True when the
orient variable is crossed with the categorical variable or False otherwise. Changed in version 0.13.0: Added "auto" mode as a new default. width float Width allotted to each element on the orient axis. When native_scale=True ,
it is relative to the minimum distance between two values in the native scale. gap float Shrink on the orient axis by this factor to add a gap between dodged elements. New in version 0.13.0. whis float or pair of floats Paramater that controls whisker length. If scalar, whiskers are drawn
to the farthest datapoint within whis * IQR from the nearest hinge.
If a tuple, it is interpreted as percentiles that whiskers represent. linecolor color Color to use for line elements, when fill is True. New in version v0.13.0. linewidth float Width of the lines that frame the plot elements. fliersize float Size of the markers used to indicate outlier observations. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other keyword arguments are passed through to matplotlib.axes.Axes.boxplot() . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also violinplot A combination of boxplot and kernel density estimation. stripplot A scatterplot where one variable is categorical. Can be used in conjunction with other plots to show each observation. swarmplot A categorical scatterplot where the points do not overlap. Can be used with other plots to show each observation. catplot Combine a categorical plot with a FacetGrid . Examples Draw a single horizontal boxplot, assigning the data directly to the coordinate variable: sns . boxplot ( x = titanic [ "age" ]) Group by a categorical variable, referencing columns in a dataframe: sns . boxplot ( data = titanic , x = "age" , y = "class" ) Draw a vertical boxplot with nested grouping by two variables: sns . boxplot ( data = titanic , x = "class" , y = "age" , hue = "alive" ) Draw the boxes as line art and add a small gap between them: sns . boxplot ( data = titanic , x = "class" , y = "age" , hue = "alive" , fill = False , gap = .1 ) Cover the full range of the data with the whiskers: sns . boxplot ( data = titanic , x = "age" , y = "deck" , whis = ( 0 , 100 )) Draw narrower boxes: sns . boxplot ( data = titanic , x = "age" , y = "deck" , width = .5 ) Modify the color and width of all the line artists: sns . boxplot ( data = titanic , x = "age" , y = "deck" , color = ".8" , linecolor = "#137" , linewidth = .75 ) Group by a numeric variable and preserve its native scaling: ax = sns . boxplot ( x = titanic [ "age" ] . round ( - 1 ), y = titanic [ "fare" ], native_scale = True ) ax . axvline ( 25 , color = ".3" , dashes = ( 2 , 2 )) Customize the plot using parameters of the underlying matplotlib function: sns . boxplot ( data = titanic , x = "age" , y = "class" , notch = True , showcaps = False , flierprops = { "marker" : "x" }, boxprops = { "facecolor" : ( .3 , .5 , .7 , .5 )}, medianprops = { "color" : "r" , "linewidth" : 2 }, )


Page: https://seaborn.pydata.org/generated/seaborn.violinplot.html#seaborn.violinplot
seaborn.violinplot # seaborn. violinplot ( data=None , * , x=None , y=None , hue=None , order=None , hue_order=None , orient=None , color=None , palette=None , saturation=0.75 , fill=True , inner='box' , split=False , width=0.8 , dodge='auto' , gap=0 , linewidth=None , linecolor='auto' , cut=2 , gridsize=100 , bw_method='scott' , bw_adjust=1 , density_norm='area' , common_norm=False , hue_norm=None , formatter=None , log_scale=None , native_scale=False , legend='auto' , scale=<deprecated> , scale_hue=<deprecated> , bw=<deprecated> , inner_kws=None , ax=None , **kwargs ) # Draw a patch representing a KDE and add observations or box plot statistics. A violin plot plays a similar role as a box-and-whisker plot. It shows the
distribution of data points after grouping by one (or more) variables.
Unlike a box plot, each violin is drawn using a kernel density estimate
of the underlying distribution. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. saturation float Proportion of the original saturation to draw fill colors in. Large
patches often look better with desaturated colors, but set this to 1 if you want the colors to perfectly match the input values. fill bool If True, use a solid patch. Otherwise, draw as line art. New in version v0.13.0. inner {“box”, “quart”, “point”, “stick”, None} Representation of the data in the violin interior. One of the following: "box" : draw a miniature box-and-whisker plot "quart" : show the quartiles of the data "point" or "stick" : show each observation split bool Show an un-mirrored distribution, alternating sides when using hue . Changed in version v0.13.0: Previously, this option required a hue variable with exactly two levels. width float Width allotted to each element on the orient axis. When native_scale=True ,
it is relative to the minimum distance between two values in the native scale. dodge “auto” or bool When hue mapping is used, whether elements should be narrowed and shifted along
the orient axis to eliminate overlap. If "auto" , set to True when the
orient variable is crossed with the categorical variable or False otherwise. Changed in version 0.13.0: Added "auto" mode as a new default. gap float Shrink on the orient axis by this factor to add a gap between dodged elements. New in version 0.13.0. linewidth float Width of the lines that frame the plot elements. linecolor color Color to use for line elements, when fill is True. New in version v0.13.0. cut float Distance, in units of bandwidth, to extend the density past extreme
datapoints. Set to 0 to limit the violin within the data range. gridsize int Number of points in the discrete grid used to evaluate the KDE. bw_method {“scott”, “silverman”, float} Either the name of a reference rule or the scale factor to use when
computing the kernel bandwidth. The actual kernel size will be
determined by multiplying the scale factor by the standard deviation of
the data within each group. New in version v0.13.0. bw_adjust: float Factor that scales the bandwidth to use more or less smoothing. New in version v0.13.0. density_norm {“area”, “count”, “width”} Method that normalizes each density to determine the violin’s width.
If area , each violin will have the same area. If count , the width
will be proportional to the number of observations. If width , each
violin will have the same width. New in version v0.13.0. common_norm bool When True , normalize the density across all violins. New in version v0.13.0. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. scale {“area”, “count”, “width”} Deprecated since version v0.13.0: See density_norm . scale_hue bool Deprecated since version v0.13.0: See common_norm . bw {‘scott’, ‘silverman’, float} Deprecated since version v0.13.0: See bw_method and bw_adjust . inner_kws dict of key, value mappings Keyword arguments for the “inner” plot, passed to one of: matplotlib.collections.LineCollection (with inner="stick" ) matplotlib.axes.Axes.scatter() (with inner="point" ) matplotlib.axes.Axes.plot() (with inner="quart" or inner="box" ) Additionally, with inner="box" , the keywords box_width , whis_width ,
and marker receive special handling for the components of the “box” plot. New in version v0.13.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Keyword arguments for the violin patches, passsed through to matplotlib.axes.Axes.fill_between() . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also boxplot A traditional box-and-whisker plot with a similar API. stripplot A scatterplot where one variable is categorical. Can be used in conjunction with other plots to show each observation. swarmplot A categorical scatterplot where the points do not overlap. Can be used with other plots to show each observation. catplot Combine a categorical plot with a FacetGrid . Examples The default violinplot represents a distribution two ways: a patch showing a symmetric kernel density estimate (KDE), and the quartiles / whiskers of a box plot: df = sns . load_dataset ( "titanic" ) sns . violinplot ( x = df [ "age" ]) In a bivariate plot, one of the variables will “group” so that multiple violins are drawn: sns . violinplot ( data = df , x = "age" , y = "class" ) By default, the orientation of the plot is determined by the variable types, preferring to group by a categorical variable: sns . violinplot ( data = df , x = "class" , y = "age" , hue = "alive" ) Pass fill=False to draw line-art violins: sns . violinplot ( data = df , x = "class" , y = "age" , hue = "alive" , fill = False ) Draw “split” violins to take up less space, and only show the data quarties: sns . violinplot ( data = df , x = "class" , y = "age" , hue = "alive" , split = True , inner = "quart" ) Add a small gap between the dodged violins: sns . violinplot ( data = df , x = "class" , y = "age" , hue = "alive" , split = True , gap = .1 , inner = "quart" ) Starting in version 0.13.0, it is possilbe to “split” single violins: sns . violinplot ( data = df , x = "class" , y = "age" , split = True , inner = "quart" ) Represent every observation inside the distribution by setting inner="stick" or inner="point" : sns . violinplot ( data = df , x = "age" , y = "deck" , inner = "point" ) Normalize the width of each violin to represent the number of observations: sns . violinplot ( data = df , x = "age" , y = "deck" , inner = "point" , density_norm = "count" ) By default, the KDE will smooth past the extremes of the observed data; set cut=0 to prevent this: sns . violinplot ( data = df , x = "age" , y = "alive" , cut = 0 , inner = "stick" ) The bw_adjust parameter controls the amount of smoothing: sns . violinplot ( data = df , x = "age" , y = "alive" , bw_adjust = .5 , inner = "stick" ) By default, the violins are drawn at fixed positions on a categorical scale, even if the grouping variable is numeric. Starting in version 0.13.0, pass the native_scale=True parameter to preserve the original scale on both axes: sns . violinplot ( x = df [ "age" ] . round ( - 1 ) + 5 , y = df [ "fare" ], native_scale = True ) When using a categorical scale, the formatter parameter accepts a function that defines categories: decades = lambda x : f " { int ( x ) } – { int ( x + 10 ) } " sns . violinplot ( x = df [ "age" ] . round ( - 1 ), y = df [ "fare" ], formatter = decades ) By default, the “inner” representation scales with the linewidth and linecolor parameters: sns . violinplot ( data = df , x = "age" , linewidth = 1 , linecolor = "k" ) Use inner_kws to pass parameters directly to the inner plotting functions: sns . violinplot ( data = df , x = "age" , inner_kws = dict ( box_width = 15 , whis_width = 2 , color = ".8" ))


Page: https://seaborn.pydata.org/generated/seaborn.boxenplot.html#seaborn.boxenplot
seaborn.boxenplot # seaborn. boxenplot ( data=None , * , x=None , y=None , hue=None , order=None , hue_order=None , orient=None , color=None , palette=None , saturation=0.75 , fill=True , dodge='auto' , width=0.8 , gap=0 , linewidth=None , linecolor=None , width_method='exponential' , k_depth='tukey' , outlier_prop=0.007 , trust_alpha=0.05 , showfliers=True , hue_norm=None , log_scale=None , native_scale=False , formatter=None , legend='auto' , scale=<deprecated> , box_kws=None , flier_kws=None , line_kws=None , ax=None , **kwargs ) # Draw an enhanced box plot for larger datasets. This style of plot was originally named a “letter value” plot because it
shows a large number of quantiles that are defined as “letter values”.  It
is similar to a box plot in plotting a nonparametric representation of a
distribution in which all features correspond to actual observations. By
plotting more quantiles, it provides more information about the shape of
the distribution, particularly in the tails. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. saturation float Proportion of the original saturation to draw fill colors in. Large
patches often look better with desaturated colors, but set this to 1 if you want the colors to perfectly match the input values. fill bool If True, use a solid patch. Otherwise, draw as line art. New in version v0.13.0. dodge “auto” or bool When hue mapping is used, whether elements should be narrowed and shifted along
the orient axis to eliminate overlap. If "auto" , set to True when the
orient variable is crossed with the categorical variable or False otherwise. Changed in version 0.13.0: Added "auto" mode as a new default. width float Width allotted to each element on the orient axis. When native_scale=True ,
it is relative to the minimum distance between two values in the native scale. gap float Shrink on the orient axis by this factor to add a gap between dodged elements. New in version 0.13.0. linewidth float Width of the lines that frame the plot elements. linecolor color Color to use for line elements, when fill is True. New in version v0.13.0. width_method {“exponential”, “linear”, “area”} Method to use for the width of the letter value boxes: "exponential" : Represent the corresponding percentile "linear" : Decrease by a constant amount for each box "area" : Represent the density of data points in that box k_depth {“tukey”, “proportion”, “trustworthy”, “full”} or int The number of levels to compute and draw in each tail: "tukey" : Use log2(n) - 3 levels, covering similar range as boxplot whiskers "proportion" : Leave approximately outlier_prop fliers "trusthworthy" : Extend to level with confidence of at least trust_alpha "full" : Use log2(n) + 1 levels and extend to most extreme points outlier_prop float Proportion of data expected to be outliers; used when k_depth="proportion" . trust_alpha float Confidence threshold for most extreme level; used when k_depth="trustworthy" . showfliers bool If False, suppress the plotting of outliers. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. box_kws: dict Keyword arguments for the box artists; passed to matplotlib.patches.Rectangle . New in version v0.12.0. line_kws: dict Keyword arguments for the line denoting the median; passed to matplotlib.axes.Axes.plot() . New in version v0.12.0. flier_kws: dict Keyword arguments for the scatter denoting the outlier observations;
passed to matplotlib.axes.Axes.scatter() . New in version v0.12.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other keyword arguments are passed to matplotlib.patches.Rectangle ,
superceded by those in box_kws . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also violinplot A combination of boxplot and kernel density estimation. boxplot A traditional box-and-whisker plot with a similar API. catplot Combine a categorical plot with a FacetGrid . Notes For a more extensive explanation, you can read the paper that introduced the plot: https://vita.had.co.nz/papers/letter-value-plot.html Examples Draw a single horizontal plot, assigning the data directly to the coordinate variable: sns . boxenplot ( x = diamonds [ "price" ]) Group by a categorical variable, referencing columns in a datafame sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" ) Group by another variable, representing it by the color of the boxes. By default, each boxen plot will be “dodged” so that they don’t overlap; you can also add a small gap between them: large_diamond = diamonds [ "carat" ] . gt ( 1 ) . rename ( "large_diamond" ) sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , hue = large_diamond , gap = .2 ) The default rule for choosing each box width represents the percentile covered by the box. Alternatively, you can reduce each box width by a linear factor: sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , width_method = "linear" ) The width parameter itself, on the other hand, determines the width of the largest box: sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , width = .5 ) There are several different approaches for choosing the number of boxes to draw, including a rule based on the confidence level of the percentie estimate: sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , k_depth = "trustworthy" , trust_alpha = 0.01 ) The linecolor and linewidth parameters control the outlines of the boxes, while the line_kws parameter controls the line representing the median and the flier_kws parameter controls the appearance of the outliers: sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , linewidth = .5 , linecolor = ".7" , line_kws = dict ( linewidth = 1.5 , color = "#cde" ), flier_kws = dict ( facecolor = ".7" , linewidth = .5 ), ) It is also possible to draw unfilled boxes. With unfilled boxes, all elements will be drawn as line art and follow hue , when used: sns . boxenplot ( data = diamonds , x = "price" , y = "clarity" , hue = "clarity" , fill = False )


Page: https://seaborn.pydata.org/generated/seaborn.pointplot.html#seaborn.pointplot
seaborn.pointplot # seaborn. pointplot ( data=None , * , x=None , y=None , hue=None , order=None , hue_order=None , estimator='mean' , errorbar=('ci' , 95) , n_boot=1000 , seed=None , units=None , weights=None , color=None , palette=None , hue_norm=None , markers=<default> , linestyles=<default> , dodge=False , log_scale=None , native_scale=False , orient=None , capsize=0 , formatter=None , legend='auto' , err_kws=None , ci=<deprecated> , errwidth=<deprecated> , join=<deprecated> , scale=<deprecated> , ax=None , **kwargs ) # Show point estimates and errors using lines with markers. A point plot represents an estimate of central tendency for a numeric
variable by the position of the dot and provides some indication of the
uncertainty around that estimate using error bars. Point plots can be more useful than bar plots for focusing comparisons
between different levels of one or more categorical variables. They are
particularly adept at showing interactions: how the relationship between
levels of one categorical variable changes across levels of a second
categorical variable. The lines that join each point from the same hue level allow interactions to be judged by differences in slope, which is
easier for the eyes than comparing the heights of several groups of points
or bars. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. estimator string or callable that maps vector -> scalar Statistical function to estimate within each categorical bin. errorbar string, (string, number) tuple, callable or None Name of errorbar method (either “ci”, “pi”, “se”, or “sd”), or a tuple
with a method name and a level parameter, or a function that maps from a
vector to a (min, max) interval, or None to hide errorbar. See the errorbar tutorial for more information. New in version v0.12.0. n_boot int Number of bootstrap samples used to compute confidence intervals. seed int, numpy.random.Generator , or numpy.random.RandomState Seed or random number generator for reproducible bootstrapping. units name of variable in data or vector data Identifier of sampling units; used by the errorbar function to
perform a multilevel bootstrap and account for repeated measures weights name of variable in data or vector data Data values or column used to compute weighted statistics.
Note that the use of weights may limit other statistical options. New in version v0.13.1. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. markers string or list of strings Markers to use for each of the hue levels. linestyles string or list of strings Line styles to use for each of the hue levels. dodge bool or float Amount to separate the points for each level of the hue variable along
the categorical axis. Setting to True will apply a small default. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. capsize float Width of the “caps” on error bars, relative to bar spacing. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. err_kws dict Parameters of matplotlib.lines.Line2D , for the error bar artists. New in version v0.13.0. ci float Level of the confidence interval to show, in [0, 100]. Deprecated since version v0.12.0: Use errorbar=("ci", ...) . errwidth float Thickness of error bar lines (and caps), in points. Deprecated since version 0.13.0: Use err_kws={'linewidth': ...} . join bool If True , connect point estimates with a line. Deprecated since version v0.13.0: Set linestyle="none" to remove the lines between the points. scale float Scale factor for the plot elements. Deprecated since version v0.13.0: Control element sizes with matplotlib.lines.Line2D parameters. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other parameters are passed through to matplotlib.lines.Line2D . New in version v0.13.0. Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also barplot Show point estimates and confidence intervals using bars. catplot Combine a categorical plot with a FacetGrid . Notes It is important to keep in mind that a point plot shows only the mean (or
other estimator) value, but in many cases it may be more informative to
show the distribution of values at each level of the categorical variables.
In that case, other approaches such as a box or violin plot may be more
appropriate. Examples Group by a categorical variable and plot aggregated values, with confidence intervals: sns . pointplot ( data = penguins , x = "island" , y = "body_mass_g" ) Add a second layer of grouping and differentiate with color: sns . pointplot ( data = penguins , x = "island" , y = "body_mass_g" , hue = "sex" ) Redundantly code the hue variable using the markers and linestyles for better accessibility: sns . pointplot ( data = penguins , x = "island" , y = "body_mass_g" , hue = "sex" , markers = [ "o" , "s" ], linestyles = [ "-" , "--" ], ) Use the error bars to represent the standard deviation of each distribution: sns . pointplot ( data = penguins , x = "island" , y = "body_mass_g" , errorbar = "sd" ) Customize the appearance of the plot: sns . pointplot ( data = penguins , x = "body_mass_g" , y = "island" , errorbar = ( "pi" , 100 ), capsize = .4 , color = ".5" , linestyle = "none" , marker = "D" , ) “Dodge” the artists along the categorical axis to reduce overplotting: sns . pointplot ( data = penguins , x = "sex" , y = "bill_depth_mm" , hue = "species" , dodge = True ) Dodge by a specific amount, relative to the width allotted for each level: sns . stripplot ( data = penguins , x = "species" , y = "bill_depth_mm" , hue = "sex" , dodge = True , alpha = .2 , legend = False , ) sns . pointplot ( data = penguins , x = "species" , y = "bill_depth_mm" , hue = "sex" , dodge = .4 , linestyle = "none" , errorbar = None , marker = "_" , markersize = 20 , markeredgewidth = 3 , ) When variables are not explicitly assigned and the dataset is two-dimensional, the plot will aggregate over each column: flights_wide = flights . pivot ( index = "year" , columns = "month" , values = "passengers" ) sns . pointplot ( flights_wide ) With one-dimensional data, each value is plotted (relative to its key or index when available): sns . pointplot ( flights_wide [ "Jun" ]) Control the formatting of the categorical variable as it appears in the tick labels: sns . pointplot ( flights_wide [ "Jun" ], formatter = lambda x : f "' { x % 1900 } " ) Or preserve the native scale of the grouping variable: ax = sns . pointplot ( flights_wide [ "Jun" ], native_scale = True ) ax . plot ( 1955 , 335 , marker = "*" , color = "r" , markersize = 10 )


Page: https://seaborn.pydata.org/generated/seaborn.barplot.html#seaborn.barplot
seaborn.barplot # seaborn. barplot ( data=None , * , x=None , y=None , hue=None , order=None , hue_order=None , estimator='mean' , errorbar=('ci' , 95) , n_boot=1000 , seed=None , units=None , weights=None , orient=None , color=None , palette=None , saturation=0.75 , fill=True , hue_norm=None , width=0.8 , dodge='auto' , gap=0 , log_scale=None , native_scale=False , formatter=None , legend='auto' , capsize=0 , err_kws=None , ci=<deprecated> , errcolor=<deprecated> , errwidth=<deprecated> , ax=None , **kwargs ) # Show point estimates and errors as rectangular bars. A bar plot represents an aggregate or statistical estimate for a numeric
variable with the height of each rectangle and indicates the uncertainty
around that estimate using an error bar. Bar plots include 0 in the
axis range, and they are a good choice when 0 is a meaningful value
for the variable to take. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. estimator string or callable that maps vector -> scalar Statistical function to estimate within each categorical bin. errorbar string, (string, number) tuple, callable or None Name of errorbar method (either “ci”, “pi”, “se”, or “sd”), or a tuple
with a method name and a level parameter, or a function that maps from a
vector to a (min, max) interval, or None to hide errorbar. See the errorbar tutorial for more information. New in version v0.12.0. n_boot int Number of bootstrap samples used to compute confidence intervals. seed int, numpy.random.Generator , or numpy.random.RandomState Seed or random number generator for reproducible bootstrapping. units name of variable in data or vector data Identifier of sampling units; used by the errorbar function to
perform a multilevel bootstrap and account for repeated measures weights name of variable in data or vector data Data values or column used to compute weighted statistics.
Note that the use of weights may limit other statistical options. New in version v0.13.1. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. saturation float Proportion of the original saturation to draw fill colors in. Large
patches often look better with desaturated colors, but set this to 1 if you want the colors to perfectly match the input values. fill bool If True, use a solid patch. Otherwise, draw as line art. New in version v0.13.0. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. width float Width allotted to each element on the orient axis. When native_scale=True ,
it is relative to the minimum distance between two values in the native scale. dodge “auto” or bool When hue mapping is used, whether elements should be narrowed and shifted along
the orient axis to eliminate overlap. If "auto" , set to True when the
orient variable is crossed with the categorical variable or False otherwise. Changed in version 0.13.0: Added "auto" mode as a new default. gap float Shrink on the orient axis by this factor to add a gap between dodged elements. New in version 0.13.0. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. capsize float Width of the “caps” on error bars, relative to bar spacing. err_kws dict Parameters of matplotlib.lines.Line2D , for the error bar artists. New in version v0.13.0. ci float Level of the confidence interval to show, in [0, 100]. Deprecated since version v0.12.0: Use errorbar=("ci", ...) . errcolor matplotlib color Color used for the error bar lines. Deprecated since version 0.13.0: Use err_kws={'color': ...} . errwidth float Thickness of error bar lines (and caps), in points. Deprecated since version 0.13.0: Use err_kws={'linewidth': ...} . ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other parameters are passed through to matplotlib.patches.Rectangle . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also countplot Show the counts of observations in each categorical bin. pointplot Show point estimates and confidence intervals using dots. catplot Combine a categorical plot with a FacetGrid . Notes For datasets where 0 is not a meaningful value, a pointplot() will
allow you to focus on differences between levels of one or more categorical
variables. It is also important to keep in mind that a bar plot shows only the mean (or
other aggregate) value, but it is often more informative to show the
distribution of values at each level of the categorical variables. In those
cases, approaches such as a boxplot() or violinplot() may be
more appropriate. Examples With long data, assign x and y to group by a categorical variable and plot aggregated values, with confidence intervals: sns . barplot ( penguins , x = "island" , y = "body_mass_g" ) Prior to v0.13.0, each bar would have a different color. To replicate this behavior, assign the grouping variable to hue as well: sns . barplot ( penguins , x = "body_mass_g" , y = "island" , hue = "island" , legend = False ) When plotting a “wide-form” dataframe, each column will be aggregated and represented as a bar: flights_wide = flights . pivot ( index = "year" , columns = "month" , values = "passengers" ) sns . barplot ( flights_wide ) Passing only a series (or dict) will plot each of its values, using the index (or keys) to label the bars: sns . barplot ( flights_wide [ "Jun" ]) With long-form data, you can add a second layer of grouping with hue : sns . barplot ( penguins , x = "island" , y = "body_mass_g" , hue = "sex" ) Use the error bars to show the standard deviation rather than a confidence interval: sns . barplot ( penguins , x = "island" , y = "body_mass_g" , errorbar = "sd" ) Use a different aggregation function and disable the error bars: sns . barplot ( flights , x = "year" , y = "passengers" , estimator = "sum" , errorbar = None ) Add text labels with each bar’s value: ax = sns . barplot ( flights , x = "year" , y = "passengers" , estimator = "sum" , errorbar = None ) ax . bar_label ( ax . containers [ 0 ], fontsize = 10 ); Preserve the original scaling of the grouping variable and add annotations in numeric coordinates: ax = sns . barplot ( flights , x = "year" , y = "passengers" , native_scale = True , estimator = "sum" , errorbar = None , ) ax . plot ( 1955 , 3600 , "*" , markersize = 10 , color = "r" ) Use orient to resolve ambiguity about which variable should group when both are numeric: sns . barplot ( flights , x = "passengers" , y = "year" , orient = "y" ) Customize the appearance of the plot using matplotlib.patches.Rectangle and matplotlib.lines.Line2D keyword arguments: sns . barplot ( penguins , x = "body_mass_g" , y = "island" , errorbar = ( "pi" , 50 ), capsize = .4 , err_kws = { "color" : ".5" , "linewidth" : 2.5 }, linewidth = 2.5 , edgecolor = ".5" , facecolor = ( 0 , 0 , 0 , 0 ), ) Use catplot() to draw faceted bars, which is recommended over working directly with FacetGrid : sns . catplot ( penguins , kind = "bar" , x = "sex" , y = "body_mass_g" , col = "species" , height = 4 , aspect = .5 , )


Page: https://seaborn.pydata.org/generated/seaborn.countplot.html#seaborn.countplot
seaborn.countplot # seaborn. countplot ( data = None , * , x = None , y = None , hue = None , order = None , hue_order = None , orient = None , color = None , palette = None , saturation = 0.75 , fill = True , hue_norm = None , stat = 'count' , width = 0.8 , dodge = 'auto' , gap = 0 , log_scale = None , native_scale = False , formatter = None , legend = 'auto' , ax = None , ** kwargs ) # Show the counts of observations in each categorical bin using bars. A count plot can be thought of as a histogram across a categorical, instead
of quantitative, variable. The basic API and options are identical to those
for barplot() , so you can compare counts across nested variables. Note that histplot() function offers similar functionality with additional
features (e.g. bar stacking), although its default behavior is somewhat different. See the tutorial for more information. Note By default, this function treats one of the variables as categorical
and draws data at ordinal positions (0, 1, … n) on the relevant axis.
As of version 0.13.0, this can be disabled by setting native_scale=True . Parameters : data DataFrame, Series, dict, array, or list of arrays Dataset for plotting. If x and y are absent, this is
interpreted as wide-form. Otherwise it is expected to be long-form. x, y, hue names of variables in data or vector data Inputs for plotting long-form data. See examples for interpretation. order, hue_order lists of strings Order to plot the categorical levels in; otherwise the levels are
inferred from the data objects. orient “v” | “h” | “x” | “y” Orientation of the plot (vertical or horizontal). This is usually
inferred based on the type of the input variables, but it can be used
to resolve ambiguity when both x and y are numeric or when
plotting wide-form data. Changed in version v0.13.0: Added ‘x’/’y’ as options, equivalent to ‘v’/’h’. color matplotlib color Single color for the elements in the plot. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. saturation float Proportion of the original saturation to draw fill colors in. Large
patches often look better with desaturated colors, but set this to 1 if you want the colors to perfectly match the input values. hue_norm tuple or matplotlib.colors.Normalize object Normalization in data units for colormap applied to the hue variable when it is numeric. Not relevant if hue is categorical. New in version v0.12.0. stat {‘count’, ‘percent’, ‘proportion’, ‘probability’} Statistic to compute; when not 'count' , bar heights will be normalized so that
they sum to 100 (for 'percent' ) or 1 (otherwise) across the plot. New in version v0.13.0. width float Width allotted to each element on the orient axis. When native_scale=True ,
it is relative to the minimum distance between two values in the native scale. dodge “auto” or bool When hue mapping is used, whether elements should be narrowed and shifted along
the orient axis to eliminate overlap. If "auto" , set to True when the
orient variable is crossed with the categorical variable or False otherwise. Changed in version 0.13.0: Added "auto" mode as a new default. log_scale bool or number, or pair of bools or numbers Set axis scale(s) to log. A single value sets the data axis for any numeric
axes in the plot. A pair of values sets each axis independently.
Numeric values are interpreted as the desired base (default 10).
When None or False , seaborn defers to the existing Axes scale. New in version v0.13.0. native_scale bool When True, numeric or datetime values on the categorical axis will maintain
their original scaling rather than being converted to fixed indices. New in version v0.13.0. formatter callable Function for converting categorical data into strings. Affects both grouping
and tick labels. New in version v0.13.0. legend “auto”, “brief”, “full”, or False How to draw the legend. If “brief”, numeric hue and size variables will be represented with a sample of evenly spaced values.
If “full”, every group will get an entry in the legend. If “auto”,
choose between brief or full representation based on number of levels.
If False , no legend data is added and no legend is drawn. New in version v0.13.0. ax matplotlib Axes Axes object to draw the plot onto, otherwise uses the current Axes. kwargs key, value mappings Other parameters are passed through to matplotlib.patches.Rectangle . Returns : ax matplotlib Axes Returns the Axes object with the plot drawn onto it. See also histplot Bin and count observations with additional options. barplot Show point estimates and confidence intervals using bars. catplot Combine a categorical plot with a FacetGrid . Examples Show the count of value for a single categorical variable: sns . countplot ( titanic , x = "class" ) Group by a second variable: sns . countplot ( titanic , x = "class" , hue = "survived" ) Normalize the counts to show percentages: sns . countplot ( titanic , x = "class" , hue = "survived" , stat = "percent" )


Page: https://seaborn.pydata.org/generated/seaborn.lmplot.html#seaborn.lmplot
seaborn.lmplot # seaborn. lmplot ( data , * , x = None , y = None , hue = None , col = None , row = None , palette = None , col_wrap = None , height = 5 , aspect = 1 , markers = 'o' , sharex = None , sharey = None , hue_order = None , col_order = None , row_order = None , legend = True , legend_out = None , x_estimator = None , x_bins = None , x_ci = 'ci' , scatter = True , fit_reg = True , ci = 95 , n_boot = 1000 , units = None , seed = None , order = 1 , logistic = False , lowess = False , robust = False , logx = False , x_partial = None , y_partial = None , truncate = True , x_jitter = None , y_jitter = None , scatter_kws = None , line_kws = None , facet_kws = None ) # Plot data and regression model fits across a FacetGrid. This function combines regplot() and FacetGrid . It is
intended as a convenient interface to fit regression models across
conditional subsets of a dataset. When thinking about how to assign variables to different facets, a general
rule is that it makes sense to use hue for the most important
comparison, followed by col and row . However, always think about
your particular dataset and the goals of the visualization you are
creating. There are a number of mutually exclusive options for estimating the
regression model. See the tutorial for more
information. The parameters to this function span most of the options in FacetGrid , although there may be occasional cases where you will
want to use that class and regplot() directly. Parameters : data DataFrame Tidy (“long-form”) dataframe where each column is a variable and each
row is an observation. x, y strings, optional Input variables; these should be column names in data . hue, col, row strings Variables that define subsets of the data, which will be drawn on
separate facets in the grid. See the *_order parameters to control
the order of levels of this variable. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. col_wrap int “Wrap” the column variable at this width, so that the column facets
span multiple rows. Incompatible with a row facet. height scalar Height (in inches) of each facet. See also: aspect . aspect scalar Aspect ratio of each facet, so that aspect * height gives the width
of each facet in inches. markers matplotlib marker code or list of marker codes, optional Markers for the scatterplot. If a list, each marker in the list will be
used for each level of the hue variable. share{x,y} bool, ‘col’, or ‘row’ optional If true, the facets will share y axes across columns and/or x axes
across rows. Deprecated since version 0.12.0: Pass using the facet_kws dictionary. {hue,col,row}_order lists, optional Order for the levels of the faceting variables. By default, this will
be the order that the levels appear in data or, if the variables
are pandas categoricals, the category order. legend bool, optional If True and there is a hue variable, add a legend. legend_out bool If True , the figure size will be extended, and the legend will be
drawn outside the plot on the center right. Deprecated since version 0.12.0: Pass using the facet_kws dictionary. x_estimator callable that maps vector -> scalar, optional Apply this function to each unique value of x and plot the
resulting estimate. This is useful when x is a discrete variable.
If x_ci is given, this estimate will be bootstrapped and a
confidence interval will be drawn. x_bins int or vector, optional Bin the x variable into discrete bins and then estimate the central
tendency and a confidence interval. This binning only influences how
the scatterplot is drawn; the regression is still fit to the original
data.  This parameter is interpreted either as the number of
evenly-sized (not necessary spaced) bins or the positions of the bin
centers. When this parameter is used, it implies that the default of x_estimator is numpy.mean . x_ci “ci”, “sd”, int in [0, 100] or None, optional Size of the confidence interval used when plotting a central tendency
for discrete values of x . If "ci" , defer to the value of the ci parameter. If "sd" , skip bootstrapping and show the
standard deviation of the observations in each bin. scatter bool, optional If True , draw a scatterplot with the underlying observations (or
the x_estimator values). fit_reg bool, optional If True , estimate and plot a regression model relating the x and y variables. ci int in [0, 100] or None, optional Size of the confidence interval for the regression estimate. This will
be drawn using translucent bands around the regression line. The
confidence interval is estimated using a bootstrap; for large
datasets, it may be advisable to avoid that computation by setting
this parameter to None. n_boot int, optional Number of bootstrap resamples used to estimate the ci . The default
value attempts to balance time and stability; you may want to increase
this value for “final” versions of plots. units variable name in data , optional If the x and y observations are nested within sampling units,
those can be specified here. This will be taken into account when
computing the confidence intervals by performing a multilevel bootstrap
that resamples both units and observations (within unit). This does not
otherwise influence how the regression is estimated or drawn. seed int, numpy.random.Generator, or numpy.random.RandomState, optional Seed or random number generator for reproducible bootstrapping. order int, optional If order is greater than 1, use numpy.polyfit to estimate a
polynomial regression. logistic bool, optional If True , assume that y is a binary variable and use statsmodels to estimate a logistic regression model. Note that this
is substantially more computationally intensive than linear regression,
so you may wish to decrease the number of bootstrap resamples
( n_boot ) or set ci to None. lowess bool, optional If True , use statsmodels to estimate a nonparametric lowess
model (locally weighted linear regression). Note that confidence
intervals cannot currently be drawn for this kind of model. robust bool, optional If True , use statsmodels to estimate a robust regression. This
will de-weight outliers. Note that this is substantially more
computationally intensive than standard linear regression, so you may
wish to decrease the number of bootstrap resamples ( n_boot ) or set ci to None. logx bool, optional If True , estimate a linear regression of the form y ~ log(x), but
plot the scatterplot and regression model in the input space. Note that x must be positive for this to work. {x,y}_partial strings in data or matrices Confounding variables to regress out of the x or y variables
before plotting. truncate bool, optional If True , the regression line is bounded by the data limits. If False , it extends to the x axis limits. {x,y}_jitter floats, optional Add uniform random noise of this size to either the x or y variables. The noise is added to a copy of the data after fitting the
regression, and only influences the look of the scatterplot. This can
be helpful when plotting variables that take discrete values. {scatter,line}_kws dictionaries Additional keyword arguments to pass to plt.scatter and plt.plot . facet_kws dict Dictionary of keyword arguments for FacetGrid . See also regplot Plot data and a conditional model fit. FacetGrid Subplot grid for plotting conditional relationships. pairplot Combine regplot() and PairGrid (when used with kind="reg" ). Notes The regplot() and lmplot() functions are closely related, but
the former is an axes-level function while the latter is a figure-level
function that combines regplot() and FacetGrid . Examples See the regplot() docs for demonstrations of various options for specifying the regression model, which are also accepted here. Plot a regression fit over a scatter plot: sns . lmplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) Condition the regression fit on another variable and represent it using color: sns . lmplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , hue = "species" ) Condition the regression fit on another variable and split across subplots: sns . lmplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , hue = "species" , col = "sex" , height = 4 , ) Condition across two variables using both columns and rows: sns . lmplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , col = "species" , row = "sex" , height = 3 , ) Allow axis limits to vary across subplots: sns . lmplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , col = "species" , row = "sex" , height = 3 , facet_kws = dict ( sharex = False , sharey = False ), )


Page: https://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot
seaborn.regplot # seaborn. regplot ( data = None , * , x = None , y = None , x_estimator = None , x_bins = None , x_ci = 'ci' , scatter = True , fit_reg = True , ci = 95 , n_boot = 1000 , units = None , seed = None , order = 1 , logistic = False , lowess = False , robust = False , logx = False , x_partial = None , y_partial = None , truncate = True , dropna = True , x_jitter = None , y_jitter = None , label = None , color = None , marker = 'o' , scatter_kws = None , line_kws = None , ax = None ) # Plot data and a linear regression model fit. There are a number of mutually exclusive options for estimating the
regression model. See the tutorial for more
information. Parameters : x, y: string, series, or vector array Input variables. If strings, these should correspond with column names
in data . When pandas objects are used, axes will be labeled with
the series name. data DataFrame Tidy (“long-form”) dataframe where each column is a variable and each
row is an observation. x_estimator callable that maps vector -> scalar, optional Apply this function to each unique value of x and plot the
resulting estimate. This is useful when x is a discrete variable.
If x_ci is given, this estimate will be bootstrapped and a
confidence interval will be drawn. x_bins int or vector, optional Bin the x variable into discrete bins and then estimate the central
tendency and a confidence interval. This binning only influences how
the scatterplot is drawn; the regression is still fit to the original
data.  This parameter is interpreted either as the number of
evenly-sized (not necessary spaced) bins or the positions of the bin
centers. When this parameter is used, it implies that the default of x_estimator is numpy.mean . x_ci “ci”, “sd”, int in [0, 100] or None, optional Size of the confidence interval used when plotting a central tendency
for discrete values of x . If "ci" , defer to the value of the ci parameter. If "sd" , skip bootstrapping and show the
standard deviation of the observations in each bin. scatter bool, optional If True , draw a scatterplot with the underlying observations (or
the x_estimator values). fit_reg bool, optional If True , estimate and plot a regression model relating the x and y variables. ci int in [0, 100] or None, optional Size of the confidence interval for the regression estimate. This will
be drawn using translucent bands around the regression line. The
confidence interval is estimated using a bootstrap; for large
datasets, it may be advisable to avoid that computation by setting
this parameter to None. n_boot int, optional Number of bootstrap resamples used to estimate the ci . The default
value attempts to balance time and stability; you may want to increase
this value for “final” versions of plots. units variable name in data , optional If the x and y observations are nested within sampling units,
those can be specified here. This will be taken into account when
computing the confidence intervals by performing a multilevel bootstrap
that resamples both units and observations (within unit). This does not
otherwise influence how the regression is estimated or drawn. seed int, numpy.random.Generator, or numpy.random.RandomState, optional Seed or random number generator for reproducible bootstrapping. order int, optional If order is greater than 1, use numpy.polyfit to estimate a
polynomial regression. logistic bool, optional If True , assume that y is a binary variable and use statsmodels to estimate a logistic regression model. Note that this
is substantially more computationally intensive than linear regression,
so you may wish to decrease the number of bootstrap resamples
( n_boot ) or set ci to None. lowess bool, optional If True , use statsmodels to estimate a nonparametric lowess
model (locally weighted linear regression). Note that confidence
intervals cannot currently be drawn for this kind of model. robust bool, optional If True , use statsmodels to estimate a robust regression. This
will de-weight outliers. Note that this is substantially more
computationally intensive than standard linear regression, so you may
wish to decrease the number of bootstrap resamples ( n_boot ) or set ci to None. logx bool, optional If True , estimate a linear regression of the form y ~ log(x), but
plot the scatterplot and regression model in the input space. Note that x must be positive for this to work. {x,y}_partial strings in data or matrices Confounding variables to regress out of the x or y variables
before plotting. truncate bool, optional If True , the regression line is bounded by the data limits. If False , it extends to the x axis limits. {x,y}_jitter floats, optional Add uniform random noise of this size to either the x or y variables. The noise is added to a copy of the data after fitting the
regression, and only influences the look of the scatterplot. This can
be helpful when plotting variables that take discrete values. label string Label to apply to either the scatterplot or regression line (if scatter is False ) for use in a legend. color matplotlib color Color to apply to all plot elements; will be superseded by colors
passed in scatter_kws or line_kws . marker matplotlib marker code Marker to use for the scatterplot glyphs. {scatter,line}_kws dictionaries Additional keyword arguments to pass to plt.scatter and plt.plot . ax matplotlib Axes, optional Axes object to draw the plot onto, otherwise uses the current Axes. Returns : ax matplotlib Axes The Axes object containing the plot. See also lmplot Combine regplot() and FacetGrid to plot multiple linear relationships in a dataset. jointplot Combine regplot() and JointGrid (when used with kind="reg" ). pairplot Combine regplot() and PairGrid (when used with kind="reg" ). residplot Plot the residuals of a linear regression model. Notes The regplot() and lmplot() functions are closely related, but
the former is an axes-level function while the latter is a figure-level
function that combines regplot() and FacetGrid . It’s also easy to combine regplot() and JointGrid or PairGrid through the jointplot() and pairplot() functions, although these do not directly accept all of regplot() ’s
parameters. Examples Plot the relationship between two variables in a DataFrame: sns . regplot ( data = mpg , x = "weight" , y = "acceleration" ) Fit a higher-order polynomial regression to capture nonlinear trends: sns . regplot ( data = mpg , x = "weight" , y = "mpg" , order = 2 ) Alternatively, fit a log-linear regression: sns . regplot ( data = mpg , x = "displacement" , y = "mpg" , logx = True ) Or use a locally-weighted (LOWESS) smoother: sns . regplot ( data = mpg , x = "horsepower" , y = "mpg" , lowess = True ) Fit a logistic regression when the response variable is binary: sns . regplot ( x = mpg [ "weight" ], y = mpg [ "origin" ] . eq ( "usa" ) . rename ( "from_usa" ), logistic = True ) Fit a robust regression to downweight the influence of outliers: sns . regplot ( data = mpg , x = "horsepower" , y = "weight" , robust = True ) Disable the confidence interval for faster plotting: sns . regplot ( data = mpg , x = "weight" , y = "horsepower" , ci = None ) Jitter the scatterplot when the x variable is discrete: sns . regplot ( data = mpg , x = "cylinders" , y = "weight" , x_jitter = .15 ) Or aggregate over the distinct x values: sns . regplot ( data = mpg , x = "cylinders" , y = "acceleration" , x_estimator = np . mean , order = 2 ) With a continuous x variable, bin and then aggregate: sns . regplot ( data = mpg , x = "weight" , y = "mpg" , x_bins = np . arange ( 2000 , 5500 , 250 ), order = 2 ) Customize the appearance of various elements: sns . regplot ( data = mpg , x = "weight" , y = "horsepower" , ci = 99 , marker = "x" , color = ".3" , line_kws = dict ( color = "r" ), )


Page: https://seaborn.pydata.org/generated/seaborn.residplot.html#seaborn.residplot
seaborn.residplot # seaborn. residplot ( data = None , * , x = None , y = None , x_partial = None , y_partial = None , lowess = False , order = 1 , robust = False , dropna = True , label = None , color = None , scatter_kws = None , line_kws = None , ax = None ) # Plot the residuals of a linear regression. This function will regress y on x (possibly as a robust or polynomial
regression) and then draw a scatterplot of the residuals. You can
optionally fit a lowess smoother to the residual plot, which can
help in determining if there is structure to the residuals. Parameters : data DataFrame, optional DataFrame to use if x and y are column names. x vector or string Data or column name in data for the predictor variable. y vector or string Data or column name in data for the response variable. {x, y}_partial vectors or string(s) , optional These variables are treated as confounding and are removed from
the x or y variables before plotting. lowess boolean, optional Fit a lowess smoother to the residual scatterplot. order int, optional Order of the polynomial to fit when calculating the residuals. robust boolean, optional Fit a robust linear regression when calculating the residuals. dropna boolean, optional If True, ignore observations with missing data when fitting and
plotting. label string, optional Label that will be used in any plot legends. color matplotlib color, optional Color to use for all elements of the plot. {scatter, line}_kws dictionaries, optional Additional keyword arguments passed to scatter() and plot() for drawing
the components of the plot. ax matplotlib axis, optional Plot into this axis, otherwise grab the current axis or make a new
one if not existing. Returns : ax: matplotlib axes Axes with the regression plot. See also regplot Plot a simple linear regression model. jointplot Draw a residplot() with univariate marginal distributions (when used with kind="resid" ). Examples Pass x and y to see a scatter plot of the residuals after fitting a simple regression model: sns . residplot ( data = mpg , x = "weight" , y = "displacement" ) Structure in the residual plot can reveal a violation of linear regression assumptions: sns . residplot ( data = mpg , x = "horsepower" , y = "mpg" ) Remove higher-order trends to test whether that stabilizes the residuals: sns . residplot ( data = mpg , x = "horsepower" , y = "mpg" , order = 2 ) Adding a LOWESS curve can help reveal or emphasize structure: sns . residplot ( data = mpg , x = "horsepower" , y = "mpg" , lowess = True , line_kws = dict ( color = "r" ))


Page: https://seaborn.pydata.org/generated/seaborn.heatmap.html#seaborn.heatmap
seaborn.heatmap # seaborn. heatmap ( data , * , vmin = None , vmax = None , cmap = None , center = None , robust = False , annot = None , fmt = '.2g' , annot_kws = None , linewidths = 0 , linecolor = 'white' , cbar = True , cbar_kws = None , cbar_ax = None , square = False , xticklabels = 'auto' , yticklabels = 'auto' , mask = None , ax = None , ** kwargs ) # Plot rectangular data as a color-encoded matrix. This is an Axes-level function and will draw the heatmap into the
currently-active Axes if none is provided to the ax argument.  Part of
this Axes space will be taken and used to plot a colormap, unless cbar is False or a separate Axes is provided to cbar_ax . Parameters : data rectangular dataset 2D dataset that can be coerced into an ndarray. If a Pandas DataFrame
is provided, the index/column information will be used to label the
columns and rows. vmin, vmax floats, optional Values to anchor the colormap, otherwise they are inferred from the
data and other keyword arguments. cmap matplotlib colormap name or object, or list of colors, optional The mapping from data values to color space. If not provided, the
default will depend on whether center is set. center float, optional The value at which to center the colormap when plotting divergent data.
Using this parameter will change the default cmap if none is
specified. robust bool, optional If True and vmin or vmax are absent, the colormap range is
computed with robust quantiles instead of the extreme values. annot bool or rectangular dataset, optional If True, write the data value in each cell. If an array-like with the
same shape as data , then use this to annotate the heatmap instead
of the data. Note that DataFrames will match on position, not index. fmt str, optional String formatting code to use when adding annotations. annot_kws dict of key, value mappings, optional Keyword arguments for matplotlib.axes.Axes.text() when annot is True. linewidths float, optional Width of the lines that will divide each cell. linecolor color, optional Color of the lines that will divide each cell. cbar bool, optional Whether to draw a colorbar. cbar_kws dict of key, value mappings, optional Keyword arguments for matplotlib.figure.Figure.colorbar() . cbar_ax matplotlib Axes, optional Axes in which to draw the colorbar, otherwise take space from the
main Axes. square bool, optional If True, set the Axes aspect to “equal” so each cell will be
square-shaped. xticklabels, yticklabels “auto”, bool, list-like, or int, optional If True, plot the column names of the dataframe. If False, don’t plot
the column names. If list-like, plot these alternate labels as the
xticklabels. If an integer, use the column names but plot only every
n label. If “auto”, try to densely plot non-overlapping labels. mask bool array or DataFrame, optional If passed, data will not be shown in cells where mask is True.
Cells with missing values are automatically masked. ax matplotlib Axes, optional Axes in which to draw the plot, otherwise use the currently-active
Axes. kwargs other keyword arguments All other keyword arguments are passed to matplotlib.axes.Axes.pcolormesh() . Returns : ax matplotlib Axes Axes object with the heatmap. See also clustermap Plot a matrix using hierarchical clustering to arrange the rows and columns. Examples Pass a DataFrame to plot with indices as row/column labels: glue = sns . load_dataset ( "glue" ) . pivot ( index = "Model" , columns = "Task" , values = "Score" ) sns . heatmap ( glue ) Use annot to represent the cell values with text: sns . heatmap ( glue , annot = True ) Control the annotations with a formatting string: sns . heatmap ( glue , annot = True , fmt = ".1f" ) Use a separate dataframe for the annotations: sns . heatmap ( glue , annot = glue . rank ( axis = "columns" )) Add lines between cells: sns . heatmap ( glue , annot = True , linewidth = .5 ) Select a different colormap by name: sns . heatmap ( glue , cmap = "crest" ) Or pass a colormap object: sns . heatmap ( glue , cmap = sns . cubehelix_palette ( as_cmap = True )) Set the colormap norm (data values corresponding to minimum and maximum points): sns . heatmap ( glue , vmin = 50 , vmax = 100 ) Use methods on the matplotlib.axes.Axes object to tweak the plot: ax = sns . heatmap ( glue , annot = True ) ax . set ( xlabel = "" , ylabel = "" ) ax . xaxis . tick_top ()


Page: https://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap
seaborn.clustermap # seaborn. clustermap ( data , * , pivot_kws = None , method = 'average' , metric = 'euclidean' , z_score = None , standard_scale = None , figsize = (10, 10) , cbar_kws = None , row_cluster = True , col_cluster = True , row_linkage = None , col_linkage = None , row_colors = None , col_colors = None , mask = None , dendrogram_ratio = 0.2 , colors_ratio = 0.03 , cbar_pos = (0.02, 0.8, 0.05, 0.18) , tree_kws = None , ** kwargs ) # Plot a matrix dataset as a hierarchically-clustered heatmap. This function requires scipy to be available. Parameters : data 2D array-like Rectangular data for clustering. Cannot contain NAs. pivot_kws dict, optional If data is a tidy dataframe, can provide keyword arguments for
pivot to create a rectangular dataframe. method str, optional Linkage method to use for calculating clusters. See scipy.cluster.hierarchy.linkage() documentation for more
information. metric str, optional Distance metric to use for the data. See scipy.spatial.distance.pdist() documentation for more options.
To use different metrics (or methods) for rows and columns, you may
construct each linkage matrix yourself and provide them as {row,col}_linkage . z_score int or None, optional Either 0 (rows) or 1 (columns). Whether or not to calculate z-scores
for the rows or the columns. Z scores are: z = (x - mean)/std, so
values in each row (column) will get the mean of the row (column)
subtracted, then divided by the standard deviation of the row (column).
This ensures that each row (column) has mean of 0 and variance of 1. standard_scale int or None, optional Either 0 (rows) or 1 (columns). Whether or not to standardize that
dimension, meaning for each row or column, subtract the minimum and
divide each by its maximum. figsize tuple of (width, height), optional Overall size of the figure. cbar_kws dict, optional Keyword arguments to pass to cbar_kws in heatmap() , e.g. to
add a label to the colorbar. {row,col}_cluster bool, optional If True , cluster the {rows, columns}. {row,col}_linkage numpy.ndarray , optional Precomputed linkage matrix for the rows or columns. See scipy.cluster.hierarchy.linkage() for specific formats. {row,col}_colors list-like or pandas DataFrame/Series, optional List of colors to label for either the rows or columns. Useful to evaluate
whether samples within a group are clustered together. Can use nested lists or
DataFrame for multiple color levels of labeling. If given as a pandas.DataFrame or pandas.Series , labels for the colors are
extracted from the DataFrames column names or from the name of the Series.
DataFrame/Series colors are also matched to the data by their index, ensuring
colors are drawn in the correct order. mask bool array or DataFrame, optional If passed, data will not be shown in cells where mask is True.
Cells with missing values are automatically masked. Only used for
visualizing, not for calculating. {dendrogram,colors}_ratio float, or pair of floats, optional Proportion of the figure size devoted to the two marginal elements. If
a pair is given, they correspond to (row, col) ratios. cbar_pos tuple of (left, bottom, width, height), optional Position of the colorbar axes in the figure. Setting to None will
disable the colorbar. tree_kws dict, optional Parameters for the matplotlib.collections.LineCollection that is used to plot the lines of the dendrogram tree. kwargs other keyword arguments All other keyword arguments are passed to heatmap() . Returns : ClusterGrid A ClusterGrid instance. See also heatmap Plot rectangular data as a color-encoded matrix. Notes The returned object has a savefig method that should be used if you
want to save the figure object without clipping the dendrograms. To access the reordered row indices, use: clustergrid.dendrogram_row.reordered_ind Column indices, use: clustergrid.dendrogram_col.reordered_ind Examples Plot a heatmap with row and column clustering: iris = sns . load_dataset ( "iris" ) species = iris . pop ( "species" ) sns . clustermap ( iris ) Change the size and layout of the figure: sns . clustermap ( iris , figsize = ( 7 , 5 ), row_cluster = False , dendrogram_ratio = ( .1 , .2 ), cbar_pos = ( 0 , .2 , .03 , .4 ) ) Add colored labels to identify observations: lut = dict ( zip ( species . unique (), "rbg" )) row_colors = species . map ( lut ) sns . clustermap ( iris , row_colors = row_colors ) Use a different colormap and adjust the limits of the color range: sns . clustermap ( iris , cmap = "mako" , vmin = 0 , vmax = 10 ) Use differente clustering parameters: sns . clustermap ( iris , metric = "correlation" , method = "single" ) Standardize the data within the columns: sns . clustermap ( iris , standard_scale = 1 ) Normalize the data within rows: sns . clustermap ( iris , z_score = 0 , cmap = "vlag" , center = 0 )


Page: https://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid
seaborn.FacetGrid # class seaborn. FacetGrid ( data , * , row = None , col = None , hue = None , col_wrap = None , sharex = True , sharey = True , height = 3 , aspect = 1 , palette = None , row_order = None , col_order = None , hue_order = None , hue_kws = None , dropna = False , legend_out = True , despine = True , margin_titles = False , xlim = None , ylim = None , subplot_kws = None , gridspec_kws = None ) # Multi-plot grid for plotting conditional relationships. __init__ ( data , * , row = None , col = None , hue = None , col_wrap = None , sharex = True , sharey = True , height = 3 , aspect = 1 , palette = None , row_order = None , col_order = None , hue_order = None , hue_kws = None , dropna = False , legend_out = True , despine = True , margin_titles = False , xlim = None , ylim = None , subplot_kws = None , gridspec_kws = None ) # Initialize the matplotlib figure and FacetGrid object. This class maps a dataset onto multiple axes arrayed in a grid of rows
and columns that correspond to levels of variables in the dataset.
The plots it produces are often called “lattice”, “trellis”, or
“small-multiple” graphics. It can also represent levels of a third variable with the hue parameter, which plots different subsets of data in different colors.
This uses color to resolve elements on a third dimension, but only
draws subsets on top of each other and will not tailor the hue parameter for the specific visualization the way that axes-level
functions that accept hue will. The basic workflow is to initialize the FacetGrid object with
the dataset and the variables that are used to structure the grid. Then
one or more plotting functions can be applied to each subset by calling FacetGrid.map() or FacetGrid.map_dataframe() . Finally, the
plot can be tweaked with other methods to do things like change the
axis labels, use different ticks, or add a legend. See the detailed
code examples below for more information. Warning When using seaborn functions that infer semantic mappings from a
dataset, care must be taken to synchronize those mappings across
facets (e.g., by defining the hue mapping with a palette dict or
setting the data type of the variables to category ). In most cases,
it will be better to use a figure-level function (e.g. relplot() or catplot() ) than to use FacetGrid directly. See the tutorial for more information. Parameters : data DataFrame Tidy (“long-form”) dataframe where each column is a variable and each
row is an observation. row, col, hue strings Variables that define subsets of the data, which will be drawn on
separate facets in the grid. See the {var}_order parameters to
control the order of levels of this variable. col_wrap int “Wrap” the column variable at this width, so that the column facets
span multiple rows. Incompatible with a row facet. share{x,y} bool, ‘col’, or ‘row’ optional If true, the facets will share y axes across columns and/or x axes
across rows. height scalar Height (in inches) of each facet. See also: aspect . aspect scalar Aspect ratio of each facet, so that aspect * height gives the width
of each facet in inches. palette palette name, list, or dict Colors to use for the different levels of the hue variable. Should
be something that can be interpreted by color_palette() , or a
dictionary mapping hue levels to matplotlib colors. {row,col,hue}_order lists Order for the levels of the faceting variables. By default, this
will be the order that the levels appear in data or, if the
variables are pandas categoricals, the category order. hue_kws dictionary of param -> list of values mapping Other keyword arguments to insert into the plotting call to let
other plot attributes vary across levels of the hue variable (e.g.
the markers in a scatterplot). legend_out bool If True , the figure size will be extended, and the legend will be
drawn outside the plot on the center right. despine boolean Remove the top and right spines from the plots. margin_titles bool If True , the titles for the row variable are drawn to the right of
the last column. This option is experimental and may not work in all
cases. {x, y}lim: tuples Limits for each of the axes on each facet (only relevant when
share{x, y} is True). subplot_kws dict Dictionary of keyword arguments passed to matplotlib subplot(s)
methods. gridspec_kws dict Dictionary of keyword arguments passed to matplotlib.gridspec.GridSpec (via matplotlib.figure.Figure.subplots() ).
Ignored if col_wrap is not None . See also PairGrid Subplot grid for plotting pairwise relationships relplot Combine a relational plot and a FacetGrid displot Combine a distribution plot and a FacetGrid catplot Combine a categorical plot and a FacetGrid lmplot Combine a regression plot and a FacetGrid Examples Note These examples use seaborn functions to demonstrate some of the
advanced features of the class, but in most cases you will want
to use figue-level functions (e.g. displot() , relplot() )
to make the plots shown here. Calling the constructor requires a long-form data object. This
initializes the grid, but doesn’t plot anything on it: tips = sns . load_dataset ( "tips" ) sns . FacetGrid ( tips ) Assign column and/or row variables to add more subplots to the figure: sns . FacetGrid ( tips , col = "time" , row = "sex" ) To draw a plot on every facet, pass a function and the name of one or more columns in the dataframe to FacetGrid.map() : g = sns . FacetGrid ( tips , col = "time" , row = "sex" ) g . map ( sns . scatterplot , "total_bill" , "tip" ) The variable specification in FacetGrid.map() requires a positional argument mapping, but if the function has a data parameter and accepts named variable assignments, you can also use FacetGrid.map_dataframe() : g = sns . FacetGrid ( tips , col = "time" , row = "sex" ) g . map_dataframe ( sns . histplot , x = "total_bill" ) Notice how the bins have different widths in each facet. A separate plot is drawn on each facet, so if the plotting function derives any parameters from the data, they may not be shared across facets. You can pass additional keyword arguments to synchronize them. But when possible, using a figure-level function like displot() will take care of this bookkeeping for you: g = sns . FacetGrid ( tips , col = "time" , row = "sex" ) g . map_dataframe ( sns . histplot , x = "total_bill" , binwidth = 2 , binrange = ( 0 , 60 )) The FacetGrid constructor accepts a hue parameter. Setting this will condition the data on another variable and make multiple plots in different colors. Where possible, label information is tracked so that a single legend can be drawn: g = sns . FacetGrid ( tips , col = "time" , hue = "sex" ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" ) g . add_legend () When hue is set on the FacetGrid , however, a separate plot is drawn for each level of the variable. If the plotting function understands hue , it is better to let it handle that logic. But it is important to ensure that each facet will use the same hue mapping. In the sample tips data, the sex column has a categorical datatype, which ensures this. Otherwise, you may want to use the hue_order or similar parameter: g = sns . FacetGrid ( tips , col = "time" ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" , hue = "sex" ) g . add_legend () The size and shape of the plot is specified at the level of each subplot using the height and aspect parameters: g = sns . FacetGrid ( tips , col = "day" , height = 3.5 , aspect = .65 ) g . map ( sns . histplot , "total_bill" ) If the variable assigned to col has many levels, it is possible to “wrap” it so that it spans multiple rows: g = sns . FacetGrid ( tips , col = "size" , height = 2.5 , col_wrap = 3 ) g . map ( sns . histplot , "total_bill" ) To add horizontal or vertical reference lines on every facet, use FacetGrid.refline() : g = sns . FacetGrid ( tips , col = "time" , margin_titles = True ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" ) g . refline ( y = tips [ "tip" ] . median ()) You can pass custom functions to plot with, or to annotate each facet.
Your custom function must use the matplotlib state-machine interface to
plot on the “current” axes, and it should catch additional keyword
arguments: import matplotlib.pyplot as plt def annotate ( data , ** kws ): n = len ( data ) ax = plt . gca () ax . text ( .1 , .6 , f "N = { n } " , transform = ax . transAxes ) g = sns . FacetGrid ( tips , col = "time" ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" ) g . map_dataframe ( annotate ) The FacetGrid object has some other useful parameters and methods for tweaking the plot: g = sns . FacetGrid ( tips , col = "sex" , row = "time" , margin_titles = True ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" ) g . set_axis_labels ( "Total bill ($)" , "Tip ($)" ) g . set_titles ( col_template = " {col_name} patrons" , row_template = " {row_name} " ) g . set ( xlim = ( 0 , 60 ), ylim = ( 0 , 12 ), xticks = [ 10 , 30 , 50 ], yticks = [ 2 , 6 , 10 ]) g . tight_layout () g . savefig ( "facet_plot.png" ) You also have access to the underlying matplotlib objects for additional tweaking: g = sns . FacetGrid ( tips , col = "sex" , row = "time" , margin_titles = True , despine = False ) g . map_dataframe ( sns . scatterplot , x = "total_bill" , y = "tip" ) g . figure . subplots_adjust ( wspace = 0 , hspace = 0 ) for ( row_val , col_val ), ax in g . axes_dict . items (): if row_val == "Lunch" and col_val == "Female" : ax . set_facecolor ( ".95" ) else : ax . set_facecolor (( 0 , 0 , 0 , 0 )) Methods __init__ (data, *[, row, col, hue, col_wrap, ...]) Initialize the matplotlib figure and FacetGrid object. add_legend ([legend_data, title, ...]) Draw a legend, maybe placing it outside axes and resizing the figure. apply (func, *args, **kwargs) Pass the grid to a user-supplied function and return self. despine (**kwargs) Remove axis spines from the facets. facet_axis (row_i, col_j[, modify_state]) Make the axis identified by these indices active and return it. facet_data () Generator for name indices and data subsets for each facet. map (func, *args, **kwargs) Apply a plotting function to each facet's subset of the data. map_dataframe (func, *args, **kwargs) Like .map but passes args as strings and inserts data in kwargs. pipe (func, *args, **kwargs) Pass the grid to a user-supplied function and return its value. refline (*[, x, y, color, linestyle]) Add a reference line(s) to each facet. savefig (*args, **kwargs) Save an image of the plot. set (**kwargs) Set attributes on each subplot Axes. set_axis_labels ([x_var, y_var, clear_inner]) Set axis labels on the left column and bottom row of the grid. set_titles ([template, row_template, ...]) Draw titles either above each facet or on the grid margins. set_xlabels ([label, clear_inner]) Label the x axis on the bottom row of the grid. set_xticklabels ([labels, step]) Set x axis tick labels of the grid. set_ylabels ([label, clear_inner]) Label the y axis on the left column of the grid. set_yticklabels ([labels]) Set y axis tick labels on the left column of the grid. tick_params ([axis]) Modify the ticks, tick labels, and gridlines. tight_layout (*args, **kwargs) Call fig.tight_layout within rect that exclude the legend. Attributes ax The matplotlib.axes.Axes when no faceting variables are assigned. axes An array of the matplotlib.axes.Axes objects in the grid. axes_dict A mapping of facet names to corresponding matplotlib.axes.Axes . fig DEPRECATED: prefer the figure property. figure Access the matplotlib.figure.Figure object underlying the grid. legend The matplotlib.legend.Legend object, if present.


Page: https://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot
seaborn.pairplot # seaborn. pairplot ( data , * , hue = None , hue_order = None , palette = None , vars = None , x_vars = None , y_vars = None , kind = 'scatter' , diag_kind = 'auto' , markers = None , height = 2.5 , aspect = 1 , corner = False , dropna = False , plot_kws = None , diag_kws = None , grid_kws = None , size = None ) # Plot pairwise relationships in a dataset. By default, this function will create a grid of Axes such that each numeric
variable in data will by shared across the y-axes across a single row and
the x-axes across a single column. The diagonal plots are treated
differently: a univariate distribution plot is drawn to show the marginal
distribution of the data in each column. It is also possible to show a subset of variables or plot different
variables on the rows and columns. This is a high-level interface for PairGrid that is intended to
make it easy to draw a few common styles. You should use PairGrid directly if you need more flexibility. Parameters : data pandas.DataFrame Tidy (long-form) dataframe where each column is a variable and
each row is an observation. hue name of variable in data Variable in data to map plot aspects to different colors. hue_order list of strings Order for the levels of the hue variable in the palette palette dict or seaborn color palette Set of colors for mapping the hue variable. If a dict, keys
should be values  in the hue variable. vars list of variable names Variables within data to use, otherwise use every column with
a numeric datatype. {x, y}_vars lists of variable names Variables within data to use separately for the rows and
columns of the figure; i.e. to make a non-square plot. kind {‘scatter’, ‘kde’, ‘hist’, ‘reg’} Kind of plot to make. diag_kind {‘auto’, ‘hist’, ‘kde’, None} Kind of plot for the diagonal subplots. If ‘auto’, choose based on
whether or not hue is used. markers single matplotlib marker code or list Either the marker to use for all scatterplot points or a list of markers
with a length the same as the number of levels in the hue variable so that
differently colored points will also have different scatterplot
markers. height scalar Height (in inches) of each facet. aspect scalar Aspect * height gives the width (in inches) of each facet. corner bool If True, don’t add axes to the upper (off-diagonal) triangle of the
grid, making this a “corner” plot. dropna boolean Drop missing values from the data before plotting. {plot, diag, grid}_kws dicts Dictionaries of keyword arguments. plot_kws are passed to the
bivariate plotting function, diag_kws are passed to the univariate
plotting function, and grid_kws are passed to the PairGrid constructor. Returns : grid PairGrid Returns the underlying PairGrid instance for further tweaking. See also PairGrid Subplot grid for more flexible plotting of pairwise relationships. JointGrid Grid for plotting joint and marginal distributions of two variables. Examples The simplest invocation uses scatterplot() for each pairing of the variables and histplot() for the marginal plots along the diagonal: penguins = sns . load_dataset ( "penguins" ) sns . pairplot ( penguins ) Assigning a hue variable adds a semantic mapping and changes the default marginal plot to a layered kernel density estimate (KDE): sns . pairplot ( penguins , hue = "species" ) It’s possible to force marginal histograms: sns . pairplot ( penguins , hue = "species" , diag_kind = "hist" ) The kind parameter determines both the diagonal and off-diagonal plotting style. Several options are available, including using kdeplot() to draw KDEs: sns . pairplot ( penguins , kind = "kde" ) Or histplot() to draw both bivariate and univariate histograms: sns . pairplot ( penguins , kind = "hist" ) The markers parameter applies a style mapping on the off-diagonal axes. Currently, it will be redundant with the hue variable: sns . pairplot ( penguins , hue = "species" , markers = [ "o" , "s" , "D" ]) As with other figure-level functions, the size of the figure is controlled by setting the height of each individual subplot: sns . pairplot ( penguins , height = 1.5 ) Use vars or x_vars and y_vars to select the variables to plot: sns . pairplot ( penguins , x_vars = [ "bill_length_mm" , "bill_depth_mm" , "flipper_length_mm" ], y_vars = [ "bill_length_mm" , "bill_depth_mm" ], ) Set corner=True to plot only the lower triangle: sns . pairplot ( penguins , corner = True ) The plot_kws and diag_kws parameters accept dicts of keyword arguments to customize the off-diagonal and diagonal plots, respectively: sns . pairplot ( penguins , plot_kws = dict ( marker = "+" , linewidth = 1 ), diag_kws = dict ( fill = False ), ) The return object is the underlying PairGrid , which can be used to further customize the plot: g = sns . pairplot ( penguins , diag_kind = "kde" ) g . map_lower ( sns . kdeplot , levels = 4 , color = ".2" )


Page: https://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid
seaborn.PairGrid # class seaborn. PairGrid ( data , * , hue = None , vars = None , x_vars = None , y_vars = None , hue_order = None , palette = None , hue_kws = None , corner = False , diag_sharey = True , height = 2.5 , aspect = 1 , layout_pad = 0.5 , despine = True , dropna = False ) # Subplot grid for plotting pairwise relationships in a dataset. This object maps each variable in a dataset onto a column and row in a
grid of multiple axes. Different axes-level plotting functions can be
used to draw bivariate plots in the upper and lower triangles, and the
marginal distribution of each variable can be shown on the diagonal. Several different common plots can be generated in a single line using pairplot() . Use PairGrid when you need more flexibility. See the tutorial for more information. __init__ ( data , * , hue = None , vars = None , x_vars = None , y_vars = None , hue_order = None , palette = None , hue_kws = None , corner = False , diag_sharey = True , height = 2.5 , aspect = 1 , layout_pad = 0.5 , despine = True , dropna = False ) # Initialize the plot figure and PairGrid object. Parameters : data DataFrame Tidy (long-form) dataframe where each column is a variable and
each row is an observation. hue string (variable name) Variable in data to map plot aspects to different colors. This
variable will be excluded from the default x and y variables. vars list of variable names Variables within data to use, otherwise use every column with
a numeric datatype. {x, y}_vars lists of variable names Variables within data to use separately for the rows and
columns of the figure; i.e. to make a non-square plot. hue_order list of strings Order for the levels of the hue variable in the palette palette dict or seaborn color palette Set of colors for mapping the hue variable. If a dict, keys
should be values  in the hue variable. hue_kws dictionary of param -> list of values mapping Other keyword arguments to insert into the plotting call to let
other plot attributes vary across levels of the hue variable (e.g.
the markers in a scatterplot). corner bool If True, don’t add axes to the upper (off-diagonal) triangle of the
grid, making this a “corner” plot. height scalar Height (in inches) of each facet. aspect scalar Aspect * height gives the width (in inches) of each facet. layout_pad scalar Padding between axes; passed to fig.tight_layout . despine boolean Remove the top and right spines from the plots. dropna boolean Drop missing values from the data before plotting. See also pairplot Easily drawing common uses of PairGrid . FacetGrid Subplot grid for plotting conditional relationships. Examples Calling the constructor sets up a blank grid of subplots with each row and one column corresponding to a numeric variable in the dataset: penguins = sns . load_dataset ( "penguins" ) g = sns . PairGrid ( penguins ) Passing a bivariate function to PairGrid.map() will draw a bivariate plot on every axes: g = sns . PairGrid ( penguins ) g . map ( sns . scatterplot ) Passing separate functions to PairGrid.map_diag() and PairGrid.map_offdiag() will show each variable’s marginal distribution on the diagonal: g = sns . PairGrid ( penguins ) g . map_diag ( sns . histplot ) g . map_offdiag ( sns . scatterplot ) It’s also possible to use different functions on the upper and lower triangles of the plot (which are otherwise redundant): g = sns . PairGrid ( penguins , diag_sharey = False ) g . map_upper ( sns . scatterplot ) g . map_lower ( sns . kdeplot ) g . map_diag ( sns . kdeplot ) Or to avoid the redundancy altogether: g = sns . PairGrid ( penguins , diag_sharey = False , corner = True ) g . map_lower ( sns . scatterplot ) g . map_diag ( sns . kdeplot ) The PairGrid constructor accepts a hue variable. This variable is passed directly to functions that understand it: g = sns . PairGrid ( penguins , hue = "species" ) g . map_diag ( sns . histplot ) g . map_offdiag ( sns . scatterplot ) g . add_legend () But you can also pass matplotlib functions, in which case a groupby is performed internally and a separate plot is drawn for each level: g = sns . PairGrid ( penguins , hue = "species" ) g . map_diag ( plt . hist ) g . map_offdiag ( plt . scatter ) g . add_legend () Additional semantic variables can be assigned by passing data vectors directly while mapping the function: g = sns . PairGrid ( penguins , hue = "species" ) g . map_diag ( sns . histplot ) g . map_offdiag ( sns . scatterplot , size = penguins [ "sex" ]) g . add_legend ( title = "" , adjust_subtitles = True ) When using seaborn functions that can implement a numeric hue mapping, you will want to disable mapping of the variable on the diagonal axes. Note that the hue variable is excluded from the list of variables shown by default: g = sns . PairGrid ( penguins , hue = "body_mass_g" ) g . map_diag ( sns . histplot , hue = None , color = ".3" ) g . map_offdiag ( sns . scatterplot ) g . add_legend () The vars parameter can be used to control exactly which variables are used: variables = [ "body_mass_g" , "bill_length_mm" , "flipper_length_mm" ] g = sns . PairGrid ( penguins , hue = "body_mass_g" , vars = variables ) g . map_diag ( sns . histplot , hue = None , color = ".3" ) g . map_offdiag ( sns . scatterplot ) g . add_legend () The plot need not be square: separate variables can be used to define the rows and columns: x_vars = [ "body_mass_g" , "bill_length_mm" , "bill_depth_mm" , "flipper_length_mm" ] y_vars = [ "body_mass_g" ] g = sns . PairGrid ( penguins , hue = "species" , x_vars = x_vars , y_vars = y_vars ) g . map_diag ( sns . histplot , color = ".3" ) g . map_offdiag ( sns . scatterplot ) g . add_legend () It can be useful to explore different approaches to resolving multiple distributions on the diagonal axes: g = sns . PairGrid ( penguins , hue = "species" ) g . map_diag ( sns . histplot , multiple = "stack" , element = "step" ) g . map_offdiag ( sns . scatterplot ) g . add_legend () Methods __init__ (data, *[, hue, vars, x_vars, ...]) Initialize the plot figure and PairGrid object. add_legend ([legend_data, title, ...]) Draw a legend, maybe placing it outside axes and resizing the figure. apply (func, *args, **kwargs) Pass the grid to a user-supplied function and return self. map (func, **kwargs) Plot with the same function in every subplot. map_diag (func, **kwargs) Plot with a univariate function on each diagonal subplot. map_lower (func, **kwargs) Plot with a bivariate function on the lower diagonal subplots. map_offdiag (func, **kwargs) Plot with a bivariate function on the off-diagonal subplots. map_upper (func, **kwargs) Plot with a bivariate function on the upper diagonal subplots. pipe (func, *args, **kwargs) Pass the grid to a user-supplied function and return its value. savefig (*args, **kwargs) Save an image of the plot. set (**kwargs) Set attributes on each subplot Axes. tick_params ([axis]) Modify the ticks, tick labels, and gridlines. tight_layout (*args, **kwargs) Call fig.tight_layout within rect that exclude the legend. Attributes fig DEPRECATED: prefer the figure property. figure Access the matplotlib.figure.Figure object underlying the grid. legend The matplotlib.legend.Legend object, if present.


Page: https://seaborn.pydata.org/generated/seaborn.jointplot.html#seaborn.jointplot
seaborn.jointplot # seaborn. jointplot ( data = None , * , x = None , y = None , hue = None , kind = 'scatter' , height = 6 , ratio = 5 , space = 0.2 , dropna = False , xlim = None , ylim = None , color = None , palette = None , hue_order = None , hue_norm = None , marginal_ticks = False , joint_kws = None , marginal_kws = None , ** kwargs ) # Draw a plot of two variables with bivariate and univariate graphs. This function provides a convenient interface to the JointGrid class, with several canned plot kinds. This is intended to be a fairly
lightweight wrapper; if you need more flexibility, you should use JointGrid directly. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements. kind { “scatter” | “kde” | “hist” | “hex” | “reg” | “resid” } Kind of plot to draw. See the examples for references to the underlying functions. height numeric Size of the figure (it will be square). ratio numeric Ratio of joint axes height to marginal axes height. space numeric Space between the joint and marginal axes dropna bool If True, remove observations that are missing from x and y . {x, y}lim pairs of numbers Axis limits to set before plotting. color matplotlib color Single color specification for when hue mapping is not used. Otherwise, the
plot will try to hook into the matplotlib property cycle. palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. marginal_ticks bool If False, suppress ticks on the count/density axis of the marginal plots. {joint, marginal}_kws dicts Additional keyword arguments for the plot components. kwargs Additional keyword arguments are passed to the function used to
draw the plot on the joint Axes, superseding items in the joint_kws dictionary. Returns : JointGrid An object managing multiple subplots that correspond to joint and marginal axes
for plotting a bivariate relationship or distribution. See also JointGrid Set up a figure with joint and marginal views on bivariate data. PairGrid Set up a figure with joint and marginal views on multiple variables. jointplot Draw multiple bivariate plots with univariate marginal distributions. Examples In the simplest invocation, assign x and y to create a scatterplot (using scatterplot() ) with marginal histograms (using histplot() ): penguins = sns . load_dataset ( "penguins" ) sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) Assigning a hue variable will add conditional colors to the scatterplot and draw separate density curves (using kdeplot() ) on the marginal axes: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , hue = "species" ) Several different approaches to plotting are available through the kind parameter. Setting kind="kde" will draw both bivariate and univariate KDEs: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , hue = "species" , kind = "kde" ) Set kind="reg" to add a linear regression fit (using regplot() ) and univariate KDE curves: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , kind = "reg" ) There are also two options for bin-based visualization of the joint distribution. The first, with kind="hist" , uses histplot() on all of the axes: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , kind = "hist" ) Alternatively, setting kind="hex" will use matplotlib.axes.Axes.hexbin() to compute a bivariate histogram using hexagonal bins: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , kind = "hex" ) Additional keyword arguments can be passed down to the underlying plots: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , marker = "+" , s = 100 , marginal_kws = dict ( bins = 25 , fill = False ), ) Use JointGrid parameters to control the size and layout of the figure: sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , height = 5 , ratio = 2 , marginal_ticks = True ) To add more layers onto the plot, use the methods on the JointGrid object that jointplot() returns: g = sns . jointplot ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot_joint ( sns . kdeplot , color = "r" , zorder = 0 , levels = 6 ) g . plot_marginals ( sns . rugplot , color = "r" , height =- .15 , clip_on = False )


Page: https://seaborn.pydata.org/generated/seaborn.JointGrid.html#seaborn.JointGrid
seaborn.JointGrid # class seaborn. JointGrid ( data = None , * , x = None , y = None , hue = None , height = 6 , ratio = 5 , space = 0.2 , palette = None , hue_order = None , hue_norm = None , dropna = False , xlim = None , ylim = None , marginal_ticks = False ) # Grid for drawing a bivariate plot with marginal univariate plots. Many plots can be drawn by using the figure-level interface jointplot() .
Use this class directly when you need more flexibility. __init__ ( data = None , * , x = None , y = None , hue = None , height = 6 , ratio = 5 , space = 0.2 , palette = None , hue_order = None , hue_norm = None , dropna = False , xlim = None , ylim = None , marginal_ticks = False ) # Set up the grid of subplots and store data internally for easy plotting. Parameters : data pandas.DataFrame , numpy.ndarray , mapping, or sequence Input data structure. Either a long-form collection of vectors that can be
assigned to named variables or a wide-form dataset that will be internally
reshaped. x, y vectors or keys in data Variables that specify positions on the x and y axes. height number Size of each side of the figure in inches (it will be square). ratio number Ratio of joint axes height to marginal axes height. space number Space between the joint and marginal axes dropna bool If True, remove missing observations before plotting. {x, y}lim pairs of numbers Set axis limits to these values before plotting. marginal_ticks bool If False, suppress ticks on the count/density axis of the marginal plots. hue vector or key in data Semantic variable that is mapped to determine the color of plot elements.
Note: unlike in FacetGrid or PairGrid , the axes-level
functions must support hue to use it in JointGrid . palette string, list, dict, or matplotlib.colors.Colormap Method for choosing the colors to use when mapping the hue semantic.
String values are passed to color_palette() . List or dict values
imply categorical mapping, while a colormap object implies numeric mapping. hue_order vector of strings Specify the order of processing and plotting for categorical levels of the hue semantic. hue_norm tuple or matplotlib.colors.Normalize Either a pair of values that set the normalization range in data units
or an object that will map from data units into a [0, 1] interval. Usage
implies numeric mapping. See also jointplot Draw a bivariate plot with univariate marginal distributions. PairGrid Set up a figure with joint and marginal views on multiple variables. jointplot Draw multiple bivariate plots with univariate marginal distributions. Examples Calling the constructor initializes the figure, but it does not plot anything: penguins = sns . load_dataset ( "penguins" ) sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) The simplest plotting method, JointGrid.plot() accepts a pair of functions (one for the joint axes and one for both marginal axes): g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot ( sns . scatterplot , sns . histplot ) The JointGrid.plot() function also accepts additional keyword arguments, but it passes them to both functions: g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot ( sns . scatterplot , sns . histplot , alpha = .7 , edgecolor = ".2" , linewidth = .5 ) If you need to pass different keyword arguments to each function, you’ll have to invoke JointGrid.plot_joint() and JointGrid.plot_marginals() : g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot_joint ( sns . scatterplot , s = 100 , alpha = .5 ) g . plot_marginals ( sns . histplot , kde = True ) You can also set up the grid without assigning any data: g = sns . JointGrid () You can then plot by accessing the ax_joint , ax_marg_x , and ax_marg_y attributes, which are matplotlib.axes.Axes objects: g = sns . JointGrid () x , y = penguins [ "bill_length_mm" ], penguins [ "bill_depth_mm" ] sns . scatterplot ( x = x , y = y , ec = "b" , fc = "none" , s = 100 , linewidth = 1.5 , ax = g . ax_joint ) sns . histplot ( x = x , fill = False , linewidth = 2 , ax = g . ax_marg_x ) sns . kdeplot ( y = y , linewidth = 2 , ax = g . ax_marg_y ) The plotting methods can use any seaborn functions that accept x and y variables: g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot ( sns . regplot , sns . boxplot ) If the functions accept a hue variable, you can use it by assigning hue when you call the constructor: g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" , hue = "species" ) g . plot ( sns . scatterplot , sns . histplot ) Horizontal and/or vertical reference lines can be added to the joint
and/or marginal axes using :meth: JointGrid.refline : g = sns . JointGrid ( data = penguins , x = "bill_length_mm" , y = "bill_depth_mm" ) g . plot ( sns . scatterplot , sns . histplot ) g . refline ( x = 45 , y = 16 ) The figure will always be square (unless you resize it at the matplotlib layer), but its overall size and layout are configurable. The size is controlled by the height parameter. The relative ratio between the joint and marginal axes is controlled by ratio , and the amount of space between the plots is controlled by space : sns . JointGrid ( height = 4 , ratio = 2 , space = .05 ) By default, the ticks on the density axis of the marginal plots are turned off, but this is configurable: sns . JointGrid ( marginal_ticks = True ) Limits on the two data axes (which are shared across plots) can also be defined when setting up the figure: sns . JointGrid ( xlim = ( - 2 , 5 ), ylim = ( 0 , 10 )) Methods __init__ ([data, x, y, hue, height, ratio, ...]) Set up the grid of subplots and store data internally for easy plotting. apply (func, *args, **kwargs) Pass the grid to a user-supplied function and return self. pipe (func, *args, **kwargs) Pass the grid to a user-supplied function and return its value. plot (joint_func, marginal_func, **kwargs) Draw the plot by passing functions for joint and marginal axes. plot_joint (func, **kwargs) Draw a bivariate plot on the joint axes of the grid. plot_marginals (func, **kwargs) Draw univariate plots on each marginal axes. refline (*[, x, y, joint, marginal, color, ...]) Add a reference line(s) to joint and/or marginal axes. savefig (*args, **kwargs) Save an image of the plot. set (**kwargs) Set attributes on each subplot Axes. set_axis_labels ([xlabel, ylabel]) Set axis labels on the bivariate axes. Attributes fig DEPRECATED: prefer the figure property. figure Access the matplotlib.figure.Figure object underlying the grid.


Page: https://seaborn.pydata.org/generated/seaborn.set_theme.html#seaborn.set_theme
seaborn.set_theme # seaborn. set_theme ( context = 'notebook' , style = 'darkgrid' , palette = 'deep' , font = 'sans-serif' , font_scale = 1 , color_codes = True , rc = None ) # Set aspects of the visual theme for all matplotlib and seaborn plots. This function changes the global defaults for all plots using the
matplotlib rcParams system. The themeing is decomposed into several distinct
sets of parameter values. The options are illustrated in the aesthetics and color palette tutorials. Parameters : context string or dict Scaling parameters, see plotting_context() . style string or dict Axes style parameters, see axes_style() . palette string or sequence Color palette, see color_palette() . font string Font family, see matplotlib font manager. font_scale float, optional Separate scaling factor to independently scale the size of the
font elements. color_codes bool If True and palette is a seaborn palette, remap the shorthand
color codes (e.g. “b”, “g”, “r”, etc.) to the colors from this palette. rc dict or None Dictionary of rc parameter mappings to override the above. Examples By default, seaborn plots will be made with the current values of the
matplotlib rcParams: sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ]) Calling this function with no arguments will activate seaborn’s
“default” theme: sns . set_theme () sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ]) Note that this will take effect for all matplotlib plots, including
those not made using seaborn: plt . bar ([ "A" , "B" , "C" ], [ 1 , 3 , 2 ]) The seaborn theme is decomposed into several distinct sets of parameters
that you can control independently: sns . set_theme ( style = "whitegrid" , palette = "pastel" ) sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ]) Pass None to preserve the current values for a given set of
parameters: sns . set_theme ( style = "white" , palette = None ) sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ]) You can also override any seaborn parameters or define additional
parameters that are part of the matplotlib rc system but not included in
the seaborn themes: custom_params = { "axes.spines.right" : False , "axes.spines.top" : False } sns . set_theme ( style = "ticks" , rc = custom_params ) sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ])


Page: https://seaborn.pydata.org/generated/seaborn.axes_style.html#seaborn.axes_style
seaborn.axes_style # seaborn. axes_style ( style = None , rc = None ) # Get the parameters that control the general style of the plots. The style parameters control properties like the color of the background and
whether a grid is enabled by default. This is accomplished using the
matplotlib rcParams system. The options are illustrated in the aesthetics tutorial . This function can also be used as a context manager to temporarily
alter the global defaults. See set_theme() or set_style() to modify the global defaults for all plots. Parameters : style None, dict, or one of {darkgrid, whitegrid, dark, white, ticks} A dictionary of parameters or the name of a preconfigured style. rc dict, optional Parameter mappings to override the values in the preset seaborn
style dictionaries. This only updates parameters that are
considered part of the style definition. Examples Calling with no arguments will return the current defaults for the style
parameters: sns . axes_style () { 'axes.facecolor' : 'white' , 'axes.edgecolor' : 'black' , 'axes.grid' : False , 'axes.axisbelow' : 'line' , 'axes.labelcolor' : 'black' , 'figure.facecolor' : 'white' , 'grid.color' : '#b0b0b0' , 'grid.linestyle' : '-' , 'text.color' : 'black' , 'xtick.color' : 'black' , 'ytick.color' : 'black' , 'xtick.direction' : 'out' , 'ytick.direction' : 'out' , 'lines.solid_capstyle' : < CapStyle . projecting : 'projecting' > , 'patch.edgecolor' : 'black' , 'patch.force_edgecolor' : False , 'image.cmap' : 'viridis' , 'font.family' : [ 'sans-serif' ], 'font.sans-serif' : [ 'DejaVu Sans' , 'Bitstream Vera Sans' , 'Computer Modern Sans Serif' , 'Lucida Grande' , 'Verdana' , 'Geneva' , 'Lucid' , 'Arial' , 'Helvetica' , 'Avant Garde' , 'sans-serif' ], 'xtick.bottom' : True , 'xtick.top' : False , 'ytick.left' : True , 'ytick.right' : False , 'axes.spines.left' : True , 'axes.spines.bottom' : True , 'axes.spines.right' : True , 'axes.spines.top' : True } Calling with the name of a predefined style will show those parameter
values: sns . axes_style ( "darkgrid" ) { 'figure.facecolor' : 'white' , 'axes.labelcolor' : '.15' , 'xtick.direction' : 'out' , 'ytick.direction' : 'out' , 'xtick.color' : '.15' , 'ytick.color' : '.15' , 'axes.axisbelow' : True , 'grid.linestyle' : '-' , 'text.color' : '.15' , 'font.family' : [ 'sans-serif' ], 'font.sans-serif' : [ 'Arial' , 'DejaVu Sans' , 'Liberation Sans' , 'Bitstream Vera Sans' , 'sans-serif' ], 'lines.solid_capstyle' : 'round' , 'patch.edgecolor' : 'w' , 'patch.force_edgecolor' : True , 'image.cmap' : 'rocket' , 'xtick.top' : False , 'ytick.right' : False , 'axes.grid' : True , 'axes.facecolor' : '#EAEAF2' , 'axes.edgecolor' : 'white' , 'grid.color' : 'white' , 'axes.spines.left' : True , 'axes.spines.bottom' : True , 'axes.spines.right' : True , 'axes.spines.top' : True , 'xtick.bottom' : False , 'ytick.left' : False } Use the function as a context manager to temporarily change the style of
your plots: with sns . axes_style ( "whitegrid" ): sns . barplot ( x = [ 1 , 2 , 3 ], y = [ 2 , 5 , 3 ])


Page: https://seaborn.pydata.org/generated/seaborn.set_style.html#seaborn.set_style
seaborn.set_style # seaborn. set_style ( style = None , rc = None ) # Set the parameters that control the general style of the plots. The style parameters control properties like the color of the background and
whether a grid is enabled by default. This is accomplished using the
matplotlib rcParams system. The options are illustrated in the aesthetics tutorial . See axes_style() to get the parameter values. Parameters : style dict, or one of {darkgrid, whitegrid, dark, white, ticks} A dictionary of parameters or the name of a preconfigured style. rc dict, optional Parameter mappings to override the values in the preset seaborn
style dictionaries. This only updates parameters that are
considered part of the style definition. Examples Call the function with the name of a seaborn style to set the default
for all plots: sns . set_style ( "whitegrid" ) sns . barplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ]) You can also selectively override seaborn’s default parameter values: sns . set_style ( "darkgrid" , { "grid.color" : ".6" , "grid.linestyle" : ":" }) sns . lineplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ])


Page: https://seaborn.pydata.org/generated/seaborn.plotting_context.html#seaborn.plotting_context
seaborn.plotting_context # seaborn. plotting_context ( context = None , font_scale = 1 , rc = None ) # Get the parameters that control the scaling of plot elements. These parameters correspond to label size, line thickness, etc. For more
information, see the aesthetics tutorial . The base context is “notebook”, and the other contexts are “paper”, “talk”,
and “poster”, which are version of the notebook parameters scaled by different
values. Font elements can also be scaled independently of (but relative to)
the other values. This function can also be used as a context manager to temporarily
alter the global defaults. See set_theme() or set_context() to modify the global defaults for all plots. Parameters : context None, dict, or one of {paper, notebook, talk, poster} A dictionary of parameters or the name of a preconfigured set. font_scale float, optional Separate scaling factor to independently scale the size of the
font elements. rc dict, optional Parameter mappings to override the values in the preset seaborn
context dictionaries. This only updates parameters that are
considered part of the context definition. Examples Calling with no arguments will return the current defaults for the
parameters that get scaled: sns . plotting_context () { 'font.size' : 10.0 , 'axes.labelsize' : 'medium' , 'axes.titlesize' : 'large' , 'xtick.labelsize' : 'medium' , 'ytick.labelsize' : 'medium' , 'legend.fontsize' : 'medium' , 'legend.title_fontsize' : None , 'axes.linewidth' : 0.8 , 'grid.linewidth' : 0.8 , 'lines.linewidth' : 1.5 , 'lines.markersize' : 6.0 , 'patch.linewidth' : 1.0 , 'xtick.major.width' : 0.8 , 'ytick.major.width' : 0.8 , 'xtick.minor.width' : 0.6 , 'ytick.minor.width' : 0.6 , 'xtick.major.size' : 3.5 , 'ytick.major.size' : 3.5 , 'xtick.minor.size' : 2.0 , 'ytick.minor.size' : 2.0 } Calling with the name of a predefined style will show those values: sns . plotting_context ( "talk" ) { 'axes.linewidth' : 1.875 , 'grid.linewidth' : 1.5 , 'lines.linewidth' : 2.25 , 'lines.markersize' : 9.0 , 'patch.linewidth' : 1.5 , 'xtick.major.width' : 1.875 , 'ytick.major.width' : 1.875 , 'xtick.minor.width' : 1.5 , 'ytick.minor.width' : 1.5 , 'xtick.major.size' : 9.0 , 'ytick.major.size' : 9.0 , 'xtick.minor.size' : 6.0 , 'ytick.minor.size' : 6.0 , 'font.size' : 18.0 , 'axes.labelsize' : 18.0 , 'axes.titlesize' : 18.0 , 'xtick.labelsize' : 16.5 , 'ytick.labelsize' : 16.5 , 'legend.fontsize' : 16.5 , 'legend.title_fontsize' : 18.0 } Use the function as a context manager to temporarily change the
parameter values: with sns . plotting_context ( "talk" ): sns . lineplot ( x = [ "A" , "B" , "C" ], y = [ 1 , 3 , 2 ])


Page: https://seaborn.pydata.org/generated/seaborn.set_context.html#seaborn.set_context
seaborn.set_context # seaborn. set_context ( context = None , font_scale = 1 , rc = None ) # Set the parameters that control the scaling of plot elements. These parameters correspond to label size, line thickness, etc.
Calling this function modifies the global matplotlib rcParams . For more
information, see the aesthetics tutorial . The base context is “notebook”, and the other contexts are “paper”, “talk”,
and “poster”, which are version of the notebook parameters scaled by different
values. Font elements can also be scaled independently of (but relative to)
the other values. See plotting_context() to get the parameter values. Parameters : context dict, or one of {paper, notebook, talk, poster} A dictionary of parameters or the name of a preconfigured set. font_scale float, optional Separate scaling factor to independently scale the size of the
font elements. rc dict, optional Parameter mappings to override the values in the preset seaborn
context dictionaries. This only updates parameters that are
considered part of the context definition. Examples Call the function with the name of a context to set the default for all
plots: sns . set_context ( "notebook" ) sns . lineplot ( x = [ 0 , 1 , 2 ], y = [ 1 , 3 , 2 ]) You can independently scale the font elements relative to the current
context: sns . set_context ( "notebook" , font_scale = 1.25 ) sns . lineplot ( x = [ 0 , 1 , 2 ], y = [ 1 , 3 , 2 ]) It is also possible to override some of the parameters with specific
values: sns . set_context ( "notebook" , rc = { "lines.linewidth" : 3 }) sns . lineplot ( x = [ 0 , 1 , 2 ], y = [ 1 , 3 , 2 ])


Page: https://seaborn.pydata.org/generated/seaborn.set_color_codes.html#seaborn.set_color_codes
seaborn.set_color_codes # seaborn. set_color_codes ( palette = 'deep' ) # Change how matplotlib color shorthands are interpreted. Calling this will change how shorthand codes like “b” or “g”
are interpreted by matplotlib in subsequent plots. Parameters : palette {deep, muted, pastel, dark, bright, colorblind} Named seaborn palette to use as the source of colors. See also set Color codes can be set through the high-level seaborn style manager. set_palette Color codes can also be set through the function that sets the matplotlib color cycle.


Page: https://seaborn.pydata.org/generated/seaborn.reset_defaults.html#seaborn.reset_defaults
seaborn.reset_defaults # seaborn. reset_defaults ( ) # Restore all RC params to default settings.


Page: https://seaborn.pydata.org/generated/seaborn.reset_orig.html#seaborn.reset_orig
seaborn.reset_orig # seaborn. reset_orig ( ) # Restore all RC params to original settings (respects custom rc).


Page: https://seaborn.pydata.org/generated/seaborn.set.html#seaborn.set
seaborn.set # seaborn. set ( * args , ** kwargs ) # Alias for set_theme() , which is the preferred interface. This function may be removed in the future.


Page: https://seaborn.pydata.org/generated/seaborn.set_palette.html#seaborn.set_palette
seaborn.set_palette # seaborn. set_palette ( palette , n_colors = None , desat = None , color_codes = False ) # Set the matplotlib color cycle using a seaborn palette. Parameters : palette seaborn color palette | matplotlib colormap | hls | husl Palette definition. Should be something color_palette() can process. n_colors int Number of colors in the cycle. The default number of colors will depend
on the format of palette , see the color_palette() documentation for more information. desat float Proportion to desaturate each color by. color_codes bool If True and palette is a seaborn palette, remap the shorthand
color codes (e.g. “b”, “g”, “r”, etc.) to the colors from this palette. See also color_palette build a color palette or set the color cycle temporarily in a with statement. set_context set parameters to scale plot elements set_style set the default parameters for figure style


Page: https://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette
seaborn.color_palette # seaborn. color_palette ( palette = None , n_colors = None , desat = None , as_cmap = False ) # Return a list of colors or continuous colormap defining a palette. Possible palette values include: Name of a seaborn palette (deep, muted, bright, pastel, dark, colorblind) Name of matplotlib colormap ‘husl’ or ‘hls’ ‘ch:<cubehelix arguments>’ ‘light:<color>’, ‘dark:<color>’, ‘blend:<color>,<color>’, A sequence of colors in any format matplotlib accepts Calling this function with palette=None will return the current
matplotlib color cycle. This function can also be used in a with statement to temporarily
set the color cycle for a plot or set of plots. See the tutorial for more information. Parameters : palette None, string, or sequence, optional Name of palette or None to return current palette. If a sequence, input
colors are used but possibly cycled and desaturated. n_colors int, optional Number of colors in the palette. If None , the default will depend
on how palette is specified. Named palettes default to 6 colors,
but grabbing the current palette or passing in a list of colors will
not change the number of colors unless this is specified. Asking for
more colors than exist in the palette will cause it to cycle. Ignored
when as_cmap is True. desat float, optional Proportion to desaturate each color by. as_cmap bool If True, return a matplotlib.colors.ListedColormap . Returns : list of RGB tuples or matplotlib.colors.ListedColormap See also set_palette Set the default color cycle for all plots. set_color_codes Reassign color codes like "b" , "g" , etc. to colors from one of the seaborn palettes. Examples Calling with no arguments returns all colors from the current default
color cycle: sns . color_palette () Other variants on the seaborn categorical color palette can be referenced by name: sns . color_palette ( "pastel" ) Return a specified number of evenly spaced hues in the “HUSL” system: sns . color_palette ( "husl" , 9 ) Return all unique colors in a categorical Color Brewer palette: sns . color_palette ( "Set2" ) Return a diverging Color Brewer palette as a continuous colormap: sns . color_palette ( "Spectral" , as_cmap = True ) Return one of the perceptually-uniform palettes included in seaborn as a discrete palette: sns . color_palette ( "flare" ) Return one of the perceptually-uniform palettes included in seaborn as a continuous colormap: sns . color_palette ( "flare" , as_cmap = True ) Return a customized cubehelix color palette: sns . color_palette ( "ch:s=.25,rot=-.25" , as_cmap = True ) Return a light sequential gradient: sns . color_palette ( "light:#5A9" , as_cmap = True ) Return a reversed dark sequential gradient: sns . color_palette ( "dark:#5A9_r" , as_cmap = True ) Return a blend gradient between two endpoints: sns . color_palette ( "blend:#7AB,#EDA" , as_cmap = True ) Use as a context manager to change the default qualitative color palette: with sns . color_palette ( "Set3" ): sns . relplot ( x = x , y = y , hue = hue , s = 500 , legend = False , height = 1.3 , aspect = 4 ) sns . relplot ( x = x , y = y , hue = hue , s = 500 , legend = False , height = 1.3 , aspect = 4 ) See the underlying color values as hex codes: print ( sns . color_palette ( "pastel6" ) . as_hex ()) [ '#a1c9f4' , '#8de5a1' , '#ff9f9b' , '#d0bbff' , '#fffea3' , '#b9f2f0' ]


Page: https://seaborn.pydata.org/generated/seaborn.husl_palette.html#seaborn.husl_palette
seaborn.husl_palette # seaborn. husl_palette ( n_colors = 6 , h = 0.01 , s = 0.9 , l = 0.65 , as_cmap = False ) # Return hues with constant lightness and saturation in the HUSL system. The hues are evenly sampled along a circular path. The resulting palette will be
appropriate for categorical or cyclical data. The h , l , and s values should be between 0 and 1. This function is similar to hls_palette() , but it uses a nonlinear color
space that is more perceptually uniform. Parameters : n_colors int Number of colors in the palette. h float The value of the first hue. l float The lightness value. s float The saturation intensity. as_cmap bool If True, return a matplotlib colormap object. Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also hls_palette Make a palette using evenly spaced hues in the HSL system. Examples By default, return 6 colors with identical lightness and saturation and evenly-sampled hues: sns . husl_palette () Increase the number of colors: sns . husl_palette ( 8 ) Decrease the lightness: sns . husl_palette ( l = .4 ) Decrease the saturation: sns . husl_palette ( s = .4 ) Change the start-point for hue sampling: sns . husl_palette ( h = .5 ) Return a continuous colormap: sns . husl_palette ( as_cmap = True )


Page: https://seaborn.pydata.org/generated/seaborn.hls_palette.html#seaborn.hls_palette
seaborn.hls_palette # seaborn. hls_palette ( n_colors = 6 , h = 0.01 , l = 0.6 , s = 0.65 , as_cmap = False ) # Return hues with constant lightness and saturation in the HLS system. The hues are evenly sampled along a circular path. The resulting palette will be
appropriate for categorical or cyclical data. The h , l , and s values should be between 0 and 1. Note While the separation of the resulting colors will be mathematically
constant, the HLS system does not construct a perceptually-uniform space,
so their apparent intensity will vary. Parameters : n_colors int Number of colors in the palette. h float The value of the first hue. l float The lightness value. s float The saturation intensity. as_cmap bool If True, return a matplotlib colormap object. Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also husl_palette Make a palette using evenly spaced hues in the HUSL system. Examples By default, return 6 colors with identical lightness and saturation and evenly-sampled hues: sns . hls_palette () Increase the number of colors: sns . hls_palette ( 8 ) Decrease the lightness: sns . hls_palette ( l = .3 ) Decrease the saturation: sns . hls_palette ( s = .3 ) Change the start-point for hue sampling: sns . hls_palette ( h = .5 ) Return a continuous colormap. Notice the perceptual discontinuities, especially around yellow, cyan, and magenta: sns . hls_palette ( as_cmap = True )


Page: https://seaborn.pydata.org/generated/seaborn.cubehelix_palette.html#seaborn.cubehelix_palette
seaborn.cubehelix_palette # seaborn. cubehelix_palette ( n_colors = 6 , start = 0 , rot = 0.4 , gamma = 1.0 , hue = 0.8 , light = 0.85 , dark = 0.15 , reverse = False , as_cmap = False ) # Make a sequential palette from the cubehelix system. This produces a colormap with linearly-decreasing (or increasing)
brightness. That means that information will be preserved if printed to
black and white or viewed by someone who is colorblind.  “cubehelix” is
also available as a matplotlib-based palette, but this function gives the
user more control over the look of the palette and has a different set of
defaults. In addition to using this function, it is also possible to generate a
cubehelix palette generally in seaborn using a string starting with ch: and containing other parameters (e.g. "ch:s=.25,r=-.5" ). Parameters : n_colors int Number of colors in the palette. start float, 0 <= start <= 3 The hue value at the start of the helix. rot float Rotations around the hue wheel over the range of the palette. gamma float 0 <= gamma Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors. hue float, 0 <= hue <= 1 Saturation of the colors. dark float 0 <= dark <= 1 Intensity of the darkest color in the palette. light float 0 <= light <= 1 Intensity of the lightest color in the palette. reverse bool If True, the palette will go from dark to light. as_cmap bool If True, return a matplotlib.colors.ListedColormap . Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also choose_cubehelix_palette Launch an interactive widget to select cubehelix palette parameters. dark_palette Create a sequential palette with dark low values. light_palette Create a sequential palette with bright low values. References Green, D. A. (2011). “A colour scheme for the display of astronomical
intensity images”. Bulletin of the Astromical Society of India, Vol. 39,
p. 289-295. Examples Return a discrete palette with default parameters: sns . cubehelix_palette () Increase the number of colors: sns . cubehelix_palette ( 8 ) Return a continuous colormap rather than a discrete palette: sns . cubehelix_palette ( as_cmap = True ) Change the starting point of the helix: sns . cubehelix_palette ( start = 2 ) Change the amount of rotation in the helix: sns . cubehelix_palette ( rot = .2 ) Rotate in the reverse direction: sns . cubehelix_palette ( rot =- .2 ) Apply a nonlinearity to the luminance ramp: sns . cubehelix_palette ( gamma = .5 ) Increase the saturation of the colors: sns . cubehelix_palette ( hue = 1 ) Change the luminance at the start and end points: sns . cubehelix_palette ( dark = .25 , light = .75 ) Reverse the direction of the luminance ramp: sns . cubehelix_palette ( reverse = True )


Page: https://seaborn.pydata.org/generated/seaborn.dark_palette.html#seaborn.dark_palette
seaborn.dark_palette # seaborn. dark_palette ( color , n_colors = 6 , reverse = False , as_cmap = False , input = 'rgb' ) # Make a sequential palette that blends from dark to color . This kind of palette is good for data that range between relatively
uninteresting low values and interesting high values. The color parameter can be specified in a number of ways, including
all options for defining a color in matplotlib and several additional
color spaces that are handled by seaborn. You can also use the database
of named colors from the XKCD color survey. If you are using the IPython notebook, you can also choose this palette
interactively with the choose_dark_palette() function. Parameters : color base color for high values hex, rgb-tuple, or html color name n_colors int, optional number of colors in the palette reverse bool, optional if True, reverse the direction of the blend as_cmap bool, optional If True, return a matplotlib.colors.ListedColormap . input {‘rgb’, ‘hls’, ‘husl’, xkcd’} Color space to interpret the input color. The first three options
apply to tuple inputs and the latter applies to string inputs. Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also light_palette Create a sequential palette with bright low values. diverging_palette Create a diverging palette with two colors. Examples Define a sequential ramp from a dark gray to a specified color: sns . dark_palette ( "seagreen" ) Specify the color with a hex code: sns . dark_palette ( "#79C" ) Specify the color from the husl system: sns . dark_palette (( 20 , 60 , 50 ), input = "husl" ) Increase the number of colors: sns . dark_palette ( "xkcd:golden" , 8 ) Return a continuous colormap rather than a discrete palette: sns . dark_palette ( "#b285bc" , as_cmap = True )


Page: https://seaborn.pydata.org/generated/seaborn.light_palette.html#seaborn.light_palette
seaborn.light_palette # seaborn. light_palette ( color , n_colors = 6 , reverse = False , as_cmap = False , input = 'rgb' ) # Make a sequential palette that blends from light to color . The color parameter can be specified in a number of ways, including
all options for defining a color in matplotlib and several additional
color spaces that are handled by seaborn. You can also use the database
of named colors from the XKCD color survey. If you are using a Jupyter notebook, you can also choose this palette
interactively with the choose_light_palette() function. Parameters : color base color for high values hex code, html color name, or tuple in input space. n_colors int, optional number of colors in the palette reverse bool, optional if True, reverse the direction of the blend as_cmap bool, optional If True, return a matplotlib.colors.ListedColormap . input {‘rgb’, ‘hls’, ‘husl’, xkcd’} Color space to interpret the input color. The first three options
apply to tuple inputs and the latter applies to string inputs. Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also dark_palette Create a sequential palette with dark low values. diverging_palette Create a diverging palette with two colors. Examples Define a sequential ramp from a light gray to a specified color: sns . light_palette ( "seagreen" ) Specify the color with a hex code: sns . light_palette ( "#79C" ) Specify the color from the husl system: sns . light_palette (( 20 , 60 , 50 ), input = "husl" ) Increase the number of colors: sns . light_palette ( "xkcd:copper" , 8 ) Return a continuous colormap rather than a discrete palette: sns . light_palette ( "#a275ac" , as_cmap = True )


Page: https://seaborn.pydata.org/generated/seaborn.diverging_palette.html#seaborn.diverging_palette
seaborn.diverging_palette # seaborn. diverging_palette ( h_neg , h_pos , s = 75 , l = 50 , sep = 1 , n = 6 , center = 'light' , as_cmap = False ) # Make a diverging palette between two HUSL colors. If you are using the IPython notebook, you can also choose this palette
interactively with the choose_diverging_palette() function. Parameters : h_neg, h_pos float in [0, 359] Anchor hues for negative and positive extents of the map. s float in [0, 100], optional Anchor saturation for both extents of the map. l float in [0, 100], optional Anchor lightness for both extents of the map. sep int, optional Size of the intermediate region. n int, optional Number of colors in the palette (if not returning a cmap) center {“light”, “dark”}, optional Whether the center of the palette is light or dark as_cmap bool, optional If True, return a matplotlib.colors.ListedColormap . Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap See also dark_palette Create a sequential palette with dark values. light_palette Create a sequential palette with light values. Examples


Page: https://seaborn.pydata.org/generated/seaborn.blend_palette.html#seaborn.blend_palette
seaborn.blend_palette # seaborn. blend_palette ( colors , n_colors = 6 , as_cmap = False , input = 'rgb' ) # Make a palette that blends between a list of colors. Parameters : colors sequence of colors in various formats interpreted by input hex code, html color name, or tuple in input space. n_colors int, optional Number of colors in the palette. as_cmap bool, optional If True, return a matplotlib.colors.ListedColormap . Returns : palette list of RGB tuples or matplotlib.colors.ListedColormap Examples


Page: https://seaborn.pydata.org/generated/seaborn.xkcd_palette.html#seaborn.xkcd_palette
seaborn.xkcd_palette # seaborn. xkcd_palette ( colors ) # Make a palette with color names from the xkcd color survey. See xkcd for the full list of colors: https://xkcd.com/color/rgb/ This is just a simple wrapper around the seaborn.xkcd_rgb dictionary. Parameters : colors list of strings List of keys in the seaborn.xkcd_rgb dictionary. Returns : palette A list of colors as RGB tuples. See also crayon_palette Make a palette with Crayola crayon colors.


Page: https://seaborn.pydata.org/generated/seaborn.crayon_palette.html#seaborn.crayon_palette
seaborn.crayon_palette # seaborn. crayon_palette ( colors ) # Make a palette with color names from Crayola crayons. Colors are taken from here: https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors This is just a simple wrapper around the seaborn.crayons dictionary. Parameters : colors list of strings List of keys in the seaborn.crayons dictionary. Returns : palette A list of colors as RGB tuples. See also xkcd_palette Make a palette with named colors from the XKCD color survey.


Page: https://seaborn.pydata.org/generated/seaborn.mpl_palette.html#seaborn.mpl_palette
seaborn.mpl_palette # seaborn. mpl_palette ( name , n_colors = 6 , as_cmap = False ) # Return a palette or colormap from the matplotlib registry. For continuous palettes, evenly-spaced discrete samples are chosen while
excluding the minimum and maximum value in the colormap to provide better
contrast at the extremes. For qualitative palettes (e.g. those from colorbrewer), exact values are
indexed (rather than interpolated), but fewer than n_colors can be returned
if the palette does not define that many. Parameters : name string Name of the palette. This should be a named matplotlib colormap. n_colors int Number of discrete colors in the palette. Returns : list of RGB tuples or matplotlib.colors.ListedColormap Examples Return discrete samples from a continuous matplotlib colormap: sns . mpl_palette ( "viridis" ) Return the continuous colormap instead; note how the extreme values are more intense: sns . mpl_palette ( "viridis" , as_cmap = True ) Return more colors: sns . mpl_palette ( "viridis" , 8 ) Return values from a qualitative colormap: sns . mpl_palette ( "Set2" ) Notice how the palette will only contain distinct colors and can be shorter than requested: sns . mpl_palette ( "Set2" , 10 )


Page: https://seaborn.pydata.org/generated/seaborn.choose_colorbrewer_palette.html#seaborn.choose_colorbrewer_palette
seaborn.choose_colorbrewer_palette # seaborn. choose_colorbrewer_palette ( data_type , as_cmap = False ) # Select a palette from the ColorBrewer set. These palettes are built into matplotlib and can be used by name in
many seaborn functions, or by passing the object returned by this function. Parameters : data_type {‘sequential’, ‘diverging’, ‘qualitative’} This describes the kind of data you want to visualize. See the seaborn
color palette docs for more information about how to choose this value.
Note that you can pass substrings (e.g. ‘q’ for ‘qualitative. as_cmap bool If True, the return value is a matplotlib colormap rather than a
list of discrete colors. Returns : pal or cmap list of colors or matplotlib colormap Object that can be passed to plotting functions. See also dark_palette Create a sequential palette with dark low values. light_palette Create a sequential palette with bright low values. diverging_palette Create a diverging palette from selected colors. cubehelix_palette Create a sequential palette or colormap using the cubehelix system.


Page: https://seaborn.pydata.org/generated/seaborn.choose_cubehelix_palette.html#seaborn.choose_cubehelix_palette
seaborn.choose_cubehelix_palette # seaborn. choose_cubehelix_palette ( as_cmap = False ) # Launch an interactive widget to create a sequential cubehelix palette. This corresponds with the cubehelix_palette() function. This kind
of palette is good for data that range between relatively uninteresting
low values and interesting high values. The cubehelix system allows the
palette to have more hue variance across the range, which can be helpful
for distinguishing a wider range of values. Requires IPython 2+ and must be used in the notebook. Parameters : as_cmap bool If True, the return value is a matplotlib colormap rather than a
list of discrete colors. Returns : pal or cmap list of colors or matplotlib colormap Object that can be passed to plotting functions. See also cubehelix_palette Create a sequential palette or colormap using the cubehelix system.


Page: https://seaborn.pydata.org/generated/seaborn.choose_light_palette.html#seaborn.choose_light_palette
seaborn.choose_light_palette # seaborn. choose_light_palette ( input = 'husl' , as_cmap = False ) # Launch an interactive widget to create a light sequential palette. This corresponds with the light_palette() function. This kind
of palette is good for data that range between relatively uninteresting
low values and interesting high values. Requires IPython 2+ and must be used in the notebook. Parameters : input {‘husl’, ‘hls’, ‘rgb’} Color space for defining the seed value. Note that the default is
different than the default input for light_palette() . as_cmap bool If True, the return value is a matplotlib colormap rather than a
list of discrete colors. Returns : pal or cmap list of colors or matplotlib colormap Object that can be passed to plotting functions. See also light_palette Create a sequential palette with bright low values. dark_palette Create a sequential palette with dark low values. cubehelix_palette Create a sequential palette or colormap using the cubehelix system.


Page: https://seaborn.pydata.org/generated/seaborn.choose_dark_palette.html#seaborn.choose_dark_palette
seaborn.choose_dark_palette # seaborn. choose_dark_palette ( input = 'husl' , as_cmap = False ) # Launch an interactive widget to create a dark sequential palette. This corresponds with the dark_palette() function. This kind
of palette is good for data that range between relatively uninteresting
low values and interesting high values. Requires IPython 2+ and must be used in the notebook. Parameters : input {‘husl’, ‘hls’, ‘rgb’} Color space for defining the seed value. Note that the default is
different than the default input for dark_palette() . as_cmap bool If True, the return value is a matplotlib colormap rather than a
list of discrete colors. Returns : pal or cmap list of colors or matplotlib colormap Object that can be passed to plotting functions. See also dark_palette Create a sequential palette with dark low values. light_palette Create a sequential palette with bright low values. cubehelix_palette Create a sequential palette or colormap using the cubehelix system.


Page: https://seaborn.pydata.org/generated/seaborn.choose_diverging_palette.html#seaborn.choose_diverging_palette
seaborn.choose_diverging_palette # seaborn. choose_diverging_palette ( as_cmap = False ) # Launch an interactive widget to choose a diverging color palette. This corresponds with the diverging_palette() function. This kind
of palette is good for data that range between interesting low values
and interesting high values with a meaningful midpoint. (For example,
change scores relative to some baseline value). Requires IPython 2+ and must be used in the notebook. Parameters : as_cmap bool If True, the return value is a matplotlib colormap rather than a
list of discrete colors. Returns : pal or cmap list of colors or matplotlib colormap Object that can be passed to plotting functions. See also diverging_palette Create a diverging color palette or colormap. choose_colorbrewer_palette Interactively choose palettes from the colorbrewer set, including diverging palettes.


Page: https://seaborn.pydata.org/generated/seaborn.despine.html#seaborn.despine
seaborn.despine # seaborn. despine ( fig = None , ax = None , top = True , right = True , left = False , bottom = False , offset = None , trim = False ) # Remove the top and right spines from plot(s). fig matplotlib figure, optional Figure to despine all axes of, defaults to the current figure. ax matplotlib axes, optional Specific axes object to despine. Ignored if fig is provided. top, right, left, bottom boolean, optional If True, remove that spine. offset int or dict, optional Absolute distance, in points, spines should be moved away
from the axes (negative values move spines inward). A single value
applies to all spines; a dict can be used to set offset values per
side. trim bool, optional If True, limit spines to the smallest and largest major tick
on each non-despined axis. Returns : None


Page: https://seaborn.pydata.org/generated/seaborn.move_legend.html#seaborn.move_legend
seaborn.move_legend # seaborn. move_legend ( obj , loc , ** kwargs ) # Recreate a plot’s legend at a new location. The name is a slight misnomer. Matplotlib legends do not expose public
control over their position parameters. So this function creates a new legend,
copying over the data from the original object, which is then removed. Parameters : obj the object with the plot This argument can be either a seaborn or matplotlib object: seaborn.FacetGrid or seaborn.PairGrid matplotlib.axes.Axes or matplotlib.figure.Figure loc str or int Location argument, as in matplotlib.axes.Axes.legend() . kwargs Other keyword arguments are passed to matplotlib.axes.Axes.legend() . Examples For axes-level functions, pass the matplotlib.axes.Axes object and provide a new location. ax = sns . histplot ( penguins , x = "bill_length_mm" , hue = "species" ) sns . move_legend ( ax , "center right" ) Use the bbox_to_anchor parameter for more fine-grained control, including moving the legend outside of the axes: ax = sns . histplot ( penguins , x = "bill_length_mm" , hue = "species" ) sns . move_legend ( ax , "upper left" , bbox_to_anchor = ( 1 , 1 )) Pass additional matplotlib.axes.Axes.legend() parameters to update other properties: ax = sns . histplot ( penguins , x = "bill_length_mm" , hue = "species" ) sns . move_legend ( ax , "lower center" , bbox_to_anchor = ( .5 , 1 ), ncol = 3 , title = None , frameon = False , ) It’s also possible to move the legend created by a figure-level function. But when fine-tuning the position, you must bear in mind that the figure will have extra blank space on the right: g = sns . displot ( penguins , x = "bill_length_mm" , hue = "species" , col = "island" , col_wrap = 2 , height = 3 , ) sns . move_legend ( g , "upper left" , bbox_to_anchor = ( .55 , .45 )) One way to avoid this would be to set legend_out=False on the FacetGrid : g = sns . displot ( penguins , x = "bill_length_mm" , hue = "species" , col = "island" , col_wrap = 2 , height = 3 , facet_kws = dict ( legend_out = False ), ) sns . move_legend ( g , "upper left" , bbox_to_anchor = ( .55 , .45 ), frameon = False )


Page: https://seaborn.pydata.org/generated/seaborn.saturate.html#seaborn.saturate
seaborn.saturate # seaborn. saturate ( color ) # Return a fully saturated color with the same hue. Parameters : color matplotlib color hex, rgb-tuple, or html color name Returns : new_color rgb tuple saturated color code in RGB tuple representation


Page: https://seaborn.pydata.org/generated/seaborn.desaturate.html#seaborn.desaturate
seaborn.desaturate # seaborn. desaturate ( color , prop ) # Decrease the saturation channel of a color by some percent. Parameters : color matplotlib color hex, rgb-tuple, or html color name prop float saturation channel of color will be multiplied by this value Returns : new_color rgb tuple desaturated color code in RGB tuple representation


Page: https://seaborn.pydata.org/generated/seaborn.set_hls_values.html#seaborn.set_hls_values
seaborn.set_hls_values # seaborn. set_hls_values ( color , h = None , l = None , s = None ) # Independently manipulate the h, l, or s channels of a color. Parameters : color matplotlib color hex, rgb-tuple, or html color name h, l, s floats between 0 and 1, or None new values for each channel in hls space Returns : new_color rgb tuple new color code in RGB tuple representation


Page: https://seaborn.pydata.org/generated/seaborn.load_dataset.html#seaborn.load_dataset
seaborn.load_dataset # seaborn. load_dataset ( name , cache = True , data_home = None , ** kws ) # Load an example dataset from the online repository (requires internet). This function provides quick access to a small number of example datasets
that are useful for documenting seaborn or generating reproducible examples
for bug reports. It is not necessary for normal usage. Note that some of the datasets have a small amount of preprocessing applied
to define a proper ordering for categorical variables. Use get_dataset_names() to see a list of available datasets. Parameters : name str Name of the dataset ( {name}.csv on https://github.com/mwaskom/seaborn-data ). cache boolean, optional If True, try to load from the local cache first, and save to the cache
if a download is required. data_home string, optional The directory in which to cache data; see get_data_home() . kws keys and values, optional Additional keyword arguments are passed to passed through to pandas.read_csv() . Returns : df pandas.DataFrame Tabular data, possibly with some preprocessing applied.


Page: https://seaborn.pydata.org/generated/seaborn.get_dataset_names.html#seaborn.get_dataset_names
seaborn.get_dataset_names # seaborn. get_dataset_names ( ) # Report available example datasets, useful for reporting issues. Requires an internet connection.


Page: https://seaborn.pydata.org/generated/seaborn.get_data_home.html#seaborn.get_data_home
seaborn.get_data_home # seaborn. get_data_home ( data_home = None ) # Return a path to the cache directory for example datasets. This directory is used by load_dataset() . If the data_home argument is not provided, it will use a directory
specified by the SEABORN_DATA environment variable (if it exists)
or otherwise default to an OS-appropriate user cache location.
