---
title: Built-in Exceptions
---

::: index
pair: statement; try pair: statement; except
:::

In Python, all exceptions must be instances of a class that derives from
`BaseException`{.interpreted-text role="class"}. In a
`try`{.interpreted-text role="keyword"} statement with an
`except`{.interpreted-text role="keyword"} clause that mentions a
particular class, that clause also handles any exception classes derived
from that class (but not exception classes from which *it* is derived).
Two exception classes that are not related via subclassing are never
equivalent, even if they have the same name.

::: index
pair: statement; raise
:::

The built-in exceptions listed in this chapter can be generated by the
interpreter or built-in functions. Except where mentioned, they have an
\"associated value\" indicating the detailed cause of the error. This
may be a string or a tuple of several items of information (e.g., an
error code and a string explaining the code). The associated value is
usually passed as arguments to the exception class\'s constructor.

User code can raise built-in exceptions. This can be used to test an
exception handler or to report an error condition \"just like\" the
situation in which the interpreter raises the same exception; but beware
that there is nothing to prevent user code from raising an inappropriate
error.

The built-in exception classes can be subclassed to define new
exceptions; programmers are encouraged to derive new exceptions from the
`Exception`{.interpreted-text role="exc"} class or one of its
subclasses, and not from `BaseException`{.interpreted-text role="exc"}.
More information on defining exceptions is available in the Python
Tutorial under `tut-userexceptions`{.interpreted-text role="ref"}.

# Exception context

::: index
pair: exception; chaining \_\_cause\_\_ (exception attribute)
\_\_context\_\_ (exception attribute) \_\_suppress_context\_\_
(exception attribute)
:::

Three attributes on exception objects provide information about the
context in which the exception was raised:

::: attribute
BaseException.\_\_context\_\_ BaseException.\_\_cause\_\_
BaseException.\_\_suppress_context\_\_

When raising a new exception while another exception is already being
handled, the new exception\'s `!__context__`{.interpreted-text
role="attr"} attribute is automatically set to the handled exception. An
exception may be handled when an `except`{.interpreted-text
role="keyword"} or `finally`{.interpreted-text role="keyword"} clause,
or a `with`{.interpreted-text role="keyword"} statement, is used.

This implicit exception context can be supplemented with an explicit
cause by using `!from`{.interpreted-text role="keyword"} with
`raise`{.interpreted-text role="keyword"}:

    raise new_exc from original_exc

The expression following `from<raise>`{.interpreted-text role="keyword"}
must be an exception or `None`. It will be set as
`!__cause__`{.interpreted-text role="attr"} on the raised exception.
Setting `!__cause__`{.interpreted-text role="attr"} also implicitly sets
the `!__suppress_context__`{.interpreted-text role="attr"} attribute to
`True`, so that using `raise new_exc from None` effectively replaces the
old exception with the new one for display purposes (e.g. converting
`KeyError`{.interpreted-text role="exc"} to
`AttributeError`{.interpreted-text role="exc"}), while leaving the old
exception available in `!__context__`{.interpreted-text role="attr"} for
introspection when debugging.

The default traceback display code shows these chained exceptions in
addition to the traceback for the exception itself. An explicitly
chained exception in `!__cause__`{.interpreted-text role="attr"} is
always shown when present. An implicitly chained exception in
`!__context__`{.interpreted-text role="attr"} is shown only if
`!__cause__`{.interpreted-text role="attr"} is `None`{.interpreted-text
role="const"} and `!__suppress_context__`{.interpreted-text role="attr"}
is false.

In either case, the exception itself is always shown after any chained
exceptions so that the final line of the traceback always shows the last
exception that was raised.
:::

# Inheriting from built-in exceptions

User code can create subclasses that inherit from an exception type.
It\'s recommended to only subclass one exception type at a time to avoid
any possible conflicts between how the bases handle the `args`
attribute, as well as due to possible memory layout incompatibilities.

::: impl-detail
Most built-in exceptions are implemented in C for efficiency, see:
`Objects/exceptions.c`{.interpreted-text role="source"}. Some have
custom memory layouts which makes it impossible to create a subclass
that inherits from multiple exception types. The memory layout of a type
is an implementation detail and might change between Python versions,
leading to new conflicts in the future. Therefore, it\'s recommended to
avoid subclassing multiple exception types altogether.
:::

# Base classes

The following exceptions are used mostly as base classes for other
exceptions.

::: exception
BaseException

The base class for all built-in exceptions. It is not meant to be
directly inherited by user-defined classes (for that, use
`Exception`{.interpreted-text role="exc"}). If `str`{.interpreted-text
role="func"} is called on an instance of this class, the representation
of the argument(s) to the instance are returned, or the empty string
when there were no arguments.

::: attribute
args

The tuple of arguments given to the exception constructor. Some built-in
exceptions (like `OSError`{.interpreted-text role="exc"}) expect a
certain number of arguments and assign a special meaning to the elements
of this tuple, while others are usually called only with a single string
giving an error message.
:::

::: method
with_traceback(tb)

This method sets *tb* as the new traceback for the exception and returns
the exception object. It was more commonly used before the exception
chaining features of `3134`{.interpreted-text role="pep"} became
available. The following example shows how we can convert an instance of
`SomeException` into an instance of `OtherException` while preserving
the traceback. Once raised, the current frame is pushed onto the
traceback of the `OtherException`, as would have happened to the
traceback of the original `SomeException` had we allowed it to propagate
to the caller. :

    try:
        ...
    except SomeException:
        tb = sys.exception().__traceback__
        raise OtherException(...).with_traceback(tb)
:::

::: attribute
\_\_traceback\_\_

A writable field that holds the
`traceback object <traceback-objects>`{.interpreted-text role="ref"}
associated with this exception. See also: `raise`{.interpreted-text
role="ref"}.
:::

::: method
add_note(note)

Add the string `note` to the exception\'s notes which appear in the
standard traceback after the exception string. A
`TypeError`{.interpreted-text role="exc"} is raised if `note` is not a
string.

::: versionadded
3.11
:::
:::

::: attribute
\_\_notes\_\_

A list of the notes of this exception, which were added with
`add_note`{.interpreted-text role="meth"}. This attribute is created
when `add_note`{.interpreted-text role="meth"} is called.

::: versionadded
3.11
:::
:::
:::

::: exception
Exception

All built-in, non-system-exiting exceptions are derived from this class.
All user-defined exceptions should also be derived from this class.
:::

::: exception
ArithmeticError

The base class for those built-in exceptions that are raised for various
arithmetic errors: `OverflowError`{.interpreted-text role="exc"},
`ZeroDivisionError`{.interpreted-text role="exc"},
`FloatingPointError`{.interpreted-text role="exc"}.
:::

::: exception
BufferError

Raised when a `buffer <bufferobjects>`{.interpreted-text role="ref"}
related operation cannot be performed.
:::

::: exception
LookupError

The base class for the exceptions that are raised when a key or index
used on a mapping or sequence is invalid: `IndexError`{.interpreted-text
role="exc"}, `KeyError`{.interpreted-text role="exc"}. This can be
raised directly by `codecs.lookup`{.interpreted-text role="func"}.
:::

# Concrete exceptions

The following exceptions are the exceptions that are usually raised.

::: exception
AssertionError

::: index
pair: statement; assert
:::

Raised when an `assert`{.interpreted-text role="keyword"} statement
fails.
:::

::: exception
AttributeError

Raised when an attribute reference (see
`attribute-references`{.interpreted-text role="ref"}) or assignment
fails. (When an object does not support attribute references or
attribute assignments at all, `TypeError`{.interpreted-text role="exc"}
is raised.)

The `name`{.interpreted-text role="attr"} and `obj`{.interpreted-text
role="attr"} attributes can be set using keyword-only arguments to the
constructor. When set they represent the name of the attribute that was
attempted to be accessed and the object that was accessed for said
attribute, respectively.

::: versionchanged
3.10 Added the `name`{.interpreted-text role="attr"} and
`obj`{.interpreted-text role="attr"} attributes.
:::
:::

::: exception
EOFError

Raised when the `input`{.interpreted-text role="func"} function hits an
end-of-file condition (EOF) without reading any data. (N.B.: the
`io.IOBase.read`{.interpreted-text role="meth"} and
`io.IOBase.readline`{.interpreted-text role="meth"} methods return an
empty string when they hit EOF.)
:::

::: exception
FloatingPointError

Not currently used.
:::

::: exception
GeneratorExit

Raised when a `generator`{.interpreted-text role="term"} or
`coroutine`{.interpreted-text role="term"} is closed; see
`generator.close`{.interpreted-text role="meth"} and
`coroutine.close`{.interpreted-text role="meth"}. It directly inherits
from `BaseException`{.interpreted-text role="exc"} instead of
`Exception`{.interpreted-text role="exc"} since it is technically not an
error.
:::

::: exception
ImportError

Raised when the `import`{.interpreted-text role="keyword"} statement has
troubles trying to load a module. Also raised when the \"from list\" in
`from ... import` has a name that cannot be found.

The optional *name* and *path* keyword-only arguments set the
corresponding attributes:

::: attribute
name

The name of the module that was attempted to be imported.
:::

::: attribute
path

The path to any file which triggered the exception.
:::

::: versionchanged
3.3 Added the `name`{.interpreted-text role="attr"} and
`path`{.interpreted-text role="attr"} attributes.
:::
:::

::: exception
ModuleNotFoundError

A subclass of `ImportError`{.interpreted-text role="exc"} which is
raised by `import`{.interpreted-text role="keyword"} when a module could
not be located. It is also raised when `None` is found in
`sys.modules`{.interpreted-text role="data"}.

::: versionadded
3.6
:::
:::

::: exception
IndexError

Raised when a sequence subscript is out of range. (Slice indices are
silently truncated to fall in the allowed range; if an index is not an
integer, `TypeError`{.interpreted-text role="exc"} is raised.)
:::

::: exception
KeyError

Raised when a mapping (dictionary) key is not found in the set of
existing keys.
:::

::: exception
KeyboardInterrupt

Raised when the user hits the interrupt key (normally
`Control-C`{.interpreted-text role="kbd"} or `Delete`{.interpreted-text
role="kbd"}). During execution, a check for interrupts is made
regularly. The exception inherits from `BaseException`{.interpreted-text
role="exc"} so as to not be accidentally caught by code that catches
`Exception`{.interpreted-text role="exc"} and thus prevent the
interpreter from exiting.

::: note
::: title
Note
:::

Catching a `KeyboardInterrupt`{.interpreted-text role="exc"} requires
special consideration. Because it can be raised at unpredictable points,
it may, in some circumstances, leave the running program in an
inconsistent state. It is generally best to allow
`KeyboardInterrupt`{.interpreted-text role="exc"} to end the program as
quickly as possible or avoid raising it entirely. (See
`handlers-and-exceptions`{.interpreted-text role="ref"}.)
:::
:::

::: exception
MemoryError

Raised when an operation runs out of memory but the situation may still
be rescued (by deleting some objects). The associated value is a string
indicating what kind of (internal) operation ran out of memory. Note
that because of the underlying memory management architecture (C\'s
:c`malloc`{.interpreted-text role="func"} function), the interpreter may
not always be able to completely recover from this situation; it
nevertheless raises an exception so that a stack traceback can be
printed, in case a run-away program was the cause.
:::

::: exception
NameError

Raised when a local or global name is not found. This applies only to
unqualified names. The associated value is an error message that
includes the name that could not be found.

The `name`{.interpreted-text role="attr"} attribute can be set using a
keyword-only argument to the constructor. When set it represent the name
of the variable that was attempted to be accessed.

::: versionchanged
3.10 Added the `name`{.interpreted-text role="attr"} attribute.
:::
:::

::: exception
NotImplementedError

This exception is derived from `RuntimeError`{.interpreted-text
role="exc"}. In user defined base classes, abstract methods should raise
this exception when they require derived classes to override the method,
or while the class is being developed to indicate that the real
implementation still needs to be added.

::: note
::: title
Note
:::

It should not be used to indicate that an operator or method is not
meant to be supported at all \-- in that case either leave the operator
/ method undefined or, if a subclass, set it to `None`{.interpreted-text
role="data"}.
:::

::: caution
::: title
Caution
:::

`!NotImplementedError`{.interpreted-text role="exc"} and
`!NotImplemented`{.interpreted-text role="data"} are not
interchangeable. This exception should only be used as described above;
see `NotImplemented`{.interpreted-text role="data"} for details on
correct usage of the built-in constant.
:::
:::

::: exception
OSError(\[arg\]) OSError(errno, strerror\[, filename\[, winerror\[,
filename2\]\]\])

::: index
pair: module; errno
:::

This exception is raised when a system function returns a system-related
error, including I/O failures such as \"file not found\" or \"disk
full\" (not for illegal argument types or other incidental errors).

The second form of the constructor sets the corresponding attributes,
described below. The attributes default to `None`{.interpreted-text
role="const"} if not specified. For backwards compatibility, if three
arguments are passed, the `~BaseException.args`{.interpreted-text
role="attr"} attribute contains only a 2-tuple of the first two
constructor arguments.

The constructor often actually returns a subclass of
`OSError`{.interpreted-text role="exc"}, as described in [OS
exceptions](#os-exceptions) below. The particular subclass depends on
the final `.errno`{.interpreted-text role="attr"} value. This behaviour
only occurs when constructing `OSError`{.interpreted-text role="exc"}
directly or via an alias, and is not inherited when subclassing.

::: attribute
errno

A numeric error code from the C variable :c`errno`{.interpreted-text
role="data"}.
:::

::: attribute
winerror

Under Windows, this gives you the native Windows error code. The
`.errno`{.interpreted-text role="attr"} attribute is then an approximate
translation, in POSIX terms, of that native error code.

Under Windows, if the *winerror* constructor argument is an integer, the
`.errno`{.interpreted-text role="attr"} attribute is determined from the
Windows error code, and the *errno* argument is ignored. On other
platforms, the *winerror* argument is ignored, and the
`winerror`{.interpreted-text role="attr"} attribute does not exist.
:::

::: attribute
strerror

The corresponding error message, as provided by the operating system. It
is formatted by the C functions :c`perror`{.interpreted-text
role="func"} under POSIX, and :c`FormatMessage`{.interpreted-text
role="func"} under Windows.
:::

::: attribute
filename filename2

For exceptions that involve a file system path (such as
`open`{.interpreted-text role="func"} or `os.unlink`{.interpreted-text
role="func"}), `filename`{.interpreted-text role="attr"} is the file
name passed to the function. For functions that involve two file system
paths (such as `os.rename`{.interpreted-text role="func"}),
`filename2`{.interpreted-text role="attr"} corresponds to the second
file name passed to the function.
:::

::: versionchanged
3.3 `EnvironmentError`{.interpreted-text role="exc"},
`IOError`{.interpreted-text role="exc"},
`WindowsError`{.interpreted-text role="exc"},
`socket.error`{.interpreted-text role="exc"},
`select.error`{.interpreted-text role="exc"} and
`mmap.error`{.interpreted-text role="exc"} have been merged into
`OSError`{.interpreted-text role="exc"}, and the constructor may return
a subclass.
:::

::: versionchanged
3.4 The `filename`{.interpreted-text role="attr"} attribute is now the
original file name passed to the function, instead of the name encoded
to or decoded from the
`filesystem encoding and error handler`{.interpreted-text role="term"}.
Also, the *filename2* constructor argument and attribute was added.
:::
:::

::: exception
OverflowError

Raised when the result of an arithmetic operation is too large to be
represented. This cannot occur for integers (which would rather raise
`MemoryError`{.interpreted-text role="exc"} than give up). However, for
historical reasons, OverflowError is sometimes raised for integers that
are outside a required range. Because of the lack of standardization of
floating-point exception handling in C, most floating-point operations
are not checked.
:::

::: exception
PythonFinalizationError

This exception is derived from `RuntimeError`{.interpreted-text
role="exc"}. It is raised when an operation is blocked during
interpreter shutdown also known as
`Python finalization <interpreter shutdown>`{.interpreted-text
role="term"}.

Examples of operations which can be blocked with a
`PythonFinalizationError`{.interpreted-text role="exc"} during the
Python finalization:

-   Creating a new Python thread.
-   `os.fork`{.interpreted-text role="func"}.

See also the `sys.is_finalizing`{.interpreted-text role="func"}
function.

::: versionadded
3.13 Previously, a plain `RuntimeError`{.interpreted-text role="exc"}
was raised.
:::
:::

::: exception
RecursionError

This exception is derived from `RuntimeError`{.interpreted-text
role="exc"}. It is raised when the interpreter detects that the maximum
recursion depth (see `sys.getrecursionlimit`{.interpreted-text
role="func"}) is exceeded.

::: versionadded
3.5 Previously, a plain `RuntimeError`{.interpreted-text role="exc"} was
raised.
:::
:::

::: exception
ReferenceError

This exception is raised when a weak reference proxy, created by the
`weakref.proxy`{.interpreted-text role="func"} function, is used to
access an attribute of the referent after it has been garbage collected.
For more information on weak references, see the
`weakref`{.interpreted-text role="mod"} module.
:::

::: exception
RuntimeError

Raised when an error is detected that doesn\'t fall in any of the other
categories. The associated value is a string indicating what precisely
went wrong.
:::

::: exception
StopIteration

Raised by built-in function `next`{.interpreted-text role="func"} and an
`iterator`{.interpreted-text role="term"}\'s
`~iterator.__next__`{.interpreted-text role="meth"} method to signal
that there are no further items produced by the iterator.

::: attribute
StopIteration.value

The exception object has a single attribute `!value`{.interpreted-text
role="attr"}, which is given as an argument when constructing the
exception, and defaults to `None`{.interpreted-text role="const"}.
:::

When a `generator`{.interpreted-text role="term"} or
`coroutine`{.interpreted-text role="term"} function returns, a new
`StopIteration`{.interpreted-text role="exc"} instance is raised, and
the value returned by the function is used as the
`value`{.interpreted-text role="attr"} parameter to the constructor of
the exception.

If a generator code directly or indirectly raises
`StopIteration`{.interpreted-text role="exc"}, it is converted into a
`RuntimeError`{.interpreted-text role="exc"} (retaining the
`StopIteration`{.interpreted-text role="exc"} as the new exception\'s
cause).

::: versionchanged
3.3 Added `value` attribute and the ability for generator functions to
use it to return a value.
:::

::: versionchanged
3.5 Introduced the RuntimeError transformation via
`from __future__ import generator_stop`, see `479`{.interpreted-text
role="pep"}.
:::

::: versionchanged
3.7 Enable `479`{.interpreted-text role="pep"} for all code by default:
a `StopIteration`{.interpreted-text role="exc"} error raised in a
generator is transformed into a `RuntimeError`{.interpreted-text
role="exc"}.
:::
:::

::: exception
StopAsyncIteration

Must be raised by `~object.__anext__`{.interpreted-text role="meth"}
method of an `asynchronous iterator`{.interpreted-text role="term"}
object to stop the iteration.

::: versionadded
3.5
:::
:::

::: exception
SyntaxError(message, details)

Raised when the parser encounters a syntax error. This may occur in an
`import`{.interpreted-text role="keyword"} statement, in a call to the
built-in functions `compile`{.interpreted-text role="func"},
`exec`{.interpreted-text role="func"}, or `eval`{.interpreted-text
role="func"}, or when reading the initial script or standard input (also
interactively).

The `str`{.interpreted-text role="func"} of the exception instance
returns only the error message. Details is a tuple whose members are
also available as separate attributes.

::: attribute
filename

The name of the file the syntax error occurred in.
:::

::: attribute
lineno

Which line number in the file the error occurred in. This is 1-indexed:
the first line in the file has a `lineno` of 1.
:::

::: attribute
offset

The column in the line where the error occurred. This is 1-indexed: the
first character in the line has an `offset` of 1.
:::

::: attribute
text

The source code text involved in the error.
:::

::: attribute
end_lineno

Which line number in the file the error occurred ends in. This is
1-indexed: the first line in the file has a `lineno` of 1.
:::

::: attribute
end_offset

The column in the end line where the error occurred finishes. This is
1-indexed: the first character in the line has an `offset` of 1.
:::

For errors in f-string fields, the message is prefixed by \"f-string: \"
and the offsets are offsets in a text constructed from the replacement
expression. For example, compiling f\'Bad {a b} field\' results in this
args attribute: (\'f-string: \...\', (\'\', 1, 2, \'(a b)n\', 1, 5)).

::: versionchanged
3.10 Added the `end_lineno`{.interpreted-text role="attr"} and
`end_offset`{.interpreted-text role="attr"} attributes.
:::
:::

::: exception
IndentationError

Base class for syntax errors related to incorrect indentation. This is a
subclass of `SyntaxError`{.interpreted-text role="exc"}.
:::

::: exception
TabError

Raised when indentation contains an inconsistent use of tabs and spaces.
This is a subclass of `IndentationError`{.interpreted-text role="exc"}.
:::

::: exception
SystemError

Raised when the interpreter finds an internal error, but the situation
does not look so serious to cause it to abandon all hope. The associated
value is a string indicating what went wrong (in low-level terms). In
`CPython`{.interpreted-text role="term"}, this could be raised by
incorrectly using Python\'s C API, such as returning a `NULL` value
without an exception set.

If you\'re confident that this exception wasn\'t your fault, or the
fault of a package you\'re using, you should report this to the author
or maintainer of your Python interpreter. Be sure to report the version
of the Python interpreter (`sys.version`; it is also printed at the
start of an interactive Python session), the exact error message (the
exception\'s associated value) and if possible the source of the program
that triggered the error.
:::

::: exception
SystemExit

This exception is raised by the `sys.exit`{.interpreted-text
role="func"} function. It inherits from
`BaseException`{.interpreted-text role="exc"} instead of
`Exception`{.interpreted-text role="exc"} so that it is not accidentally
caught by code that catches `Exception`{.interpreted-text role="exc"}.
This allows the exception to properly propagate up and cause the
interpreter to exit. When it is not handled, the Python interpreter
exits; no stack traceback is printed. The constructor accepts the same
optional argument passed to `sys.exit`{.interpreted-text role="func"}.
If the value is an integer, it specifies the system exit status (passed
to C\'s :c`exit`{.interpreted-text role="func"} function); if it is
`None`, the exit status is zero; if it has another type (such as a
string), the object\'s value is printed and the exit status is one.

A call to `sys.exit`{.interpreted-text role="func"} is translated into
an exception so that clean-up handlers (`finally`{.interpreted-text
role="keyword"} clauses of `try`{.interpreted-text role="keyword"}
statements) can be executed, and so that a debugger can execute a script
without running the risk of losing control. The
`os._exit`{.interpreted-text role="func"} function can be used if it is
absolutely positively necessary to exit immediately (for example, in the
child process after a call to `os.fork`{.interpreted-text role="func"}).

::: attribute
code

The exit status or error message that is passed to the constructor.
(Defaults to `None`.)
:::
:::

::: exception
TypeError

Raised when an operation or function is applied to an object of
inappropriate type. The associated value is a string giving details
about the type mismatch.

This exception may be raised by user code to indicate that an attempted
operation on an object is not supported, and is not meant to be. If an
object is meant to support a given operation but has not yet provided an
implementation, `NotImplementedError`{.interpreted-text role="exc"} is
the proper exception to raise.

Passing arguments of the wrong type (e.g. passing a
`list`{.interpreted-text role="class"} when an `int`{.interpreted-text
role="class"} is expected) should result in a
`TypeError`{.interpreted-text role="exc"}, but passing arguments with
the wrong value (e.g. a number outside expected boundaries) should
result in a `ValueError`{.interpreted-text role="exc"}.
:::

::: exception
UnboundLocalError

Raised when a reference is made to a local variable in a function or
method, but no value has been bound to that variable. This is a subclass
of `NameError`{.interpreted-text role="exc"}.
:::

::: exception
UnicodeError

Raised when a Unicode-related encoding or decoding error occurs. It is a
subclass of `ValueError`{.interpreted-text role="exc"}.

`UnicodeError`{.interpreted-text role="exc"} has attributes that
describe the encoding or decoding error. For example,
`err.object[err.start:err.end]` gives the particular invalid input that
the codec failed on.

::: attribute
encoding

The name of the encoding that raised the error.
:::

::: attribute
reason

A string describing the specific codec error.
:::

::: attribute
object

The object the codec was attempting to encode or decode.
:::

::: attribute
start

The first index of invalid data in `object`{.interpreted-text
role="attr"}.

This value should not be negative as it is interpreted as an absolute
offset but this constraint is not enforced at runtime.
:::

::: attribute
end

The index after the last invalid data in `object`{.interpreted-text
role="attr"}.

This value should not be negative as it is interpreted as an absolute
offset but this constraint is not enforced at runtime.
:::
:::

::: exception
UnicodeEncodeError

Raised when a Unicode-related error occurs during encoding. It is a
subclass of `UnicodeError`{.interpreted-text role="exc"}.
:::

::: exception
UnicodeDecodeError

Raised when a Unicode-related error occurs during decoding. It is a
subclass of `UnicodeError`{.interpreted-text role="exc"}.
:::

::: exception
UnicodeTranslateError

Raised when a Unicode-related error occurs during translating. It is a
subclass of `UnicodeError`{.interpreted-text role="exc"}.
:::

::: exception
ValueError

Raised when an operation or function receives an argument that has the
right type but an inappropriate value, and the situation is not
described by a more precise exception such as
`IndexError`{.interpreted-text role="exc"}.
:::

::: exception
ZeroDivisionError

Raised when the second argument of a division or modulo operation is
zero. The associated value is a string indicating the type of the
operands and the operation.
:::

The following exceptions are kept for compatibility with previous
versions; starting from Python 3.3, they are aliases of
`OSError`{.interpreted-text role="exc"}.

::: exception
EnvironmentError
:::

::: exception
IOError
:::

::: exception
WindowsError

Only available on Windows.
:::

## OS exceptions

The following exceptions are subclasses of `OSError`{.interpreted-text
role="exc"}, they get raised depending on the system error code.

::: exception
BlockingIOError

Raised when an operation would block on an object (e.g. socket) set for
non-blocking operation. Corresponds to :c`errno`{.interpreted-text
role="data"} :py`~errno.EAGAIN`{.interpreted-text role="const"},
:py`~errno.EALREADY`{.interpreted-text role="const"},
:py`~errno.EWOULDBLOCK`{.interpreted-text role="const"} and
:py`~errno.EINPROGRESS`{.interpreted-text role="const"}.

In addition to those of `OSError`{.interpreted-text role="exc"},
`BlockingIOError`{.interpreted-text role="exc"} can have one more
attribute:

::: attribute
characters_written

An integer containing the number of characters written to the stream
before it blocked. This attribute is available when using the buffered
I/O classes from the `io`{.interpreted-text role="mod"} module.
:::
:::

::: exception
ChildProcessError

Raised when an operation on a child process failed. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.ECHILD`{.interpreted-text role="const"}.
:::

::: exception
ConnectionError

A base class for connection-related issues.

Subclasses are `BrokenPipeError`{.interpreted-text role="exc"},
`ConnectionAbortedError`{.interpreted-text role="exc"},
`ConnectionRefusedError`{.interpreted-text role="exc"} and
`ConnectionResetError`{.interpreted-text role="exc"}.
:::

::: exception
BrokenPipeError

A subclass of `ConnectionError`{.interpreted-text role="exc"}, raised
when trying to write on a pipe while the other end has been closed, or
trying to write on a socket which has been shutdown for writing.
Corresponds to :c`errno`{.interpreted-text role="data"}
:py`~errno.EPIPE`{.interpreted-text role="const"} and
:py`~errno.ESHUTDOWN`{.interpreted-text role="const"}.
:::

::: exception
ConnectionAbortedError

A subclass of `ConnectionError`{.interpreted-text role="exc"}, raised
when a connection attempt is aborted by the peer. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.ECONNABORTED`{.interpreted-text role="const"}.
:::

::: exception
ConnectionRefusedError

A subclass of `ConnectionError`{.interpreted-text role="exc"}, raised
when a connection attempt is refused by the peer. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.ECONNREFUSED`{.interpreted-text role="const"}.
:::

::: exception
ConnectionResetError

A subclass of `ConnectionError`{.interpreted-text role="exc"}, raised
when a connection is reset by the peer. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.ECONNRESET`{.interpreted-text role="const"}.
:::

::: exception
FileExistsError

Raised when trying to create a file or directory which already exists.
Corresponds to :c`errno`{.interpreted-text role="data"}
:py`~errno.EEXIST`{.interpreted-text role="const"}.
:::

::: exception
FileNotFoundError

Raised when a file or directory is requested but doesn\'t exist.
Corresponds to :c`errno`{.interpreted-text role="data"}
:py`~errno.ENOENT`{.interpreted-text role="const"}.
:::

::: exception
InterruptedError

Raised when a system call is interrupted by an incoming signal.
Corresponds to :c`errno`{.interpreted-text role="data"}
:py`~errno.EINTR`{.interpreted-text role="const"}.

::: versionchanged
3.5 Python now retries system calls when a syscall is interrupted by a
signal, except if the signal handler raises an exception (see
`475`{.interpreted-text role="pep"} for the rationale), instead of
raising `InterruptedError`{.interpreted-text role="exc"}.
:::
:::

::: exception
IsADirectoryError

Raised when a file operation (such as `os.remove`{.interpreted-text
role="func"}) is requested on a directory. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.EISDIR`{.interpreted-text role="const"}.
:::

::: exception
NotADirectoryError

Raised when a directory operation (such as
`os.listdir`{.interpreted-text role="func"}) is requested on something
which is not a directory. On most POSIX platforms, it may also be raised
if an operation attempts to open or traverse a non-directory file as if
it were a directory. Corresponds to :c`errno`{.interpreted-text
role="data"} :py`~errno.ENOTDIR`{.interpreted-text role="const"}.
:::

::: exception
PermissionError

Raised when trying to run an operation without the adequate access
rights - for example filesystem permissions. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.EACCES`{.interpreted-text role="const"},
:py`~errno.EPERM`{.interpreted-text role="const"}, and
:py`~errno.ENOTCAPABLE`{.interpreted-text role="const"}.

::: versionchanged
3.11.1 WASI\'s :py`~errno.ENOTCAPABLE`{.interpreted-text role="const"}
is now mapped to `PermissionError`{.interpreted-text role="exc"}.
:::
:::

::: exception
ProcessLookupError

Raised when a given process doesn\'t exist. Corresponds to
:c`errno`{.interpreted-text role="data"}
:py`~errno.ESRCH`{.interpreted-text role="const"}.
:::

::: exception
TimeoutError

Raised when a system function timed out at the system level. Corresponds
to :c`errno`{.interpreted-text role="data"}
:py`~errno.ETIMEDOUT`{.interpreted-text role="const"}.
:::

::: versionadded
3.3 All the above `OSError`{.interpreted-text role="exc"} subclasses
were added.
:::

::: seealso
`3151`{.interpreted-text role="pep"} - Reworking the OS and IO exception
hierarchy
:::

# Warnings {#warning-categories-as-exceptions}

The following exceptions are used as warning categories; see the
`warning-categories`{.interpreted-text role="ref"} documentation for
more details.

::: exception
Warning

Base class for warning categories.
:::

::: exception
UserWarning

Base class for warnings generated by user code.
:::

::: exception
DeprecationWarning

Base class for warnings about deprecated features when those warnings
are intended for other Python developers.

Ignored by the default warning filters, except in the `__main__` module
(`565`{.interpreted-text role="pep"}). Enabling the
`Python Development Mode <devmode>`{.interpreted-text role="ref"} shows
this warning.

The deprecation policy is described in `387`{.interpreted-text
role="pep"}.
:::

::: exception
PendingDeprecationWarning

Base class for warnings about features which are obsolete and expected
to be deprecated in the future, but are not deprecated at the moment.

This class is rarely used as emitting a warning about a possible
upcoming deprecation is unusual, and
`DeprecationWarning`{.interpreted-text role="exc"} is preferred for
already active deprecations.

Ignored by the default warning filters. Enabling the `Python
Development Mode <devmode>`{.interpreted-text role="ref"} shows this
warning.

The deprecation policy is described in `387`{.interpreted-text
role="pep"}.
:::

::: exception
SyntaxWarning

Base class for warnings about dubious syntax.
:::

::: exception
RuntimeWarning

Base class for warnings about dubious runtime behavior.
:::

::: exception
FutureWarning

Base class for warnings about deprecated features when those warnings
are intended for end users of applications that are written in Python.
:::

::: exception
ImportWarning

Base class for warnings about probable mistakes in module imports.

Ignored by the default warning filters. Enabling the `Python
Development Mode <devmode>`{.interpreted-text role="ref"} shows this
warning.
:::

::: exception
UnicodeWarning

Base class for warnings related to Unicode.
:::

::: exception
EncodingWarning

Base class for warnings related to encodings.

See `io-encoding-warning`{.interpreted-text role="ref"} for details.

::: versionadded
3.10
:::
:::

::: exception
BytesWarning

Base class for warnings related to `bytes`{.interpreted-text
role="class"} and `bytearray`{.interpreted-text role="class"}.
:::

::: exception
ResourceWarning

Base class for warnings related to resource usage.

Ignored by the default warning filters. Enabling the `Python
Development Mode <devmode>`{.interpreted-text role="ref"} shows this
warning.

::: versionadded
3.2
:::
:::

# Exception groups {#lib-exception-groups}

The following are used when it is necessary to raise multiple unrelated
exceptions. They are part of the exception hierarchy so they can be
handled with `except`{.interpreted-text role="keyword"} like all other
exceptions. In addition, they are recognised by
`except*<except_star>`{.interpreted-text role="keyword"}, which matches
their subgroups based on the types of the contained exceptions.

::: exception
ExceptionGroup(msg, excs)
:::

::: exception
BaseExceptionGroup(msg, excs)

Both of these exception types wrap the exceptions in the sequence
`excs`. The `msg` parameter must be a string. The difference between the
two classes is that `BaseExceptionGroup`{.interpreted-text role="exc"}
extends `BaseException`{.interpreted-text role="exc"} and it can wrap
any exception, while `ExceptionGroup`{.interpreted-text role="exc"}
extends `Exception`{.interpreted-text role="exc"} and it can only wrap
subclasses of `Exception`{.interpreted-text role="exc"}. This design is
so that `except Exception` catches an `ExceptionGroup`{.interpreted-text
role="exc"} but not `BaseExceptionGroup`{.interpreted-text role="exc"}.

The `BaseExceptionGroup`{.interpreted-text role="exc"} constructor
returns an `ExceptionGroup`{.interpreted-text role="exc"} rather than a
`BaseExceptionGroup`{.interpreted-text role="exc"} if all contained
exceptions are `Exception`{.interpreted-text role="exc"} instances, so
it can be used to make the selection automatic. The
`ExceptionGroup`{.interpreted-text role="exc"} constructor, on the other
hand, raises a `TypeError`{.interpreted-text role="exc"} if any
contained exception is not an `Exception`{.interpreted-text role="exc"}
subclass.

::: attribute
message

The `msg` argument to the constructor. This is a read-only attribute.
:::

::: attribute
exceptions

A tuple of the exceptions in the `excs` sequence given to the
constructor. This is a read-only attribute.
:::

::: method
subgroup(condition)

Returns an exception group that contains only the exceptions from the
current group that match *condition*, or `None` if the result is empty.

The condition can be an exception type or tuple of exception types, in
which case each exception is checked for a match using the same check
that is used in an `except` clause. The condition can also be a callable
(other than a type object) that accepts an exception as its single
argument and returns true for the exceptions that should be in the
subgroup.

The nesting structure of the current exception is preserved in the
result, as are the values of its `message`{.interpreted-text
role="attr"}, `~BaseException.__traceback__`{.interpreted-text
role="attr"}, `~BaseException.__cause__`{.interpreted-text role="attr"},
`~BaseException.__context__`{.interpreted-text role="attr"} and
`~BaseException.__notes__`{.interpreted-text role="attr"} fields. Empty
nested groups are omitted from the result.

The condition is checked for all exceptions in the nested exception
group, including the top-level and any nested exception groups. If the
condition is true for such an exception group, it is included in the
result in full.

::: versionadded
3.13 `condition` can be any callable which is not a type object.
:::
:::

::: method
split(condition)

Like `subgroup`{.interpreted-text role="meth"}, but returns the pair
`(match, rest)` where `match` is `subgroup(condition)` and `rest` is the
remaining non-matching part.
:::

::: method
derive(excs)

Returns an exception group with the same `message`{.interpreted-text
role="attr"}, but which wraps the exceptions in `excs`.

This method is used by `subgroup`{.interpreted-text role="meth"} and
`split`{.interpreted-text role="meth"}, which are used in various
contexts to break up an exception group. A subclass needs to override it
in order to make `subgroup`{.interpreted-text role="meth"} and
`split`{.interpreted-text role="meth"} return instances of the subclass
rather than `ExceptionGroup`{.interpreted-text role="exc"}.

`subgroup`{.interpreted-text role="meth"} and `split`{.interpreted-text
role="meth"} copy the `~BaseException.__traceback__`{.interpreted-text
role="attr"}, `~BaseException.__cause__`{.interpreted-text role="attr"},
`~BaseException.__context__`{.interpreted-text role="attr"} and
`~BaseException.__notes__`{.interpreted-text role="attr"} fields from
the original exception group to the one returned by
`derive`{.interpreted-text role="meth"}, so these fields do not need to
be updated by `derive`{.interpreted-text role="meth"}.

::: doctest
\>\>\> class MyGroup(ExceptionGroup): \... def derive(self, excs): \...
return MyGroup(self.message, excs) \... \>\>\> e = MyGroup(\"eg\",
\[ValueError(1), TypeError(2)\]) \>\>\> e.add_note(\"a note\") \>\>\>
e.\_\_context\_\_ = Exception(\"context\") \>\>\> e.\_\_cause\_\_ =
Exception(\"cause\") \>\>\> try: \... raise e \... except Exception as
e: \... exc = e \... \>\>\> match, rest = exc.split(ValueError) \>\>\>
exc, exc.\_\_context\_\_, exc.\_\_cause\_\_, exc.\_\_notes\_\_
(MyGroup(\'eg\', \[ValueError(1), TypeError(2)\]),
Exception(\'context\'), Exception(\'cause\'), \[\'a note\'\]) \>\>\>
match, match.\_\_context\_\_, match.\_\_cause\_\_, match.\_\_notes\_\_
(MyGroup(\'eg\', \[ValueError(1)\]), Exception(\'context\'),
Exception(\'cause\'), \[\'a note\'\]) \>\>\> rest, rest.\_\_context\_\_,
rest.\_\_cause\_\_, rest.\_\_notes\_\_ (MyGroup(\'eg\',
\[TypeError(2)\]), Exception(\'context\'), Exception(\'cause\'), \[\'a
note\'\]) \>\>\> exc.\_\_traceback\_\_ is match.\_\_traceback\_\_ is
rest.\_\_traceback\_\_ True
:::
:::

Note that `BaseExceptionGroup`{.interpreted-text role="exc"} defines
`~object.__new__`{.interpreted-text role="meth"}, so subclasses that
need a different constructor signature need to override that rather than
`~object.__init__`{.interpreted-text role="meth"}. For example, the
following defines an exception group subclass which accepts an exit_code
and and constructs the group\'s message from it. :

    class Errors(ExceptionGroup):
       def __new__(cls, errors, exit_code):
          self = super().__new__(Errors, f"exit code: {exit_code}", errors)
          self.exit_code = exit_code
          return self

       def derive(self, excs):
          return Errors(excs, self.exit_code)

Like `ExceptionGroup`{.interpreted-text role="exc"}, any subclass of
`BaseExceptionGroup`{.interpreted-text role="exc"} which is also a
subclass of `Exception`{.interpreted-text role="exc"} can only wrap
instances of `Exception`{.interpreted-text role="exc"}.

::: versionadded
3.11
:::
:::

# Exception hierarchy

The class hierarchy for built-in exceptions is:

::: {.literalinclude language="text"}
../../Lib/test/exception_hierarchy.txt
:::
