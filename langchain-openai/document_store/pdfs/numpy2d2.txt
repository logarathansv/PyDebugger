Page: https://numpy.org/doc/stable/release/2.2.0-notes.html
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#numpy-2-2-0-release-notes
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#deprecations
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/27735



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#expired-deprecations
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/27160



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#compatibility-notes
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://numpy.org/doc/stable/reference/generated/numpy.cov.html#numpy.cov
numpy.cov # numpy. cov ( m , y = None , rowvar = True , bias = False , ddof = None , fweights = None , aweights = None , * , dtype = None ) [source] # Estimate a covariance matrix, given data and weights. Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, \(X = [x_1, x_2, ... x_N]^T\) ,
then the covariance matrix element \(C_{ij}\) is the covariance of \(x_i\) and \(x_j\) . The element \(C_{ii}\) is the variance
of \(x_i\) . See the notes for an outline of the algorithm. Parameters : m array_like A 1-D or 2-D array containing multiple variables and observations.
Each row of m represents a variable, and each column a single
observation of all those variables. Also see rowvar below. y array_like, optional An additional set of variables and observations. y has the same form
as that of m . rowvar bool, optional If rowvar is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations. bias bool, optional Default normalization (False) is by (N - 1) , where N is the
number of observations given (unbiased estimate). If bias is True,
then normalization is by N . These values can be overridden by using
the keyword ddof in numpy versions >= 1.5. ddof int, optional If not None the default value implied by bias is overridden.
Note that ddof=1 will return the unbiased estimate, even if both fweights and aweights are specified, and ddof=0 will return
the simple average. See the notes for the details. The default value
is None . fweights array_like, int, optional 1-D array of integer frequency weights; the number of times each
observation vector should be repeated. aweights array_like, optional 1-D array of observation vector weights. These relative weights are
typically large for observations considered “important” and smaller for
observations considered less “important”. If ddof=0 the array of
weights can be used to assign probabilities to observation vectors. dtype data-type, optional Data-type of the result. By default, the return data-type will have
at least numpy.float64 precision. New in version 1.20. Returns : out ndarray The covariance matrix of the variables. See also corrcoef Normalized covariance matrix Notes Assume that the observations are in the columns of the observation
array m and let f = fweights and a = aweights for brevity. The
steps to compute the weighted covariance are as follows: >>> m = np . arange ( 10 , dtype = np . float64 ) >>> f = np . arange ( 10 ) * 2 >>> a = np . arange ( 10 ) ** 2. >>> ddof = 1 >>> w = f * a >>> v1 = np . sum ( w ) >>> v2 = np . sum ( w * a ) >>> m -= np . sum ( m * w , axis = None , keepdims = True ) / v1 >>> cov = np . dot ( m * w , m . T ) * v1 / ( v1 ** 2 - ddof * v2 ) Note that when a == 1 , the normalization factor v1 / (v1**2 - ddof * v2) goes over to 1 / (np.sum(f) - ddof) as it should. Examples >>> import numpy as np Consider two variables, \(x_0\) and \(x_1\) , which
correlate perfectly, but in opposite directions: >>> x = np . array ([[ 0 , 2 ], [ 1 , 1 ], [ 2 , 0 ]]) . T >>> x array([[0, 1, 2], [2, 1, 0]]) Note how \(x_0\) increases while \(x_1\) decreases. The covariance
matrix shows this clearly: >>> np . cov ( x ) array([[ 1., -1.], [-1.,  1.]]) Note that element \(C_{0,1}\) , which shows the correlation between \(x_0\) and \(x_1\) , is negative. Further, note how x and y are combined: >>> x = [ - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , 0.12 ] >>> X = np . stack (( x , y ), axis = 0 ) >>> np . cov ( X ) array([[11.71      , -4.286     ], # may vary [-4.286     ,  2.144133]]) >>> np . cov ( x , y ) array([[11.71      , -4.286     ], # may vary [-4.286     ,  2.144133]]) >>> np . cov ( x ) array(11.71)


Page: https://github.com/numpy/numpy/pull/27661



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#new-features
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://numpy.org/doc/stable/reference/generated/numpy.matvec.html#numpy.matvec
numpy.matvec # numpy. matvec ( x1 , x2 , / , out=None , * , casting='same_kind' , order='K' , dtype=None , subok=True [ , signature , axes , axis ] ) = <ufunc 'matvec'> # Matrix-vector dot product of two arrays. Given a matrix (or stack of matrices) \(\mathbf{A}\) in x1 and
a vector (or stack of vectors) \(\mathbf{v}\) in x2 , the
matrix-vector product is defined as: \[\mathbf{A} \cdot \mathbf{b} = \sum_{j=0}^{n-1} A_{ij} v_j\] where the sum is over the last dimensions in x1 and x2 (unless axes is specified).  (For a matrix-vector product with the
vector conjugated, use np.vecmat(x2, x1.mT) .) New in version 2.2.0. Parameters : x1, x2 array_like Input arrays, scalars not allowed. out ndarray, optional A location into which the result is stored. If provided, it must have
the broadcasted shape of x1 and x2 with the summation axis
removed. If not provided or None, a freshly-allocated array is used. **kwargs For other keyword-only arguments, see the ufunc docs . Returns : y ndarray The matrix-vector product of the inputs. Raises : ValueError If the last dimensions of x1 and x2 are not the same size. If a scalar value is passed in. See also vecdot Vector-vector product. vecmat Vector-matrix product. matmul Matrix-matrix product. einsum Einstein summation convention. Examples Rotate a set of vectors from Y to X along Z. >>> a = np . array ([[ 0. , 1. , 0. ], ... [ - 1. , 0. , 0. ], ... [ 0. , 0. , 1. ]]) >>> v = np . array ([[ 1. , 0. , 0. ], ... [ 0. , 1. , 0. ], ... [ 0. , 0. , 1. ], ... [ 0. , 6. , 8. ]]) >>> np . matvec ( a , v ) array([[ 0., -1.,  0.], [ 1.,  0.,  0.], [ 0.,  0.,  1.], [ 6.,  0.,  8.]])


Page: https://numpy.org/doc/stable/reference/generated/numpy.vecmat.html#numpy.vecmat
numpy.vecmat # numpy. vecmat ( x1 , x2 , / , out=None , * , casting='same_kind' , order='K' , dtype=None , subok=True [ , signature , axes , axis ] ) = <ufunc 'vecmat'> # Vector-matrix dot product of two arrays. Given a vector (or stack of vector) \(\mathbf{v}\) in x1 and
a matrix (or stack of matrices) \(\mathbf{A}\) in x2 , the
vector-matrix product is defined as: \[\mathbf{b} \cdot \mathbf{A} = \sum_{i=0}^{n-1} \overline{v_i}A_{ij}\] where the sum is over the last dimension of x1 and the one-but-last
dimensions in x2 (unless axes is specified) and where \(\overline{v_i}\) denotes the complex conjugate if \(v\) is complex and the identity otherwise. (For a non-conjugated vector-matrix
product, use np.matvec(x2.mT, x1) .) New in version 2.2.0. Parameters : x1, x2 array_like Input arrays, scalars not allowed. out ndarray, optional A location into which the result is stored. If provided, it must have
the broadcasted shape of x1 and x2 with the summation axis
removed. If not provided or None, a freshly-allocated array is used. **kwargs For other keyword-only arguments, see the ufunc docs . Returns : y ndarray The vector-matrix product of the inputs. Raises : ValueError If the last dimensions of x1 and the one-but-last dimension of x2 are not the same size. If a scalar value is passed in. See also vecdot Vector-vector product. matvec Matrix-vector product. matmul Matrix-matrix product. einsum Einstein summation convention. Examples Project a vector along X and Y. >>> v = np . array ([ 0. , 4. , 2. ]) >>> a = np . array ([[ 1. , 0. , 0. ], ... [ 0. , 1. , 0. ], ... [ 0. , 0. , 0. ]]) >>> np . vecmat ( v , a ) array([ 0.,  4., 0.])


Page: https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul
numpy.matmul # numpy. matmul ( x1 , x2 , / , out=None , * , casting='same_kind' , order='K' , dtype=None , subok=True [ , signature , axes , axis ] ) = <ufunc 'matmul'> # Matrix product of two arrays. Parameters : x1, x2 array_like Input arrays, scalars not allowed. out ndarray, optional A location into which the result is stored. If provided, it must have
a shape that matches the signature (n,k),(k,m)->(n,m) . If not
provided or None, a freshly-allocated array is returned. **kwargs For other keyword-only arguments, see the ufunc docs . Returns : y ndarray The matrix product of the inputs.
This is a scalar only when both x1, x2 are 1-d vectors. Raises : ValueError If the last dimension of x1 is not the same size as
the second-to-last dimension of x2 . If a scalar value is passed in. See also vecdot Complex-conjugating dot product for stacks of vectors. matvec Matrix-vector product for stacks of matrices and vectors. vecmat Vector-matrix product for stacks of vectors and matrices. tensordot Sum products over arbitrary axes. einsum Einstein summation convention. dot alternative matrix product with different broadcasting rules. Notes The behavior depends on the arguments in the following way. If both arguments are 2-D they are multiplied like conventional
matrices. If either argument is N-D, N > 2, it is treated as a stack of
matrices residing in the last two indexes and broadcast accordingly. If the first argument is 1-D, it is promoted to a matrix by
prepending a 1 to its dimensions. After matrix multiplication
the prepended 1 is removed. (For stacks of vectors, use vecmat .) If the second argument is 1-D, it is promoted to a matrix by
appending a 1 to its dimensions. After matrix multiplication
the appended 1 is removed. (For stacks of vectors, use matvec .) matmul differs from dot in two important ways: Multiplication by scalars is not allowed, use * instead. Stacks of matrices are broadcast together as if the matrices
were elements, respecting the signature (n,k),(k,m)->(n,m) : >>> a = np . ones ([ 9 , 5 , 7 , 4 ]) >>> c = np . ones ([ 9 , 5 , 4 , 3 ]) >>> np . dot ( a , c ) . shape (9, 5, 7, 9, 5, 3) >>> np . matmul ( a , c ) . shape (9, 5, 7, 3) >>> # n is 7, k is 4, m is 3 The matmul function implements the semantics of the @ operator
introduced in Python 3.5 following PEP 465 . It uses an optimized BLAS library when possible (see numpy.linalg ). Examples For 2-D arrays it is the matrix product: >>> import numpy as np >>> a = np . array ([[ 1 , 0 ], ... [ 0 , 1 ]]) >>> b = np . array ([[ 4 , 1 ], ... [ 2 , 2 ]]) >>> np . matmul ( a , b ) array([[4, 1], [2, 2]]) For 2-D mixed with 1-D, the result is the usual. >>> a = np . array ([[ 1 , 0 ], ... [ 0 , 1 ]]) >>> b = np . array ([ 1 , 2 ]) >>> np . matmul ( a , b ) array([1, 2]) >>> np . matmul ( b , a ) array([1, 2]) Broadcasting is conventional for stacks of arrays >>> a = np . arange ( 2 * 2 * 4 ) . reshape (( 2 , 2 , 4 )) >>> b = np . arange ( 2 * 2 * 4 ) . reshape (( 2 , 4 , 2 )) >>> np . matmul ( a , b ) . shape (2, 2, 2) >>> np . matmul ( a , b )[ 0 , 1 , 1 ] 98 >>> sum ( a [ 0 , 1 , :] * b [ 0 , :, 1 ]) 98 Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated: >>> np . matmul ([ 2 j , 3 j ], [ 2 j , 3 j ]) (-13+0j) Scalar multiplication raises an error. >>> np . matmul ([ 1 , 2 ], 3 ) Traceback (most recent call last): ... ValueError : matmul: Input operand 1 does not have enough dimensions ... The @ operator can be used as a shorthand for np.matmul on
ndarrays. >>> x1 = np . array ([ 2 j , 3 j ]) >>> x2 = np . array ([ 2 j , 3 j ]) >>> x1 @ x2 (-13+0j)


Page: https://numpy.org/doc/stable/reference/generated/numpy.vecdot.html#numpy.vecdot
numpy.vecdot # numpy. vecdot ( x1 , x2 , / , out=None , * , casting='same_kind' , order='K' , dtype=None , subok=True [ , signature , axes , axis ] ) = <ufunc 'vecdot'> # Vector dot product of two arrays. Let \(\mathbf{a}\) be a vector in x1 and \(\mathbf{b}\) be
a corresponding vector in x2 . The dot product is defined as: \[\mathbf{a} \cdot \mathbf{b} = \sum_{i=0}^{n-1} \overline{a_i}b_i\] where the sum is over the last dimension (unless axis is specified) and
where \(\overline{a_i}\) denotes the complex conjugate if \(a_i\) is complex and the identity otherwise. New in version 2.0.0. Parameters : x1, x2 array_like Input arrays, scalars not allowed. out ndarray, optional A location into which the result is stored. If provided, it must have
the broadcasted shape of x1 and x2 with the last axis removed.
If not provided or None, a freshly-allocated array is used. **kwargs For other keyword-only arguments, see the ufunc docs . Returns : y ndarray The vector dot product of the inputs.
This is a scalar only when both x1, x2 are 1-d vectors. Raises : ValueError If the last dimension of x1 is not the same size as
the last dimension of x2 . If a scalar value is passed in. See also vdot same but flattens arguments first matmul Matrix-matrix product. vecmat Vector-matrix product. matvec Matrix-vector product. einsum Einstein summation convention. Examples >>> import numpy as np Get the projected size along a given normal for an array of vectors. >>> v = np . array ([[ 0. , 5. , 0. ], [ 0. , 0. , 10. ], [ 0. , 6. , 8. ]]) >>> n = np . array ([ 0. , 0.6 , 0.8 ]) >>> np . vecdot ( v , n ) array([ 3.,  8., 10.])


Page: https://github.com/numpy/numpy/pull/25675



Page: https://github.com/numpy/numpy/pull/27420



Page: https://github.com/numpy/numpy/pull/27736



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#improvements
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/14622



Page: https://github.com/numpy/numpy/pull/27636



Page: https://numpy.org/doc/stable/reference/generated/numpy.memmap.html#numpy.memmap
numpy.memmap # class numpy. memmap ( filename , dtype=<class 'numpy.ubyte'> , mode='r+' , offset=0 , shape=None , order='C' ) [source] # Create a memory-map to an array stored in a binary file on disk. Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  NumPy’s
memmap’s are array-like objects.  This differs from Python’s mmap module, which uses file-like objects. This subclass of ndarray has some unpleasant interactions with
some operations, because it doesn’t quite fit properly as a subclass.
An alternative to using this subclass is to create the mmap object yourself, then create an ndarray with ndarray.__new__ directly,
passing the object created in its ‘buffer=’ parameter. This class may at some point be turned into a factory function
which returns a view into an mmap buffer. Flush the memmap instance to write the changes to the file. Currently there
is no API to close the underlying mmap . It is tricky to ensure the
resource is actually closed, since it may be shared between different
memmap instances. Parameters : filename str, file-like object, or pathlib.Path instance The file name or file object to be used as the array data buffer. dtype data-type, optional The data-type used to interpret the file contents.
Default is uint8 . mode {‘r+’, ‘r’, ‘w+’, ‘c’}, optional The file is opened in this mode: ‘r’ Open existing file for reading only. ‘r+’ Open existing file for reading and writing. ‘w+’ Create or overwrite existing file for reading and writing.
If mode == 'w+' then shape must also be specified. ‘c’ Copy-on-write: assignments affect data in memory, but
changes are not saved to disk.  The file on disk is
read-only. Default is ‘r+’. offset int, optional In the file, array data starts at this offset. Since offset is
measured in bytes, it should normally be a multiple of the byte-size
of dtype . When mode != 'r' , even positive offsets beyond end of
file are valid; The file will be extended to accommodate the
additional data. By default, memmap will start at the beginning of
the file, even if filename is a file pointer fp and fp.tell() != 0 . shape int or sequence of ints, optional The desired shape of the array. If mode == 'r' and the number
of remaining bytes after offset is not a multiple of the byte-size
of dtype , you must specify shape . By default, the returned array
will be 1-D with the number of elements determined by file size
and data-type. Changed in version 2.0: The shape parameter can now be any integer sequence type, previously
types were limited to tuple and int. order {‘C’, ‘F’}, optional Specify the order of the ndarray memory layout: row-major , C-style or column-major ,
Fortran-style.  This only has an effect if the shape is
greater than 1-D.  The default order is ‘C’. See also lib.format.open_memmap Create or load a memory-mapped .npy file. Notes The memmap object can be used anywhere an ndarray is accepted.
Given a memmap fp , isinstance(fp, numpy.ndarray) returns True . Memory-mapped files cannot be larger than 2GB on 32-bit systems. When a memmap causes a file to be created or extended beyond its
current size in the filesystem, the contents of the new part are
unspecified. On systems with POSIX filesystem semantics, the extended
part will be filled with zero bytes. Examples >>> import numpy as np >>> data = np . arange ( 12 , dtype = 'float32' ) >>> data . resize (( 3 , 4 )) This example uses a temporary file so that doctest doesn’t write
files to your directory. You would use a ‘normal’ filename. >>> from tempfile import mkdtemp >>> import os.path as path >>> filename = path . join ( mkdtemp (), 'newfile.dat' ) Create a memmap with dtype and shape that matches our data: >>> fp = np . memmap ( filename , dtype = 'float32' , mode = 'w+' , shape = ( 3 , 4 )) >>> fp memmap([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]], dtype=float32) Write data to memmap array: >>> fp [:] = data [:] >>> fp memmap([[  0.,   1.,   2.,   3.], [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.]], dtype=float32) >>> fp . filename == path . abspath ( filename ) True Flushes memory changes to disk in order to read them back >>> fp . flush () Load the memmap and verify data was stored: >>> newfp = np . memmap ( filename , dtype = 'float32' , mode = 'r' , shape = ( 3 , 4 )) >>> newfp memmap([[  0.,   1.,   2.,   3.], [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.]], dtype=float32) Read-only memmap: >>> fpr = np . memmap ( filename , dtype = 'float32' , mode = 'r' , shape = ( 3 , 4 )) >>> fpr . flags . writeable False Copy-on-write memmap: >>> fpc = np . memmap ( filename , dtype = 'float32' , mode = 'c' , shape = ( 3 , 4 )) >>> fpc . flags . writeable True It’s possible to assign to copy-on-write array, but values are only
written into the memory copy of the array, and not written to disk: >>> fpc memmap([[  0.,   1.,   2.,   3.], [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.]], dtype=float32) >>> fpc [ 0 ,:] = 0 >>> fpc memmap([[  0.,   0.,   0.,   0.], [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.]], dtype=float32) File on disk is unchanged: >>> fpr memmap([[  0.,   1.,   2.,   3.], [  4.,   5.,   6.,   7.], [  8.,   9.,  10.,  11.]], dtype=float32) Offset into a memmap: >>> fpo = np . memmap ( filename , dtype = 'float32' , mode = 'r' , offset = 16 ) >>> fpo memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32) Attributes : filename str or pathlib.Path instance Path to the mapped file. offset int Offset position in the file. mode str File mode. Methods flush () Write any changes in the array to the file on disk.


Page: https://github.com/numpy/numpy/pull/27723



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#f2py-handles-multiple-modules-and-exposes-variables-again
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/27695



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#performance-improvements-and-changes
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/27896



Page: https://github.com/numpy/numpy/pull/27119



Page: https://github.com/numpy/numpy/pull/27147



Page: https://github.com/numpy/numpy/pull/27808



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#changes
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://numpy.org/doc/stable/reference/generated/numpy.fix.html#numpy.fix
numpy.fix # numpy. fix ( x , out = None ) [source] # Round to nearest integer towards zero. Round an array of floats element-wise to nearest integer towards zero.
The rounded values have the same data-type as the input. Parameters : x array_like An array to be rounded out ndarray, optional A location into which the result is stored. If provided, it must have
a shape that the input broadcasts to. If not provided or None, a
freshly-allocated array is returned. Returns : out ndarray of floats An array with the same dimensions and data-type as the input.
If second argument is not supplied then a new array is returned
with the rounded values. If a second argument is supplied the result is stored there.
The return value out is then a reference to that array. See also rint , trunc , floor , ceil around Round to given number of decimals Examples >>> import numpy as np >>> np . fix ( 3.14 ) 3.0 >>> np . fix ( 3 ) 3 >>> np . fix ([ 2.1 , 2.9 , - 2.1 , - 2.9 ]) array([ 2.,  2., -2., -2.])


Page: https://github.com/numpy/numpy/pull/26766



Page: https://github.com/numpy/numpy/pull/27334



Page: https://github.com/numpy/numpy/pull/27482



Page: https://github.com/numpy/numpy/pull/27807



Page: https://github.com/pypa/manylinux/issues/1629



Page: https://github.com/numpy/numpy/pull/27088



Page: https://numpy.org/doc/stable/release/2.2.0-notes.html#nep-50-promotion-state-option-removed
NumPy 2.2.0 Release Notes # The NumPy 2.2.0 release is quick release that brings us back into sync with the
usual twice yearly release cycle. There have been an number of small cleanups,
as well as work bringing the new StringDType to completion and improving support
for free threaded Python. Highlights are: New functions matvec and vecmat , see below. Many improved annotations. Improved support for the new StringDType. Improved support for free threaded Python Fixes for f2py This release supports Python versions 3.10-3.13. Deprecations # _add_newdoc_ufunc is now deprecated. ufunc.__doc__ = newdoc should
be used instead. ( gh-27735 ) Expired deprecations # bool(np.array([])) and other empty arrays will now raise an error.
Use arr.size > 0 instead to check whether an array has no elements. ( gh-27160 ) Compatibility notes # numpy.cov now properly transposes single-row (2d array) design matrices
when rowvar=False . Previously, single-row design matrices would return a
scalar in this scenario, which is not correct, so this is a behavior change
and an array of the appropriate shape will now be returned. ( gh-27661 ) New Features # New functions for matrix-vector and vector-matrix products Two new generalized ufuncs were defined: numpy.matvec - matrix-vector product, treating the arguments as
stacks of matrices and column vectors, respectively. numpy.vecmat - vector-matrix product, treating the arguments as
stacks of column vectors and matrices, respectively. For complex
vectors, the conjugate is taken. These add to the existing numpy.matmul as well as to numpy.vecdot ,
which was added in numpy 2.0. Note that numpy.matmul never takes a complex conjugate, also not
when its left input is a vector, while both numpy.vecdot and numpy.vecmat do take the conjugate for complex vectors on the
left-hand side (which are taken to be the ones that are transposed,
following the physics convention). ( gh-25675 ) np.complexfloating[T, T] can now also be written as np.complexfloating[T] ( gh-27420 ) UFuncs now support __dict__ attribute and allow overriding __doc__ (either directly or via ufunc.__dict__["__doc__"] ). __dict__ can be
used to also override other properties, such as __module__ or __qualname__ . ( gh-27735 ) The “nbit” type parameter of np.number and its subtypes now defaults
to typing.Any . This way, type-checkers will infer annotations such as x: np.floating as x: np.floating[Any] , even in strict mode. ( gh-27736 ) Improvements # The datetime64 and timedelta64 hashes now correctly match the Pythons
builtin datetime and timedelta ones.  The hashes now evaluated equal
even for equal values with different time units. ( gh-14622 ) Fixed a number of issues around promotion for string ufuncs with StringDType
arguments. Mixing StringDType and the fixed-width DTypes using the string
ufuncs should now generate much more uniform results. ( gh-27636 ) Improved support for empty memmap . Previously an empty memmap would fail
unless a non-zero offset was set. Now a zero-size memmap is supported
even if offset=0 . To achieve this, if a memmap is mapped to an empty
file that file is padded with a single byte. ( gh-27723 ) f2py handles multiple modules and exposes variables again # A regression has been fixed which allows F2PY users to expose variables to
Python in modules with only assignments, and also fixes situations where
multiple modules are present within a single source file. ( gh-27695 ) Performance improvements and changes # Improved multithreaded scaling on the free-threaded build when many threads
simultaneously call the same ufunc operations. ( gh-27896 ) NumPy now uses fast-on-failure attribute lookups for protocols.  This can
greatly reduce overheads of function calls or array creation especially with
custom Python objects.  The largest improvements will be seen on Python 3.12
or newer. ( gh-27119 ) OpenBLAS on x86_64 and i686 is built with fewer kernels. Based on
benchmarking, there are 5 clusters of performance around these kernels: PRESCOTT NEHALEM SANDYBRIDGE HASWELL SKYLAKEX . OpenBLAS on windows is linked without quadmath, simplifying licensing Due to a regression in OpenBLAS on windows, the performance improvements
when using multiple threads for OpenBLAS 0.3.26 were reverted. ( gh-27147 ) NumPy now indicates hugepages also for large np.zeros allocations
on linux.  Thus should generally improve performance. ( gh-27808 ) Changes # numpy.fix now won’t perform casting to a floating data-type for integer
and boolean data-type input arrays. ( gh-26766 ) The type annotations of numpy.float64 and numpy.complex128 now
reflect that they are also subtypes of the built-in float and complex types, respectively. This update prevents static type-checkers from reporting
errors in cases such as: x : float = numpy . float64 ( 6.28 ) # valid z : complex = numpy . complex128 ( - 1 j ) # valid ( gh-27334 ) The repr of arrays large enough to be summarized (i.e., where elements
are replaced with ... ) now includes the shape of the array, similar
to what already was the case for arrays with zero size and non-obvious
shape. With this change, the shape is always given when it cannot be
inferred from the values.  Note that while written as shape=... , this
argument cannot actually be passed in to the np.array constructor. If
you encounter problems, e.g., due to failing doctests, you can use the print
option legacy=2.1 to get the old behaviour. ( gh-27482 ) Calling __array_wrap__ directly on NumPy arrays or scalars now does the
right thing when return_scalar is passed (Added in NumPy 2).  It is
further safe now to call the scalar __array_wrap__ on a non-scalar
result. ( gh-27807 ) Bump the musllinux CI image and wheels to 1_2 from 1_1. This is because 1_1 is end of life . ( gh-27088 ) NEP 50 promotion state option removed # The NEP 50 promotion state settings are now removed. They were always meant as
temporary means for testing.  A warning will be given if the environment
variable is set to anything but NPY_PROMOTION_STATE=weak while _set_promotion_state and _get_promotion_state are removed.  In case
code used _no_nep50_warning , a contextlib.nullcontext could be used to
replace it when not available. ( gh-27156 )


Page: https://github.com/numpy/numpy/pull/27156

