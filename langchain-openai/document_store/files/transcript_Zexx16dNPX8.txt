[00:00:00] hey everyone welcome back and let's write some more neat code today so today let's solve the problem alternating groups 2 if I'm being 100% honest this is one of those problems where it took me most of the time to like just understand exactly what it's asking for I think it took me like five minutes honestly to understand exactly what it was asking for and then it took about like 2 minutes to code up the solution so uh let's go ahead and get into it the idea is that we are given an input array they call it colors but you really don't really need need all that context it
[00:00:31] doesn't really change the problem so suppose the input is like this 0 1 0 1 Z so the nature of this array is that it's supposed to be circular so technically the last element and the first element are adjacent we're also given another parameter K I believe K is always going to be less than or equal to the size of the input array in this example it's going to be three and that's because we want to look at subarrays of size K so
[00:01:05] before even getting into what this problem is asking for how many subarrays of size K would there even be I mean obviously there's that one and then there's this one and then there's this one so now you might think we're done but don't forget that the nature of the array is that it is circular I don't know if this uh picture over here is going to help you it doesn't really help me that much I think honestly just sticking with the array is a little bit easier so like this would actually be another subarray like this and that and
[00:01:37] then another one would be this and then these come after that and then that's pretty much it because then if we start over then we kind of just get this which is something we already saw before and now among all of those subarrays we want to count how many of them are alternating so if you look at this first one here it's 0 1 0 all the values are alternating okay great look at the next subarray all of them 1 0 1 they're all
[00:02:09] alternating the next one 0 1 0 those are alternating so so far we've counted three so if our result was keeping track of the count so far we have three now let's look at this one which is if I were to draw it out one 0 and then this one over here which is zero they are not alternating these two adjacent elements are the same okay and then one more is going to be this zero and then these next two Z and one again not alternating
[00:02:41] so this one also doesn't count and that's pretty much it now we are done so the result for the first example is going to be three okay so now we know what exactly we're trying to do we kind of just saw like one way to solve this without necessarily knowing all the implementation details that Brute Force simulation that I kind of ran in the worst case it'd be n * K cuz we're going to have n different sub Rays each is going to be of size K we can kind of verify if they're alternating or Not by like scanning through it and so that's one way to solve the problem and the
[00:03:13] optimization I guess I'll just tell you because to be honest in my mind it's so trivial I'll show you the intuition of how you can like dve it or like think about it but it's it's just the sliding window it's a very kind of common pattern it's something I've talked about a lot on this channel talked about a lot on N code iio many courses and lessons for it on nikio if you're interested but using that and also using a little trick for dealing with circular arrays we are going to be able to solve this problem pretty dang easily so let me show you
[00:03:43] that so sometimes when dealing with circular arrays I like to or like a common trick is just to take the original array and then concatenate it to itself so if this was the original array and we concatenate it with itself the main reason to do that would be cuz then you can do something like this if uh this is just the entire array and then we take that entire array and just copy it so now we have 0 1 0 1 zero so this is like the copy of the array I'm
[00:04:15] just going to kind of make this cleaner this would be a technique to deal with like the circular nature this is not trying to like optimize the solution it's just dealing with like the circular nature of it then we could just get every single window of size three right well this would be the first window it's a valid window next window valid next window valid next window it's valid next window it's valid but after that the next window from here we would just be repeating the window that we already saw over here there's no
[00:04:46] need to repeat the window every window before that was not repeating because like we had the window that's starting here going up till here then we had this window then we had this window then we had this window then we had this window none of these were repeating but this one would be so we can't easily just do that just concatenate the array I guess you could but then you'd have to know like where the stopping point is and also if we were to do that we would have to create a new array and it's actually possible to not create the new array so
[00:05:18] how many times are we going to iterate past uh the ending point well this is the window we would not want to include so basically it's going to be K minus one those are like the extra elements we want to sort of add to the end of here so like just forget everything past this we just want to take the first K minus one elements and sort of put them over there but we don't even have to put them over there we can do something even more clever we can have our eye pointer
[00:05:50] normally we'd want to go from the beginning up until the end here but now we're going to actually say Okay iterate kus1 one extra time so we iterate through the input and then we iterate over this little Gap over here that's going to be K minus1 elements long and we can access these elements because we know these elements are the same ones that are over here anyway and we can do that without having to copy them there by doing this like what if my ey pointer goes out of bounds that's probably what
[00:06:21] you're worried of right if I had my eye pointer over here and I'm trying to index the original array well I'm going to get an index out of bounds error but why not do something like this take nums and whatever I happens to be even if it's out of bounds take it mod it by uppercase n where let's say uppercase n is the length of the input that's this section uppercase n this section is K minus one long so then if I mod it by uppercase n well then uh this is going to bring me back over here this is going
[00:06:55] to bring me back over there so I don't have to put these elements there to know what they are it's going to be zero and one so that's a little technique I'm going to use to deal with the circular nature and now we kind of know what the stopping point is going to be as well okay now for the optimization for the fact that we don't have to go through each of these windows we don't have to go through the entire window every single time because this is what I'm going to do I'm going to do a little sliding window optimization I'm going to
[00:07:25] cut down on the repeated work because I can do this first I'm going to have two pointers I'm going to have my left pointer and I'm going to have my right pointer after that I'm going to compare these two elements I'm going to see that they are different that's good so I'm going to now expand my window I'm going to move my right pointer to be over here the right pointer is still different than the previous element that's good because we want these values to be alternating that's all we care about we only have to compare the newest element that we added with the previous one because we assume everything else is
[00:07:56] alternating okay and then our right pointer is over here now when our window is of size K since R minus left + 1 that tells us the size of the window it's equal to k then we know we have an alternating window we can increment our result by one so if I'm keeping track of my result I will now set it to be one so now I'm going to shift my right pointer one more time I'm over here great it's still alternating but right now my window is actually too big so what do I
[00:08:27] do well as soon as it becomes too big we will just shift the left pointer by one that will ensure that once we shift the left pointer now our window is exactly the size that we want it to be it is of size K and the window is valid that's great okay so now we just kind of keep going we found that this is a valid window we increment uh the result by one now it's going to be two I'm going to take my right pointer shift it again it's going to be over here compare it to the previous element still alternating shift the left pointer by one since the window is too big it's of size K now great found another valid window in the
[00:08:59] result by one now we're at three once again shift the right pointer this is where things are going to get interesting shift the right pointer over here compare this element which is going to be nums of I since it's out of bounds we are still going to mod by uppercase n we're always actually going to be modding by uppercase n if we were in bounds that uppercase n like modding math wouldn't really do anything when we're out of bounds it'll bring us back in bounds but anyways we will compare this element with the pre one and now
[00:09:30] they're the same so now think about what we do if you're not familiar with the sliding window you might not know what to do at this point but basically we are going to slide the window we're going to say the left pointer has to be shifted because if these two adjacent elements are equal by including both of these in the same window we will never have an alternating window we'll never have alternating elements so we cannot include both of these values so we're going to take our left pointer and shift
[00:10:00] it all the way to where we are currently right now our window is too small technically this window of size one is alternating but it's too small so we can't really update the result uh now we will shift the right pointer again the right pointer will be over here these are technically alternating but this is the stopping point we don't really go any further than that because at that point we'd be repeating a window that we've already seen over here so that's the idea behind this solution we can get it it to be a linear time solution and
[00:10:32] constant space if you're new to the sliding window pattern highly recommend checking out n code iio but let's code this up now okay so I'm going to get the length of the input and store it in a variable cuz we're going to need it to do that mod math I'm going to have my left pointer initialize it to zero I'm going to have my result which is what we are going to return sorry I can't type today um over there and then I'm going to have my right pointer just in a ized in the for Loop and I'm not going to start it at zero I'm going to start it
[00:11:02] at one so we can compare it with the previous element and we're going to go not up until n but to n we're going to add K minus1 and you could just write it like this to keep it simple and so now we're going to do that comparison we want these to be alternating so we're going to check if colors at index R is equal to colors at Rus one if that's the case they're not alternating and then we
[00:11:33] shift the left pointer to be equal to the right pointer otherwise we wouldn't do anything so that's why I'm not putting the case where they're not equal because if they're not equal we don't really have to do anything we just expanded our window but if they're equal then we shift and also don't forget the math to mod this by um n and to mod this index by n as well okay after that the main thing we're looking for is is if r - L + 1 that's the size of the window if
[00:12:03] that's exactly equal to k then we know that we always make sure that the window is alternating if it's not alternating then we shrink the window but if the window is of size K we assume it's alternating so then we can increment the result of course the window could become greater than K as well at that point we would then increment our left pointer so right before we check this let's do this right minus left + one if it's greater than k then just shrink it by one and because of that the window will never be greater than K by more than one so as
[00:12:35] soon as we increment the left pointer then the size should be equal to K at that point so that's the entire solution I'm going to run it for you and you can see here it works it's pretty efficient I promise you that this is pretty much as efficient as you can get I mean let's take a look at this person's solution who got slightly better runtime by like 40 milliseconds and let's see what their solution is and yeah it looks like it's pretty much the exact same in terms of like time complexity if anything it looks like it's even less efficient the fact that they're updating the input array and it kind of looks
[00:13:07] like this is GPT generated to be honest and speaking of GPT generated I mean have you guys been looking at these editorials recently I mean somebody tell me that these are not GPT generated first of all like there's no space between these like it's hard to believe that like a human wrote this but I mean look at these God awful Solutions they're just way more complicated than they need to be if a human is writing these I mean that human should be asham of themselves I mean look at this like this is the best that they could do to get this to be a constant time solution and this one pass solution I mean look at this like I guess this one's not too
[00:13:39] bad but still I feel like my solution uh is pretty preferable I mean this is very very simple stuff but anyways this is linear time I guess you could say that the time complexity is uh n plus K but I mean k is going to be less than n anyway so I feel like saying it's O of n is also pretty accurate it is a con space solution if you found this helpful check out n code iio for a lot more thanks for watching and I'll see you soon